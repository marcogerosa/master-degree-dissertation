Diversos pesquisadores propuseram cheiros de código e práticas recomendadas para tecnologias ou plataformas específicas, como frameworks Java [AA, FinavaroAniche2016], linguagem Cascading Style Sheets (CSS) [CSSCodeSmell] e fórmulas em planilhas [54].

Chen et al. [AA] afirma que frameworks Object-Relational Mapping (ORM) são amplamente utilizado na indústria. No entanto, os desenvolvedores geralmente escrevem código ORM sem considerar o impacto desse código no desempenho de banco de dados, levando a causar transações com "timeout" ou travamentos em sistemas em larga escala. Chen et al. [AA] soluciona este problema com implementação de um framework automatizado e sistemático para detectar e priorizar anti-patterns de desempenho para aplicações desenvolvidas usando ORM. Estudos de caso mostraram que o framework pode detectar centenas ou milhares de instâncias de anti-patterns de desempenho ao mesmo tempo que prioriza efetivamente a correção dessas instâncias [AA]. Foi descoberto que a correção dessas instâncias de anti-patterns de desempenho pode melhorar o tempo de resposta dos sistemas em até 98% (e, em média, 35%). Além do framework que é extensível podendo agregar outros anti-patterns, Chen et al. [AA] contribui com o mapeamento de 2 anti-patterns específicos a frameworks ORM.

Aniche et al. [FinavaroAniche2016] também investigou cheiros de código relacionado a um framework. Segundo o autor, para escrever código fácil de ser mantido e evoluído, e detectar pedaços de código problemáticos, desenvolvedores fazem uso de métricas de código e estratégias de detecção de maus cheiros de código. No entanto, métricas de código e estratégias de detecção de maus cheiros de código não levam em conta a arquitetura do software em análise o que significa que todas classes são avaliadas como se umas fossem iguais às outras. Aniche et al. [FinavaroAniche2016] afirma que cada papel arquitetural possui resposabilidades diferentes o que resulta em distribuições diferentes de valores de métrica de código. Mostra ainda que classes que cumprem um papel arquitetural específico, como por exemplo \textsc{Controllers}, também contêm maus cheiros de código específicos. Uma das contribuições de Aniche et al. é um catálogo com 6 cheiros de códigos específicos ao framework Spring MVC mapeados e validados.

CSS é amplamente utilizado nas aplicações web de hoje para separar a semântica de apresentação do conteúdo HTML [CSSCodeSmell]. De acordo como Gharachorlu [CSSCodeSmell] apesar da simplicidade de síntaxe do CSS, as características específicas da linguagem tornam a criação e manutenção de CSS uma tarefa desafiadora. Foi realizando um estudo empírico de larga escala em 500 sites, 5060 arquivos no total, que consistem de mais de 10 milhões de linhas de código CSS. Segundo o autor, os resultados indicaram que o CSS de hoje sofre significativamente de padrões inadequados e está longe de ser um código bem escrito. Porfim Gharachorlu [CSSCodeSmell] propõe o primeiro modelo de qualidade de código CSS derivado de uma grande amostra de aprendizagem de modo a ajudar desenvolvedores a obter uma estimativa do número total de cheiros de código em seu código CSS. Sua principal contrinbuição foi oito novos cheiros de código CSS detectados com o uso da ferramenta CSSNose, também implementada e disponibilizada pelo autor.

Javascript é uma flexível linguagem de script para o desenvolvimento de aplicações Web 2.0 [BB]. Fard e Ali [BB] afirmam que devido à essa flexibilidade, o JavaScript é uma linguagem particularmente desafiadora para escrevere manter código. Os desafios são múltiplos: Primeiro, é uma linguagem interpretada, o que significa que normalmente não há compilador no ciclo de desenvolvimento que ajudaria os desenvolvedores a detectar código incorreto ou não otimizado. Segundo, tem uma natureza dinâmica, fracamente tipificada, assíncrona. Terceiro, ele suporta recursos intrincados, como prototypes [CC], funções de primeira classe e "closures" [DD]. E finalmente, ele interage com o DOM através de um mecanismo complexo baseado em eventos [EE]. Os autores propõem um conjunto de 13 cheiros de código JavaScript, sendo 7 cheiros de códigos bem conhecidos adaptados para o JavaScript e 6 tipos específicos de códigos de JavaScript devidos do trabalho. Também é apresentada uma técnica automatizada, chamada JSNOSE, para detectar esses cheiros de código.


