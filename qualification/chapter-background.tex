% -*- root: dissertacao.tex -*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setlength{\parindent}{20pt}
\setlength{\textheight}{22cm}
\setlength{\parskip}{0.2cm}
\linespread{1.2} % Para aumentar o espaçamento entre as linhas
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Fundamentação Conceitual}
\label{cap:background}

Para a compreensão deste trabalho é importante ter compreensão de dois temas: Maus Cheiros de Código e Android.

% \section{Refatoração}


\section{Maus Cheiros de Código}
\label{sec:MausCheiros}

Maus cheiros de código são sintomas de design ruim e más práticas de programação \cite{WikiCodeSmell, FinavaroAniche2016, Refactoring:99, MobileSmells:13}. Também conhecido por anomalias de código \cite{padilha2013detecccao}. Diferentemente de erros sistêmicos, eles não resultam em comportamentos errôneos \cite{WikiCodeSmell, MobileSmells:13}. Maus cheiros apontam fraquezas no \textit{design} que podem desacelerar o desenvolvimento e aumentar o risco a defeitos, falhas e mudanças \cite{WikiCodeSmell, FinavaroAniche2016, Khomh:2012:ESI:2158916.2158921, DomainMatters}. Do ponto de vista do desenvolvedor, maus cheiros são heurísticas para refatorações que indicam quando refatorar e qual técnica de refatoração usar \cite{WikiCodeSmell}.

Refatoração é definido por Fowler como ``uma técnica para reestruturação de um código existente, alterando sua estrutura interna sem alterar seu comportamento externo'' \cite{Refactoring:99}. Escolher não resolver um mau cheiro pela refatoração não resultará na aplicação falhar mas irá aumentar a dificuldade de mantê-la. A refatoração ajuda a melhorar a manutenibilidade de uma aplicação \cite{MobileSmells:13}. Uma vez que os custos com manutenção são a maior parte dos custos envolvidos no ciclo de desenvolvimento de software, aumentar a manutenibilidade através de refatoração irá reduzir os custos de um software no longo prazo \cite{RefactoringAndImprovements:10}. 

O livro de Webster (1995) \cite{Webster} deve ter sido um dos primeiros onde o termo cheiro de código, referindo-se a más práticas, foi usado. Mais adiante, \textbf{mau cheiro de código} foi usado por Martin Fowler e Kent Beck no livro Refactoring (1999) \cite{Refactoring:99} referindo-se a um trecho de código que pode se beneficiar de refatoração. Em uma postagem em 2006 em seu site \cite{CodeSmell:06}, Martin Fowler define um \textbf{cheiro de código} como sendo ``uma indicação superficial no código que usualmente corresponde a um problema mais profundo no sistema'' e complementa dizendo que ``primeiramente um mau cheiro é por definição algo rápido de ser detectado - farejável - e segundo, que um mau cheiro nem sempre indica um problema' (tradução livre). 

Note que o termo usado no livro Refactoring (1999) \cite{Refactoring:99} é mau cheiro de código (\textit{bad smell in code}) e na postagem em seu site \cite{CodeSmell:06} é cheiro de código (\textit{code smell}). Essa diferença pode ser justificada pela afirmativa de Fowler, na postagem em seu site, em que diz que ``cheiros de código não são inerentemente ruins por conta própria - eles são muitas vezes um indicador de um problema e não o problema em si'' (tradução livre).

No livro Refactoring for Software Design Smells (2014) \cite{Suryanarayana2014Refactoring} encontramos uma definição sobre cheiro de código relacionada a princípios e qualidade, onde diz que ``[cheiros de código] são certas estruturas que indicam violação de princípios de \textit{design} fundamentais e impactam negativamente na qualidade do \textit{design}''. De fato, pesquisas têm apontado que maus cheiros de código estão relacionados à degradação da qualidade em projetos de software \cite{ReimannBrylski2013}.

Outro termo comum de se ver juntamente com (mau) cheiro de código é o termo \textit{antipattern}, também conhecido como má prática. Esse, por sua vez, descreve uma solução comum para um problema que gera consequências negativas \cite{WilleyAntiPatterns}. Pode ser resultado de um desenvolvedor não ter conhecimento suficiente ou experiência em resolver um determinado tipo de problema, ou ter aplicado um \textit{design pattern}, solução reutilizável para um problema de \textit{design} recorrente \cite{WilleyAntiPatterns, gof}, perfeitamente bom no contexto errado \cite{WilleyAntiPatterns}. Geralmente, (maus) cheiros de código são sintomas da presença de \textit{antipattern}. Linares et al. \cite{DomainMatters} concluem que \textit{antipatterns} impactam de forma negativa aplicações móveis, em particular métricas de qualidade relacionadas ao aumento do risco de falhas.

Para auxiliar no processo de refatoração, é comum desenvolvedores se utilizarem de ferramentas de detecção de cheiros de código \cite{FinavaroAniche2016}, sintomas de design ruim e más práticas de programação \cite{WikiCodeSmell, FinavaroAniche2016, Refactoring:99, MobileSmells:13}. Para automatizar a detecção de cheiros de código, é importante tê-los mapeados e catalogados. Muitos cheiros de código já foram catalogados \cite{Refactoring:99,Suryanarayana2014Refactoring, Webster}. 

Diversos autores já trabalharam na definição de diferentes catálogos de cheiros de código. Riel \cite{Riel} definiu mais de 60 características de um bom código orientado a objetos. Fowler \cite{Refactoring:99} definiu mais de 20 maus cheiros como \textit{God Classes} \cite{Refactoring:99}, que são classes que fazem ou sabem muitas coisas e \textit{Feature Envy} \cite{Refactoring:99}, que são métodos que estão mais interessados em outras classes do que na própria classe. Existem diversas ferramentas atualmente que conseguem realizar a detecção automática de diversos desses maus cheiros como PMD \cite{PMD2016} e Sonar \cite{Sonarqube2016}.

No entanto, nas principais conferências de manutenção de software, dentre 2008 a 2015, 5 de um total de 52 artigos, foram sobre maus cheiros Android \cite{Mannan_Dig_Ahmed_Jensen_Abdullah_Almurshed}. A ausência de um catálogo de maus cheiros Android resulta em (i) uma carência de conhecimento sobre boas e más práticas a ser compartilhado entre praticantes da plataforma, (ii) indisponibilidade de uma ferramenta de detecção de maus cheiros de modo a alertar automaticamente os desenvolvedores de sua existência e (iii) ausência de estudo empírico sobre o impacto dessas más práticas na manutenibilidade do código de projetos Android. 

Nesta dissertação utilizamos o termo \textbf{cheiro de código} para nos referir a ambos os termos (mau) cheiro de código, \textit{antipattern} e anomalias de código, como em trabalhos prévios \cite{DomainMatters, Moha_Gueheneuc_Meur_Duchien_2008, padilha2013detecccao}, e nosso foco está em definir e detectar maus cheiros relacionados especificamente à camada de apresentação de projetos Android.

\section{Android}
\label{sec:Android}

Atualmente o Android é a plataforma móvel com maior crescimento. Em 2017 completará uma década do seu lançamento \cite{AndroidHistory}. A Figura \ref{fig:AndroidMarketShare} apresenta a quantidade de dispositivos vendidos para cada plataforma móvel, no período de 2009 à 2016 \cite{SmartphoneSales:09-16}. É possível observar que no Q1 de 2016, foram vendidos aproximadamente 300 milhões de dispositivos com Android contra aproximadamente 50 milhões com iOS, seu concorrente mais próximo.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.9\textwidth]{mobile-market-share-bars.png}
	\caption{Unidades de dispositivos vendidos por plataforma móvel \cite{SmartphoneSales:09-16}.}
	\label{fig:AndroidMarketShare}
\end{figure}

Com o crescimento da plataforma, a demanda por aplicativos também aumentou. Na Figura \ref{fig:GooglePlayStore} é possível acompanhar o crescimento da quantidade de aplicativos disponíveis na Google Play Store \footnote{Google Play Store (originalmente Android Market) é a loja oficial de aplicativos Android. Pode ser acessada pelo URL https://play.google.com/store \cite{WikiGooglePlay}.} ao longo de 2009 até 2016, sendo que nesse último ano, superou 200 milhões de aplicativos disponíveis \cite{AppInPlayStore:09-16}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.9\textwidth]{play-store-apps-09to16.png}
	\caption{Quantidade de aplicativos disponíveis na Google Play Store \cite{AppInPlayStore:09-16}.}
	\label{fig:GooglePlayStore}
\end{figure}


% \subsection{Arquitetura da Plataforma} 
Android é um sistema operacional de código aberto, baseado no kernel do Linux criado para um amplo conjunto de dispositivos. Na Figura \ref{fig:AndroidPlatform} é apresentada a arquitetura geral da plataforma Android. Todas as funcionalidades da plataforma Android estão disponíveis para os aplicativos por meio de APIs Java (\textit{Application Programming Interface}). Essas APIs compõem os elementos básicos para a construção de aplicativos Android.

% Para prover acesso aos recursos específicos dos dispositivos como câmera ou \textit{bluetooth}, o Android possui uma camada de abstração de \textit{hardware} (HAL do inglês \textit{Hardware Abstraction Layer}) exposto aos desenvolvedores por meio de um arcabouço de Interfaces de Programação de Aplicativos Java (API - \textit{Applications Programming Interface}). 

% Estes e outros elementos explicados a seguir podem ser visualizados na Figura \ref{fig:AndroidPlatform} \cite{AndroidPlatformArchitecture}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.7\textwidth]{android-architecture.png}
	\caption{Arquitetura do sistema operacional Android \cite{AndroidPlatformArchitecture}.}
	\label{fig:AndroidPlatform}
\end{figure}

% Cada aplicativo é executado em um novo processo de sistema que contém sua própria instância do ambiente de execução Android. A partir da versão 5 (API nível 21), o ambiente de execução padrão é o Android Runtime (ART), antes dessa versão era a Dalvik. ART foi escrita para executar multiplas instâncias de máquina virtual em dispositivos com pouca memória. Suas funcionalidades incluem: duas forma de compilação, a frente do tempo (AOT do inglês \textit{Ahead-of-time}) e apenas no momento (JIT do inglês \textit{Just-in-time}), o coletor de lixo, ferramentas de depuração e um relatório de diagnósticos de erros e exceções.

% Muitos dos componentes e serviços básicos do Android, como ART e HAL, foram criados a partir de código nativo que depende de bibliotecas nativas escritas em C e C++. A plataforma Android provê arcabouços de APIs Java para expôr as funcionalidade de algumas dessas bibliotecas nativas para os aplicativos. Por exemplo, OpenGL ES pode ser acessado por meio do arcabouço Android Java OpenGL API, de modo a adicionar suporte ao desenho e manipulação de gráficos 2D e 3D no aplicativo.

% Todas as funcionalidades da plataforma Android estão disponíveis para os aplicativos por meio de APIs Java. Essas APIs compõem os elementos básicos para a construção de aplicativos Android. 

% Dentre eles, os mais relevantes para esta dissertação são:

% \begin{itemize}
% 	\item Um rico e extensível \textbf{Sistema de Visualização} para a contrução de interfaces com o usuário, também chamadas de arquivos de \textit{layout}, do aplicativo. Incluindo listas, grades ou tabelas, caixas de textos, botões, dentre outros.

% 	\item Um \textbf{Gerenciador de Recursos}, provendo acesso aos recursos ``não-java'' como textos, elementos gráficos, arquivos de \textit{layout}.

% 	\item Um \textbf{Gerenciador de Activity} que gerencia o ciclo de vida dos aplicativos e provê uma navegação comum.
% \end{itemize}

% O Android já vem com um conjunto de aplicativos básicos como por exemplo, para envio e recebimento de SMS, calendário, navegador, contatos e outros. Esses aplicativos não possuem diferencial com relação aos aplicativos de terceiros. Todo aplicativo tem acesso ao mesmo arcabouço de APIs do Android, seja ele aplicativo da plataforma ou de terceiro. Ou seja, um aplicativo de terceiro pode se tornar o aplicativo padrão para navegar na internet, receber e enviar SMS e assim por diante.

% Aplicativos da plataforma provém capacidades básicas que aplicativos de terceiros podem reutilizar. Por exemplo, se um aplicativo de terceiro quer possibilitar o envio de SMS, o mesmo pode reutilizar o aplicativo de SMS existente, em vez de implementar também essa funcionalidade.

\subsection{Fundamentos do Desenvolvimento Android}

Aplicativos Android são escritos na linguagem de programação Java. O \ac{SDK} Android compila o código, junto com qualquer arquivo de recurso ou dados, em um arquivo APK (\textit{Android Package}). Arquivos APKs, arquivo com extensão \texttt{.apk}, são usados por dispositivos para a instalação de aplicativos \cite{AndroidFundamentals}.

Os elementos base para a construção de aplicativos Android são os componentes. Cada componente é um diferente ponto de entrada por meio do qual o sistema aciona o aplicativo. Nem todos os componente são pontos de entrada para o usuário e alguns são dependentes entre si \cite{AndroidFundamentals}. Há quatro tipos diferentes de componentes Android, cada qual serve um propósito distinto e possui diferentes ciclos de vida, ou seja, como o componente é criado e destruído \cite{AndroidFundamentals}. São eles:

\begin{itemize}

	\item \textbf{Activities}

	Uma \textit{activity} representa uma tela com uma interface de usuário. Por exemplo, um aplicativo de email pode ter uma \textit{activity} para mostrar a lista de emails, outra para redigir um email, outra para ler emails e assim por diante. Embora \textit{activities} trabalhem juntas de modo a criar uma experiência de usuário (UX do inglês \textit{User Experience}) coesa no aplicativo de emails, cada uma é independente da outra. Desta forma, um aplicativo diferente poderia iniciar qualquer uma dessas \textit{activities} (se o aplicativo de emails permitir). Por exemplo, a \textit{activity} de redigir email no aplicativo de emails, poderia solicitar o aplicativo câmera, de modo a permitir o compartilhamento de alguma foto. Uma \textit{activity} é implementada como uma subclasse de \texttt{Activity} \cite{AndroidFundamentals}.  

	\item \textbf{Services}

	Um \textit{service} é um componente que é executado em plano de fundo para processar operações de longa duração ou processar operações remotas. Um \textit{service} não provê uma interface com o usuário. Por exemplo, um \textit{service} pode tocar uma música em plano de fundo enquanto o usuário está usando um aplicativo diferente, ou ele pode buscar dados em um servidor remoto através da internet sem bloquear as interações do usuário com a \textit{activity}. Um \textit{service} é implementado como uma subclasse de \texttt{Service} \cite{AndroidFundamentals}.

	\item \textbf{Content Providers}

	Um \textit{content provider} gerencia um conjunto compartilhado de dados do aplicativo. Estes dados podem estar armazenados em arquivos de sistema, banco de dados SQLite, servidor remoto ou qualquer outro local de armazenamento que o aplicativo possa acessar. Por meio de \textit{content providers}, outros aplicativos podem consultar ou modificar (se o \textit{content provider} permitir) os dados. Por exemplo, a plataforma Android disponibiliza um \textit{content provider} que gerencia as informações dos contatos dos usuários, possibilitando que qualquer aplicativo, com as devidas permissões, possa consultar, ler ou escrever informações sobre um contato. Um \textit{content provider} é implementado como uma subclasse de \texttt{ContentProvider} \cite{AndroidFundamentals}.

	\item \textbf{Broadcast Receivers}

	Um \textit{broadcast receiver} é um componente que responde a mensagens enviadas pelo sistema. Muitas destas mensagens são originadas da plataforma Android, por exemplo, o desligamento da tela, baixo nível de bateria e assim por diante. \textit{Broadcast receivers} não possuem interface de usuário. Para informar o usuário que algo ocorreu, \textit{broadcast receivers} podem criar notificações. Um \textit{broadcast receiver} é implementado como uma subclasse de \texttt{BroadcastReceiver} \cite{AndroidFundamentals}.

\end{itemize}

Para a plataforma iniciar quaisquer dos componentes mencionados, ela busca pela existência deles por meio da leitura do arquivo \texttt{AndroidManifest.xml} do aplicativo (arquivo de manifesto). O arquivo de manifesto é um arquivo XML, localizado na raiz do projeto, que contém informações sobre o aplicativo tais como: permissões de usuário, configurações de dependências do projeto, versão do Android, declarações dos componentes do aplicativo, dentre outras \cite{AndroidFundamentals}. Por exemplo, uma \textit{activity} pode ser declarada conforme o Código-fonte \ref{lst:AndroidManifest}. \\

% Os elementos usados no arquivo de manifesto são definidos pelo vocabulário XML do Android. Por exemplo, uma \textit{activity} pode ser declarada conforme o Código-Fonte \ref{lst:AndroidManifest}. \\

\begin{lstlisting}[
	language=XML, 
	caption={Arquivo \texttt{AndroidManifest.xml}}, 
	label={lst:AndroidManifest}
]
<?xml version="1.0" encoding="utf-8"?>
<manifest ... >
    <application android:icon="@drawable/app_icon.png" ... >
        <activity android:name="com.example.project.ExampleActivity"
                  android:label="@string/example_label" ... >
        </activity>
        ...
    </application>
</manifest>	
\end{lstlisting}

No elemento \texttt{<application>}, o atributo \texttt{android:icon} aponta para o ícone, que é um recurso do tipo imagem, que identifica o aplicativo. No elemento \texttt{<activity>}, o atributo \texttt{android:name} especifica o nome completamente qualificado da \textit{Activity}, e por fim, o atributo \texttt{android:label} especifica um texto para ser usado como título da \textit{Activity}.

% Para declarar cada um dos quatro tipos de componentes, deve-se usar os elementos a seguir:
% \begin{itemize}
% 	\item \texttt{<activity>} elemento para \textit{activities}.
% 	\item \texttt{<service>} elemento para \textit{services}.
% 	\item \texttt{<receiver>} elemento para \textit{broadcast receivers}.
% 	\item \texttt{<provider>} elemento para \textit{content providers}.
% \end{itemize}

\subsection{Recursos do Aplicativo}
\label{sec:AndroidResources}

Um aplicativo Android é composto por outros arquivos além de código Java, ele requer \textbf{recursos} como imagens, arquivos de áudio, animações, menus, estilos e qualquer recurso relativo a apresentação visual do aplicativo \cite{AndroidResourceType}. Recursos costumam ser arquivos XML que usam o vocabulário definido pelo Android \cite{AndroidFundamentals}.

Um dos aspectos mais importantes de prover recursos separados do código-fonte é a habilidade de prover recursos alternativos para diferentes configurações de dispositivos como por exemplo idioma ou tamanho de tela \cite{AndroidFundamentals}. Segundo levantamento, em 2015 foram encontrados mais de 24 mil dispositivos diferentes com Android \cite{AndroidFragmentation}.

Deve-se organizar os recursos dentro do diretório \texttt{res} do projeto, usando subdiretórios que agrupam os recursos por tipo e configuração. Para qualquer tipo de recurso, pode-se especificar uma opção padrão e outras alternativas \cite{AndroidFundamentals}. 

\begin{itemize}
	\item \textbf{Recursos padrões} são aqueles que devem ser usados independente de qualquer configuração ou quando não há um recurso alternativo que atenda a configuração atual. Por exemplo, arquivos de \textit{layout} padrão ficam em \texttt{res/layout}.

	\item \textbf{Recursos alternativos} são todos aqueles que foram desenhados para atender a uma configuração específica. Para especificar que um grupo de recursos é para ser usado em determinada configuração, basta adicionar um qualificador ao nome do diretório. Por exemplo, arquivos de \textit{layout} para quando o dispositivo está em posição de paisagem ficam em \texttt{res/layout-land}.
\end{itemize}

O Android irá aplicar automaticamente o recurso apropriado através da identificação da configuração corrente do dispositivo. Por exemplo, o recurso do tipo \textit{strings} pode conter textos usados nas interfaces do aplicativo. É possível traduzir estes textos em diferentes idiomas e salvá-los em arquivos separados. Desta forma, baseado no qualificador de idioma usado no nome do diretório deste tipo de recurso (por exemplo \texttt{res/values-fr} para o idioma francês) e a configuração de idioma do dispositivo, o Android aplica o conjunto de \textit{strings} mais apropriado.

% A seguir são listados os tipos de recursos que podem ser utilizados no Android \cite{AndroidResourceType}. Para cada tipo de recurso existe um conjunto de qualificadores que podem ser usados para prover recursos alternativos:

% \begin{itemize}
% 	\item \textbf{Recursos de animações} Definem animações pré-determinadas. Ficam nos diretórios \texttt{res/anim} ou \texttt{res/animator}.

% 	\item \textbf{Recursos de lista de cores de estado} Definem recursos de cores que alteram baseado no estado da \textit{View}. Ficam no diretório \texttt{res/color}.	

% 	\item \textbf{Recursos de desenhos} Definem recursos gráficos como \textit{bitmap} ou XML. Ficam no diretório \texttt{res/drawable}.

% 	\item \textbf{Recursos de \textit{layouts}} Definem a parte visual da interface com o usuário. Ficam no diretório \texttt{res/layout}.

% 	\item \textbf{Recursos de menus} Definem os conteúdos dos menus da aplicação. Ficam no diretório \texttt{res/menu}.

% 	\item \textbf{Recursos de textos} Definem textos, conjunto de textos e plurais. Ficam no diretório \texttt{res/values}.

% 	\item \textbf{Recursos de estilos} Definem os estilos e e formatos para os elementos da interface com usuário. Ficam no diretório \texttt{res/values}.

% 	\item \textbf{Outros recursos} Ainda existem outros recursos como inteiros, \textit{booleanos}, dimensões, dentre outros. Ficam no diretório \texttt{res/values}.
% \end{itemize}


\subsection{Interfaces de Usuários}

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.7\textwidth]{ui-overview.png}
	\caption{Árvore hierárquica de \texttt{View}s e \texttt{ViewGroup}s do Android \cite{AndroidUIOverview}.}
	\label{fig:UIOverview}
\end{figure}

Arquivos de \textit{layout} são recursos localizados no subdiretório \texttt{res/layout} que possuem a extensão \texttt{.xml} \cite{AndroidResourceType}. Todos os elementos de UI (Interface de Usuário, do inglês UI, \textit{User Interface}) de um aplicativo Android são construídos usando objetos do tipo \texttt{View} e \texttt{ViewGroup} como mostrado na Figura \ref{fig:UIOverview} \cite{AndroidUIOverview}. 

Uma \texttt{View} é um objeto que desenha algo na tela do qual o usuário pode interagir como caixas de texto e botões. Um \texttt{ViewGroup} é um contêiner invisível que organiza \texttt{View}s filhas. O encadeamento desses objetos formam uma árvore hierárquica que pode ser tão simples ou complexa quanto se precisar \cite{AndroidResourceType}.

É possível criar um \textit{layout} programaticamente instanciando \texttt{View}s e \texttt{ViewGroup}s no código e construir a árvore hierárquica manualmente, no entanto, a forma mais indicada é  por meio de um XML de \textit{layout} \cite{AndroidUIOverview}. 

O vocabulário XML para declarar elementos de UI segue ou é muito próxima a estrutura de nome de classes e métodos, onde os nomes dos elementos correspondem aos nomes das classes e os atributos correspondem aos nomes dos métodos, como por exemplo, o elemento \texttt{<EditText>} tem o atributo \texttt{text} que corresponde ao método \texttt{EditText.setText()} \cite{AndroidUIOverview}. Um layout vertical simples com uma caixa de texto e um botão se parece com o Código-fonte \ref{lst:LayoutSample}. \\

\begin{lstlisting}[
	language=XML, 
	caption={Arquivo exemplo de layout.}, 
	label={lst:LayoutSample}
]
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout ...
              android:layout_width="fill_parent"
              android:layout_height="fill_parent"
              android:orientation="vertical">

    <TextView android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="I am a TextView" />

    <Button   android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="I am a Button" />

</LinearLayout>
\end{lstlisting}

% Quando um recurso de layout é carregado pelo aplicativo, o Android inicializa um objeto para cada elemento do layout, desta forma é possível recuperá-lo programaticamente para definir comportamentos, modificar o layout ou mesmo recuperar o estado. 

% O Android provê uma série de elementos de UI comuns pré-prontos como: caixa de texto, botão, lista suspensa, dentre muitos outros. Desta forma, o desenvolvedor não precisa implementar do zero estes elementos básicos através de \texttt{View}s e \texttt{ViewGroup}s para escrever uma interface de usuário.

% Cada subclasse de \texttt{ViewGroup} provê uma forma única de exibir o conteúdo dentro dele. Por exemplo, o \texttt{LinearLayout} organiza seu conteúdo de forma linear horizontalmente, um ao lado do outro, ou verticalmente, um abaixo do outro. O \texttt{RelativeLayout} permite especificar a posição de uma \texttt{View} relativa ao posicionamento de alguma outra \cite{AndroidLayouts}.

Quando o conteúdo é dinâmico ou não pré-determinado, como por exemplo uma lista de dados, pode-se usar um elemento que estende de \texttt{AdapterView} para popular o layout em tempo de execução. Subclasses de \texttt{AdapterView} usam uma implementação de \texttt{Adapter} para carregar dados em seu \textit{layout}. \texttt{Adapter}s agem como um intermediador entre o conteúdo a ser exibido e o \textit{layout}, ele recupera o conteúdo e converte cada item, de uma lista por exemplo, dentro de uma ou mais \texttt{View}s.

Os elementos comumente usados para situações de conteúdo dinâmico ou não pré-determinado são: \texttt{ListView} e \texttt{GridView}. Para fazer o carregamento dos dados o Android provê alguns \texttt{Adapter}s como por exemplo o \texttt{ArrayAdapter} que a partir de um \texttt{array} de dados popula os dados na \texttt{ListView} ou \texttt{GridView}.

Para responder a ações do usuário, cada \texttt{View} possui um conjunto de interfaces que podem responder a eventos, essas interfaces são chamadas de \textit{event listeners}. Por exemplo, quando um botão é clicado, o evento \texttt{onClick} da interface \texttt{OnClickListener} é disparado. Ao associar a interface implementada ao botão, é possível implementar a resposta desejada para essa ação do usuário \cite{AndroidUIEvents}.

\subsection{Camada de Apresentação Android}
\label{ch:PresentationLayer}

Um assunto essencial para o entendimento deste trabalho é explanar o que queremos dizer com ``Camada de Apresentação Android''. Nesta seção abordamos justamente este assunto com o objetivo de explanar como chegamos na definição aqui usada.

Em nossas pesquisas bibliográficas não foi encontrada uma definição formal sobre camada de apresentação Android. Encontramos porém, pontos na documentação oficial do Android \cite{AndroidDeveloperSite2016} que afirmam que determinado elemento de alguma forma é parte desta camada. Por exemplo o trecho sobre \textit{Activities} diz que ``representa uma tela com interface do usuário''. O trecho sobre recursos do aplicativo afirma que ``um aplicativo Android é composto por outros arquivos além de código Java, ele requer recursos como imagens, arquivos de áudio e qualquer recurso relativo a apresentação visual do aplicativo'' \cite{AndroidFundamentals}. Encontramos também postagens em sites técnicos sobre Android que de alguma forma indicam que determinado elemento compõe a camada de apresentação Android, por exemplo Preussler relaciona \textit{adapters} como parte da camada de apresentação \cite{AdaptersPreussler2016}. Desta forma viu-se necessário definir quais são os elementos, para efeitos desta dissertação, que compõem a camada de apresentação em aplicativos Android. 

Os primórdios de GUI (\textit{Graphical User Interfaces} ou Interfaces de Usuário Gráficas) foram em 1973 com o projeto Alto, desenvolvido pelos pesquisadores da Xerox Palo Alto Research Center (PARC), seguido do projeto Lisa da Apple em 1979. Estes dois projetos serviram de base e inspiração para o Machintosh, lançado pela Apple em 1985. As primeiras definições sobre GUI que surgiram nessa época abordavam sobre componentes de uso comum como ícones, janelas, barras de rolagem, menus suspensos, botões, caixas de entrada de texto; gerenciadores de janelas; arquivos de áudio, internacionalização e eventos. Antes deste período existiam apenas interfaces de linha de comando \cite{GUIRaymond2004, UITecMundo2016}.

Outra fonte define camada de apresentação como ``informações gráficas, textuais e auditivas apresentadas ao utilizador, e as sequências de controle (como comandos de teclado, \textit{mouse} ou toque) para interagir com o programa'' \cite{UIWikipedia2016}. 

Unindo as definições supracitadas, definimos que todos os elementos do Android que são apresentados ou interagem com o usuário de alguma forma auditiva, visual ou por comando de voz ou toque são elementos da \textbf{Camada de Apresentação}, são eles:

\begin{itemize}
	\item \textbf{Activities e Fragments} Representam uma tela ou um fragmento de tela. A exemplo temos classes Java que herdam de \texttt{Activity}, \texttt{Fragment} ou classes similares.

	\item \textbf{Listeners} Meio pelo qual os comandos do usuário são capturados pelo aplicativo. A exemplo temos classes Java que implementam interfaces como \texttt{View.OnClickListener}.

	\item \textbf{Recursos do Aplicativo} Arquivos que apresentam textos, imagens, áudios, menus, interfaces gráficas (\textit{layout}), dentre outros. Estão incluídos neste item todos os arquivos dentro do diretório \texttt{res} ainda que em seu formato Java. A exemplo podemos citar classes que herdam da classe \texttt{View} ou \texttt{ViewGroup}.

	\item \textbf{Adapters} Meio pelo qual são carregados conteúdos dinâmicos ou não pré-determinados na tela. A exemplo podemos citar classes que herdam da classe \texttt{BaseAdapter}.

\end{itemize}

