% -*- root: dissertacao.tex -*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setlength{\parindent}{20pt}
\setlength{\textheight}{22cm}
\setlength{\parskip}{0.2cm}
\linespread{1.2} % Para aumentar o espaçamento entre as linhas
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Identificar o contexto e a motivação para o trabalho, especificar o problema, discutir trabalhos relacionados (principalmente as suas limitações), definir as contribuições, enfatizar os resultados principais e a organização do texto.

\chapter{Trabalhos Relacionados}
\label{cap:related}

Agrupamos os trabalhos relacionados em 3 seções: a Seção 3.1 trata de estudos recentes realizados sobre Android, a Seção 3.2 trata de estudos que analisam cheiros de código específicos à alguma tecnologia ou plataforma e a Seção 3.3, estudos sobre cheiros de código específicos à plataforma Android.

\section{Pesquisas Focadas na Plataforma Android}

Diversas pesquisas têm sido realizadas em torno da plataforma Android. É possível encontrar artigos sobre temas variados, como por exemplo segurança \cite{Y, X, D, E, F, G, H}, análise estática de código \cite{A, B, C, X, Z} e autenticação de usuário \cite{P,Q,R,S}. Neste seção passamos por alguns desses e outros de modo a apresentar uma visão geral das pesquisas realizadas sobre Android. 

% usabilidade

Adrienne et al. \cite{AdriennePermission} realizou um estudo de usabilidade com usuários Android para entender a efetividade do sistema de permissões de usuários. Quando um usuário instala uma aplicação tem a oportunidade de rever as permissões solicitadas pelo aplicativo. O estudo concluiu que 17\% dos usuários prestam atenção as permissões apresentadas durante a instalação. O estudo conclui com recomendações para melhorar o entendimento e atenção dos usuários com relação as permissões solicitadas. 
% ----------------------------------------------------------------- 

% Segurança & Análise Estática
O sistema operacional Android além de possuir uma API aberta, tem um rico sistema de mensagens entre aplicações. Isso reduz o trabalho de desenvolvimento, facilitando a reutilização de componentes \cite{Y}. Entretanto o Android confere uma responsabilidade significativa aos desenvolvedores de aplicativos com relação ao risco de problemas de segurança como afirma Kavitha K et al. \cite{X}. 

Infelizmente a comunicação entre aplicações pode ser detectada, capturada ou até mesmo substituída, comprometendo a privacidade e segurança do usuário como a Erika Chin et al. \cite{Y} afirma. 

Alguns autores tem explorando os riscos de problemas de segurança envolvendo Android \cite{Y, X, D, E, F, G, H}. No artigo Analyzing Inter-Application Communication in Android os autores examinam iterações entre aplicações Android e identificam os riscos de segurança nos componentes. Enquanto no artigo Exploring the Malicious Android Applications and Reducing Risk using Static Analysis os autores investigam os problemas de segurança envolvendo o controle de permissão. 

Uma das contribuições do trabalho de Erika Chin et al. \cite{Y} é uma ferramenta para detecção de vulnerabilidades na comunicação entre aplicações chamada ComDroid. A ferramenta ComDroid baseia-se no DEX do aplicativo. Isto permite que terceiros ou revisores poderem utilizar a ferramenta para avaliar aplicativos mesmo quando não tem disponível o código fonte. O funcionamento da ferramenta ComDroid é baseado na análise estática da saída do Dedexer \cite{P}. A análise estática tem sido comumente utilizada para a detecção de bugs \cite{A, B, C}. 

Kavitha K \cite{X} também utiliza análise estatística em conjunto com análise dinâmica em um sistema de detecção de malware com base no controle de permissão do Android e os passos necessários para mitigar o acesso a permissões indesejadas. 

No artigo Automated Static Code Analysis for Classifying Android Applications Using Machine Learning \cite{Z} os autores utilizam análise estática para  classificar aplicações Android  em dois tipos: ferramentas e jogos. Do mesmo modo que o trabalho de Erika Chin et al. \cite{Y} os autores Asaf Shabtai et al. \cite{Z} também se baseiam no DEX, entretanto, mesmo utilizando aprendizado de máquina em conjunto com análise estática alguns aplicativos não conseguiram ser classificados corretamente.

Thomas Bläsing et al \cite{K} no artigo An Android Application Sandbox System for Suspicious Software Detection propoem um sandbox para análises de aplicações Android denominado AASandbox. O AASandbox pode ser implantado na nuvem e é capaz de executar análises estáticas e dinâmicas em programas Android com objetivo de detectar automaticamente aplicativos suspeitos. A análise estática do software tem foco em padrões maliciosos utilizando serviços na nuvem utilizando um emulador Android em ambiente isolado, fornecendo uma detecção rápida e distribuída de software suspeito. Além disso, o AASandbox pode ser utilizado para melhorar a eficiência dos antivírus disponíveis para o sistema operacional Android.


% Teste de Aplicativos Android
Os usuários confiam cada vez mais em aplicações móveis para necessidades computacionais. Android é uma plataforma móvel muito popular, desta maneira a confiabilidade de aplicativos Android está se tornando cada vez mais importante \cite{J, L}. De acordo com Wasserman \cite{N}, o desafio de engenharia de software com desenvolvimento de aplicações móveis é o de encontrar soluções eficazes para alcançar qualidades e definir técnicas e ferramentas adequadas para suportar seus testes. Testar aplicativos do Android é uma atividade desafiadora, com vários problemas abertos, problemas específicos e perguntas em aberto principalmente em relação a GUI \cite{J, L, M}.


No artigo Automating GUI Testing for Android Applications os autores apresentam uma abordagem para automatizar o processo de teste para aplicativos Android com foco em bugs de interface, como erros de ACTIVITY e EVENT. Primeiramente os autores realizam um estudo de bugs para entender a natureza e a frequência de bugs que afetam aplicativos Android. Em seguida Cuixiong Hu et al \cite{J} apresentam técnicas de detecção de erros GUI utilizando geração automática de casos de teste, utilizando eventos aleatórios da aplicação e instrumentação da máquina virtual, produzindo arquivos de log que serão utilizados na análise pós-execução. As técnicas apresentadas mostraram-se eficazes para erros de ACTIVITY, EVENT e TYPE ERRORS.


Atif M. Memon no artigo Using GUI Ripping for Automated Testing of Android Applications \cite{M}  apresenta o AndroidRipper uma técnica automatizada que testa aplicativos Android através da GUI. AndroidRipper é baseado em um explorador automático da GUI do aplicativo com o objetivo de exercitar o aplicativo de forma estruturada. Uma das contribuições do artigo \cite{M} é a disponibilização do aplicativo  AndroidRipper com código aberto. Os resultados apresentados demonstra a capacidade de detectar falhas graves, previamente desconhecidas no código, e que a exploração estruturada supera a abordagem aleatória.

% -----------------

Dispositivos móveis tornaram-se uma parte importante na vida das pessoas \cite{P, S}. A identificação de dispositivos é de grande importância para a autenticação segura de usuários em redes móveis e tem atraído a atenção de muitos pesquisadores \cite{P, S, T}. 

Yildirim et a. \cite{S} propõe o uso do leitor biométrico somado a identidade de equipamento móvel internacional (IMEI) para a geração de uma senha única e expirável para a autenticação em sistemas web. Alguns fabricantes de dispositivos móveis permitem que os desenvolvedores usem os recursos de segurança do dispositivo em seus aplicativos por meio do kit de desenvolvimento do dispositivo (SDK) do dispositivo.

Wu et al. \cite{P} propõe que os dados obtidos a partir de um smartphone podem ser usados para identificar o usuário do smartphone, sem a necessidade de alguma ação pelo usuário. O autor afirma que Métodos tradicionais utilizam identificadores explícitos como o IMEI, a identidade de assinante móvel internacional (IMSI) ou o Android ID. No entanto, alguns identificadores explícitos não são confiáveis e podem ser facilmente adulterados ou forjados, além de que, para obtê-los, é necessário solicitar permissão do usuário o que pode causar em abuso de permissões sensíveis e vazamento da privacidade \cite{Q, R}.

Para resolver esses problemas, Wu et al. \cite{P} propõe três algoritmos de identificação de dispositivos baseado em identificadores implícitos que podem ser obtidos sem solicitar qualquer permissão \cite{P}. Os identificadores implícitos são compostos por dados obtidos (i) da camada física (hardware) como espaço em disco, (ii) da camada de aplicação (sistema operacional) como versão do Android e (iii)  da camada do usuário (configurações) como time-zone. 


% ----------------------------------------------------------------- 



\section{Cheiros de Código Específicos de Tecnologia ou Plataforma}

Diversos pesquisadores propuseram cheiros de código e práticas recomendadas para tecnologias ou plataformas específicas, como frameworks Java \cite{AA, FinavaroAniche2016}, linguagem web como Cascading Style Sheets (CSS) \cite{CSSCodeSmell} e Javascript \cite{BB} e outros.

Chen et al. \cite{AA} afirma que frameworks Object-Relational Mapping (ORM) são amplamente utilizado na indústria. No entanto, os desenvolvedores geralmente escrevem código ORM sem considerar o impacto desse código no desempenho de banco de dados, levando a causar transações com "timeout" ou travamentos em sistemas em larga escala. Chen et al. \cite{AA} soluciona este problema com implementação de um framework automatizado e sistemático para detectar e priorizar anti-patterns de desempenho para aplicações desenvolvidas usando ORM. Estudos de caso mostraram que o framework pode detectar centenas ou milhares de instâncias de anti-patterns de desempenho ao mesmo tempo que prioriza efetivamente a correção dessas instâncias \cite{AA}. Foi descoberto que a correção dessas instâncias de anti-patterns de desempenho pode melhorar o tempo de resposta dos sistemas em até 98\% (e, em média, 35\%). Além do framework que é extensível podendo agregar outros anti-patterns, Chen et al. \cite{AA} contribui com o mapeamento de 2 anti-patterns específicos a frameworks ORM.

Aniche et al. \cite{FinavaroAniche2016} também investigou cheiros de código relacionado a um framework. Segundo o autor, para escrever código fácil de ser mantido e evoluído, e detectar pedaços de código problemáticos, desenvolvedores fazem uso de métricas de código e estratégias de detecção de maus cheiros de código. No entanto, métricas de código e estratégias de detecção de maus cheiros de código não levam em conta a arquitetura do software em análise o que significa que todas classes são avaliadas como se umas fossem iguais às outras. Aniche et al. \cite{FinavaroAniche2016} afirma que cada papel arquitetural possui resposabilidades diferentes o que resulta em distribuições diferentes de valores de métrica de código. Mostra ainda que classes que cumprem um papel arquitetural específico, como por exemplo \textsc{Controllers}, também contêm maus cheiros de código específicos. Uma das contribuições de Aniche et al. é um catálogo com 6 cheiros de códigos específicos ao framework Spring MVC mapeados e validados.

CSS é amplamente utilizado nas aplicações web de hoje para separar a semântica de apresentação do conteúdo HTML \cite{CSSCodeSmell}. De acordo como Gharachorlu \cite{CSSCodeSmell} apesar da simplicidade de síntaxe do CSS, as características específicas da linguagem tornam a criação e manutenção de CSS uma tarefa desafiadora. Foi realizando um estudo empírico de larga escala em 500 sites, 5060 arquivos no total, que consistem de mais de 10 milhões de linhas de código CSS. Segundo o autor, os resultados indicaram que o CSS de hoje sofre significativamente de padrões inadequados e está longe de ser um código bem escrito. Porfim Gharachorlu \cite{CSSCodeSmell} propõe o primeiro modelo de qualidade de código CSS derivado de uma grande amostra de aprendizagem de modo a ajudar desenvolvedores a obter uma estimativa do número total de cheiros de código em seu código CSS. Sua principal contrinbuição foi oito novos cheiros de código CSS detectados com o uso da ferramenta CSSNose, também implementada e disponibilizada pelo autor.

Javascript é uma flexível linguagem de script para o desenvolvimento de aplicações Web 2.0 \cite{BB}. Fard e Ali \cite{BB} afirmam que devido à essa flexibilidade, o JavaScript é uma linguagem particularmente desafiadora para escrevere manter código. Os desafios são múltiplos: Primeiro, é uma linguagem interpretada, o que significa que normalmente não há compilador no ciclo de desenvolvimento que ajudaria os desenvolvedores a detectar código incorreto ou não otimizado. Segundo, tem uma natureza dinâmica, fracamente tipificada, assíncrona. Terceiro, ele suporta recursos intrincados, como prototypes \cite{CC}, funções de primeira classe e "closures" \cite{DD}. E finalmente, ele interage com o DOM através de um mecanismo complexo baseado em eventos \cite{EE}. Os autores propõem um conjunto de 13 cheiros de código JavaScript, sendo 7 cheiros de códigos bem conhecidos adaptados para o JavaScript e 6 tipos específicos de códigos de JavaScript devidos do trabalho. Também é apresentada uma técnica automatizada, chamada JSNOSE, para detectar esses cheiros de código.

Abílio et al \cite{FF} descreve no artigo um estudo exploratório sobre maus cheiros de código em um ambiente que não utiliza engenharia de software convencional. A abordagem das Linhas de Produtos de Software (Software Product Lines, SPL) centra-se no uso de técnicas de engenharia que permitem criar um grupo de sistemas de software similares a partir de um conjunto de especificações de software comuns a todos esses sistemas. Diferenciando  da engenharia de software convencional principalmente pela presença de variação em alguns ou até todos os requisitos de software \cite{GG, II, HH}. Programação Orientada a Recursos (do inglês \textit{Feature-Oriented Programming}, FOP) é um paradigma para a modularização de software em que as características são as principais abstrações \cite{JJ}. Os recursos podem ser realizados em artefatos separados usando abordagens de composição com FOP e Programação Orientada a Aspecto (do inglês, \textit{Aspect-Oriented Programming}, AOP) \cite{LL}.

No entanto, a Programação Orientada a Recursos é uma técnica específica para lidar com a modularização de recursos no SPL \cite{FF}. Uma das linguagens FOP mais populares é a AHEAD e ainda faltam estudos sistemáticos sobre a categorização e detecção de cheiros de código em SPL baseado em AHEAD \cite{FF}. Para preencher essa lacuna, Abíio et al. \cite{FF} estende as definições de três maus cheiros de código tradicionais, \textit{God Method}, \textit{God Class}, e \textit{Shotgun Surgery}, para levar em conta as abstrações de FOP. Propondo novas métricas FOP para quantificar características específicas de abordagens com o AHEAD e definindo estratégias para identificar os maus cheiros de código investigados.


\section{Cheiros de Código na Plataforma Android}

Verloop \cite{MobileSmells:13} e Minelli e Lanza \cite{Mantyla2013} focam em estudar código-fonte de aplicativos para entender se e como eles diferem dos sistemas de software tradicionais e quais são as possíveis implicações para a manutenção de aplicativos. Os autores concluem que aplicações móveis são substancialmente diferentes das aplicações de software tradicionais, por exemplo, a falta de uma fonte de alimentação permanente, vida útil curta, times de desenvolvimento com poucos desenvolvedores, projetos menores, poder de processamento limitado, muitas dependências externas. E que devido a essas diferenças, pesquisas feita em aplicações de software tradicionais podem não se aplicar a aplicações móveis.


Minelli e Lanza \cite{Mantyla2013} realiza sua análise com uma ferramenta desenvolvida por ele chamada Samoa. Samoa é descrita como uma plataforma de análise de software baseada na web para analisar aplicações móveis de uma perspectiva estrutural e histórica. Ele mostra uma série de métricas de software para as aplicações que analisa e apresenta as métricas usando diferentes tipos de gráficos. As métricas utilizadas incluem o número de pacotes, o número de classes, o número de métodos, o número de chamadas internas, o número de chamadas externas, o número de elementos principais, dentre outras. Minelli e Lanza \cite{Mantyla2013} acreditam que no futuro, aplicações móveis poderão enfrentar os mesmos problemas que aplicações tradicionais.


Outro ponto importante da tese de Verloop \cite{MobileSmells:13} consistia em encontrar cheiros de código em projetos Android para determinar se os cheiros de código ocorrem com mais freqüência no código relacionado ao Android. Para isso, foram usadas ferramentas de detecção automática de cheiros de código. Das 8 ferramentas mencionadas, apenas uma foi desenvolvida especificamente para Android e suportava a linguagem XML (Lint). Vale considerar que, um projeto de aplicativo Android é composto por muitos arquivos XML \cite{AndroidResourcesOverview}. Desta análise Verloop \cite{MobileSmells:13} derivou 4 métricas (CoreCS, CoreNLOC, NonCoreCS e NonCoreNLOC, onde NLOC significa número de linhas de código, do inglês, Number Lines of Code) que foram usadas para calcular o número de cheiros de código. Na Figura \ref{fig:VerloopSmells} é apresentada uma tabela com o resultado.


\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.5\textwidth]{verloop-smells.png}
	\caption{Número de cheiros de código encontrados por 1000 LOC agrupador por cheiro de código .}
	\label{fig:VerloopSmells}
\end{figure}


Verloop \cite{MobileSmells:13} mostra que o cheiro de código \textit{Long Method} é quase duas vezes mais provável de ocorrer nas classes núcleo, classes que herdam da estrutura do Android. Também mostra que o cheiro de código \textit{Large Class} é quase tão provável de ocorrer em classes núcleo como em classes não-núcleo. Uma possível razão para isso pode ser que o número de classes de \textsc{Activities} em comparação com o número total de classes é pequeno. O cheiro de código de  \textit{Long Parameter List} é quase inexistente em classes de núcleo. O cheiro de código \textit{Feature Envy}, tal como o cheiro \textit{Large Class}, é quase tão provável de ocorrer nas classes núcleo como nas classes não-núcleo. O cheiro de código \textit{Type Checking} foi encontrado menos de uma vez a cada 1000 LOC, mas foi encontrado duas vezes mais freqüentemente nas classes principais. Por último, o cheiro de código \textit{Dead Code} é mais provável de ser encontrado em classes não-núcleo. O autor ainda contribui com cincopossíveis refatorações e três delas foram implementadas em um plugin do Eclipse.


Verloop \cite{MobileSmells:13} diz que apesar do crescimento e mudanças do mercado móvel não há muita pesquisa a ser encontrada nesta nova área de desenvolvimento de software. Esses novos desafios enfrentados por desenvolvedores móveis e a quantidade limitada de pesquisa sobre o assunto têm tornado cheiros de código para aumentar a manutenibilidade dessas aplicações em um tópico interessante afirma Verloop \cite{MobileSmells:13}.

Linares-Vásquez et al. \cite{DomainMatters} usou a ferramenta DECOR para realizar a detecção de 18 diferentes \textit{anti-patterns} orientado a objetos em aplicativos móveis desenvolvidos com Java Mobile Edition (J2ME). Este estudo em larga escala mostra que a presença de antipatterns afeta negativamente as métricas de qualidade do software, em particular as métricas relacionadas à falha.

Gottschalk e Jelschen \cite{EnergyAndroidSmells} explicam como tentam melhorar o uso de energia de aplicações móveis, procurando por desperdícios de energia, padrões esses que eles denominam de cheiro de código sobre energia (textit{quality code smell}). Os autores produzem um catálogo com um total de 6 cheiros de códigos de energia e salientam que os mesmos são \textit{cross-platform}, ou seja, independente de plataforma móvel. Entretanto, um código Android é dado no exemplo. Cada cheiro de código de energia catalogado tem uma descrição, instruções de como detectar e reestruturar. Reimann et al. \cite{ReimannBrylski2013} também trata sobre cheiros de qualidade e relacionados 20 que impactam no consumo inteligente de recursos de hardware do dispositivo como eficiência no uso de energia, processamento e memória.

Reimann et al. \cite{ReimannBrylski2013} correlaciona os conceitos de mau cheiro, qualidade e refatoração a fim de introduzir o termo cheiro de qualidade (do inglês \textit{quality smell}). Um cheiro de qualidade é uma estrutura que influencia negativamente requisitos de qualidade específicos, que podem ser resolvidos por refatorações \cite{Reimann:2013}.

Os autores compilaram um catálogo de 30 cheiros de qualidade para Android. O formato dos cheiros de qualidade incluem: nome, contexto, requisitos de qualidades afetados e descrição, este formato foi baseado nos catálogos de Brown et al. \cite{WilleyAntiPatterns} e Fowler \cite{RefactoringFowler1999}. Todo o catálogo pode ser encontrado em \texttt{http://www.modelrefactoring.org/smell\_catalog} e os mesmos também foram implamentados no framework Refactory \cite{Reimann:2013}.

O requisitos de qualidade tratados por Reimann et al. \cite{ReimannBrylski2013} são: centrados no usuário (estabilidade, tempo de início, conformidade com usuários, experiência do usuário e acessibilidade), consumo inteligente de recursos de hardware do dispositivo (eficiência no uso de energia, processamento e memória) e segurança. 

Os autores ainda citam que o problema no desenvolvimento móvel é que os desenvolvedores estão cientes de cheiros de qualidade apenas indiretamente porque suas definições são informais (melhores práticas, problemas de rastreamento de bugs, discussões de fóruns etc.) e os recursos onde encontrá-los são distribuídos pela web e que é difícil coletar e analisar todas essas fontes sob um ponto de vista comum e fornecer suporte de ferramentas para desenvolvedores. 

Esta dissertação pretende pela primeira vez catalogar cheiros de código especificamente relacionados a camada de apresentação de aplicativos Android. Pretende-se reaproveitar diversos dos métodos utilizados para a detecção e documentação de cheiros de código dos diversos trabalhos acima citados. \\