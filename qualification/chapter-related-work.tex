% -*- root: dissertacao.tex -*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setlength{\parindent}{20pt}
\setlength{\textheight}{22cm}
\setlength{\parskip}{0.2cm}
\linespread{1.2} % Para aumentar o espaçamento entre as linhas
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Identificar o contexto e a motivação para o trabalho, especificar o problema, discutir trabalhos relacionados (principalmente as suas limitações), definir as contribuições, enfatizar os resultados principais e a organização do texto.

\chapter{Trabalhos Relacionados}
\label{cap:related}

Agrupamos os trabalhos relacionados em 3 áreas: (i) estudos recentes realizados sobre Android, (ii) estudos que analisam cheiros de código específicos à alguma tecnologia, plataforma ou framework e (iii) estudos sobre cheiros de código específicos a plataforma Android.

\section{Pesquisas Focadas na Plataforma Android}

Diversas pesquisas têm sido realizadas em torno da plataforma Android. É possível encontrar artigos sobre temas variados, como por exemplo segurança \cite{Y, X, D, E, F, G, H}, análise estática de código \cite{A, B, C, X, Z} e autenticação de usuário \cite{P,Q,R,S}. Neste seção passamos por alguns desses e outros de modo a apresentar uma visão geral das pesquisas realizadas sobre Android. 

% usabilidade

Adrienne et al. \cite{AdriennePermission} realizou um estudo de usabilidade com usuários Android para entender a efetividade do sistema de permissões de usuários. Quando um usuário instala uma aplicação tem a oportunidade de rever as permissões solicitadas pelo aplicativo. O estudo concluiu que 17\% dos usuários prestam atenção as permissões apresentadas durante a instalação. O estudo conclui com recomendações para melhorar o entendimento e atenção dos usuários com relação as permissões solicitadas. 
% ----------------------------------------------------------------- 

% Segurança & Análise Estática
O sistema operacional Android além de possuir uma API aberta, tem um rico sistema de mensagens entre aplicações. Isso reduz o trabalho de desenvolvimento, facilitando a reutilização de componentes \cite{Y}. Entretanto o Android confere uma responsabilidade significativa aos desenvolvedores de aplicativos com relação ao risco de problemas de segurança como afirma Kavitha K et al. \cite{X}. 

Infelizmente a comunicação entre aplicações pode ser detectada, capturada ou até mesmo substituída, comprometendo a privacidade e segurança do usuário como a Erika Chin et al. \cite{Y} afirma. 

Alguns autores tem explorando os riscos de problemas de segurança envolvendo Android \cite{Y, X, D, E, F, G, H}. No artigo Analyzing Inter-Application Communication in Android os autores examinam iterações entre aplicações Android e identificam os riscos de segurança nos componentes. Enquanto no artigo Exploring the Malicious Android Applications and Reducing Risk using Static Analysis os autores investigam os problemas de segurança envolvendo o controle de permissão. 

Uma das contribuições do trabalho de Erika Chin et al. \cite{Y} é uma ferramenta para detecção de vulnerabilidades na comunicação entre aplicações chamada ComDroid. A ferramenta ComDroid baseia-se no DEX do aplicativo. Isto permite que terceiros ou revisores poderem utilizar a ferramenta para avaliar aplicativos mesmo quando não tem disponível o código fonte. O funcionamento da ferramenta ComDroid é baseado na análise estática da saída do Dedexer \cite{P}. A análise estática tem sido comumente utilizada para a detecção de bugs \cite{A, B, C}. 

Kavitha K \cite{X} também utiliza análise estatística em conjunto com análise dinâmica em um sistema de detecção de malware com base no controle de permissão do Android e os passos necessários para mitigar o acesso a permissões indesejadas. 

No artigo Automated Static Code Analysis for Classifying Android Applications Using Machine Learning \cite{Z} os autores utilizam análise estática para  classificar aplicações Android  em dois tipos: ferramentas e jogos. Do mesmo modo que o trabalho de Erika Chin et al. \cite{Y} os autores Asaf Shabtai et al. \cite{Z} também se baseiam no DEX, entretanto, mesmo utilizando aprendizado de máquina em conjunto com análise estática alguns aplicativos não conseguiram ser classificados corretamente.

Thomas Bläsing et al \cite{K} no artigo An Android Application Sandbox System for Suspicious Software Detection propoem um sandbox para análises de aplicações Android denominado AASandbox. O AASandbox pode ser implantado na nuvem e é capaz de executar análises estáticas e dinâmicas em programas Android com objetivo de detectar automaticamente aplicativos suspeitos. A análise estática do software tem foco em padrões maliciosos utilizando serviços na nuvem utilizando um emulador Android em ambiente isolado, fornecendo uma detecção rápida e distribuída de software suspeito. Além disso, o AASandbox pode ser utilizado para melhorar a eficiência dos antivírus disponíveis para o sistema operacional Android.


% Teste de Aplicativos Android


Os usuários confiam cada vez mais em aplicações móveis para necessidades computacionais. Android é uma plataforma móvel muito popular, desta maneira a confiabilidade de aplicativos Android está se tornando cada vez mais importante \cite{J, L}. De acordo com Wasserman \cite{N}, o desafio de engenharia de software com desenvolvimento de aplicações móveis é o de encontrar soluções eficazes para alcançar qualidades e definir técnicas e ferramentas adequadas para suportar seus testes. Testar aplicativos do Android é uma atividade desafiadora, com vários problemas abertos, problemas específicos e perguntas em aberto principalmente em relação a GUI \cite{J, L, M}.


No artigo Automating GUI Testing for Android Applications os autores apresentam uma abordagem para automatizar o processo de teste para aplicativos Android com foco em bugs de interface, como erros de ACTIVITY e EVENT. Primeiramente os autores realizam um estudo de bugs para entender a natureza e a frequência de bugs que afetam aplicativos Android. Em seguida Cuixiong Hu et al \cite{J} apresentam técnicas de detecção de erros GUI utilizando geração automática de casos de teste, utilizando eventos aleatórios da aplicação e instrumentação da máquina virtual, produzindo arquivos de log que serão utilizados na análise pós-execução. As técnicas apresentadas mostraram-se eficazes para erros de ACTIVITY, EVENT e TYPE ERRORS.


Atif M. Memon no artigo Using GUI Ripping for Automated Testing of Android Applications \cite{M}  apresenta o AndroidRipper uma técnica automatizada que testa aplicativos Android através da GUI. AndroidRipper é baseado em um explorador automático da GUI do aplicativo com o objetivo de exercitar o aplicativo de forma estruturada. Uma das contribuições do artigo \cite{M} é a disponibilização do aplicativo  AndroidRipper com código aberto. Os resultados apresentados demonstra a capacidade de detectar falhas graves, previamente desconhecidas no código, e que a exploração estruturada supera a abordagem aleatória.

% -----------------

Dispositivos móveis tornaram-se uma parte importante na vida das pessoas \cite{P, S}. A identificação de dispositivos é de grande importância para a autenticação segura de usuários em redes móveis e tem atraído a atenção de muitos pesquisadores \cite{P, S, T}. 

Yildirim et a. \cite{S} propõe o uso do leitor biométrico somado a identidade de equipamento móvel internacional (IMEI) para a geração de uma senha única e expirável para a autenticação em sistemas web. Alguns fabricantes de dispositivos móveis permitem que os desenvolvedores usem os recursos de segurança do dispositivo em seus aplicativos por meio do kit de desenvolvimento do dispositivo (SDK) do dispositivo.

Wu et al. \cite{P} propõe que os dados obtidos a partir de um smartphone podem ser usados para identificar o usuário do smartphone, sem a necessidade de alguma ação pelo usuário. O autor afirma que Métodos tradicionais utilizam identificadores explícitos como o IMEI, a identidade de assinante móvel internacional (IMSI) ou o Android ID. No entanto, alguns identificadores explícitos não são confiáveis e podem ser facilmente adulterados ou forjados, além de que, para obtê-los, é necessário solicitar permissão do usuário o que pode causar em abuso de permissões sensíveis e vazamento da privacidade \cite{Q, R}.

Para resolver esses problemas, Wu et al. \cite{P} propõe três algoritmos de identificação de dispositivos baseado em identificadores implícitos que podem ser obtidos sem solicitar qualquer permissão \cite{P}. Os identificadores implícitos são compostos por dados obtidos (i) da camada física (hardware) como espaço em disco, (ii) da camada de aplicação (sistema operacional) como versão do Android e (iii)  da camada do usuário (configurações) como time-zone. 


% ----------------------------------------------------------------- 



\section{Cheiros de Código Específicos}

Nas últimas décadas, muitos cheiros de código para projetos orientado a objetos foram catalogados \cite{Refactoring:99, Riel}. Riel \cite{Riel} definiu mais de 60 características de um bom código orientado a objetos. Martin Fowler \cite{Refactoring:99} definiu mais de 20 maus cheiros como por exemplo \textit{Feature Envy}, que são métodos que estão mais interessados em outras classes do que na própria classe. Existem diversas ferramentas atualmente que conseguem realizar a detecção automática de diversos desses cheiros de código como PMD \cite{PMD2016} e Sonarqube \cite{Sonarqube2016}.

Aniche et al. \cite{FinavaroAniche2016} em seu trabalho de doutorado, encontrou cheiros de código específicos ao framework Java Spring MVC, foram eles \textit{Promiscuous Controller}, \textit{Smart Controller}, \textit{Meddling Service}, \textit{Smart Repositories}, \textit{Laborious Repository Method} e \textit{Fat Repository}. 

Mario et al. \cite{DomainMatters} salienta a importância do domínio ao se tratar de cheiros de código ao concluir em sua pesquisa que \textit{antipatterns} em aplicações com determinados domínios tem sua qualidade negativamente impactada mais do que outros. 

Gharachorlu \cite{CSSCodeSmell} avaliou a existência de más práticas em arquivos CSS de projetos de código aberto. Essas más práticas foram extraídas de sites e blogs técnicos. De acordo com o autor, as más práticas mais frequentes eram valores fixos, estilos que desfaziam o que estilos anteriores faziam e o uso de seletores id. 

% Silva et al. \cite{Silva_Does_2015} executou uma análise em sistemas de código aberto e mostrou que códigos Javascript tendem a usar conceitos de orientação a objetos em 36\% dos sistemas analisados.



\section{Cheiros de Código Específicos ao Android}

% Em outros trabalhos sobre cheiros de código Android, foram identificados cheiros de código relacionados a segurança, consumo inteligente de recursos ou que de alguma maneira influênciavam a experiência ou expectativa do usuário.
Diversas trabalhos em torno de cheiros de código vem sendo realizadas ao longo dos últimos anos. Já existem inclusive diversos cheiros de código mapeados, porém poucos deles são específicos da plataforma Android \cite{Mannan_Dig_Ahmed_Jensen_Abdullah_Almurshed}. Segundo Hecht \cite{Hecht2015} estudos sobre cheiros de código de código sobre aplicações Android ainda estão em sua infância. Outro ponto que reafirma esta questão são os trabalhos de Linares-Vásquez \cite{DomainMatters} e Hecht \cite{Hecht2015} onde concluem que, em projetos Android, é mais comum cheiros de código específicos do que cheiros de código Orientado a Objetos. 

O trabalho de Verloop \cite{MobileSmells:13} avalia a presença de cheiros de código definidos por Fowler \cite{Refactoring:99} e Minelli e Lanza \cite{Mantyla2013} em projetos Android. Apesar das relevantes contribuições feitas, a conclusão sobre a incidência de tais cheiros de código não é plenamente conclusiva, visto que dos 6 cheiros de código analisados (\textit{Large Class}, \textit{Long Method}, \textit{Long Parameter List}, \textit{Type Checking}, \textit{Feature Envy} e \textit{Dead Code}) apenas dois deles, \textit{Long Method} e \textit{Type Checking}, se apresentam com maior destaque (duas vezes mais provável) em projetos Android. Os demais apresentam uma diferença mínima em classes Android quando se comparados a classes não específicas do Android. Por fim, acaba por não ser conclusivo quanto a maior relevância deles em Android ou não. 

Desta forma, Verloop \cite{MobileSmells:13} conclui com algumas recomendações de refatoração de forma a mitigar a presença do mau cheiro \textit{Long Method}. Estas recomendações são o uso do atualmente já reconhecido padrão \textit{ViewHolder} em classes do tipo \texttt{Adapters}. Ele também sugere um \textit{ActivityViewHolder} de forma a extrair código do método \texttt{onCreate} e deixá-lo menor. Sugere também o uso do atributo \texttt{onClick} em XMLs de \textsc{layout} e \textsc{menu}. 

% Sobre esta última recomendação, acredito que será entendida como um anti-pattern, visto que acopla o comportamento a um layout específico além do que hoje já é possível o uso de lambdas também no desenvolvimento android, encurtando muito portanto o tamanha das antigas classes anônimas e o uso de resource ids ao invés dos resources values, onde o código fica mais verboso, logo, mais complicado de ler, ele recomenda sempre que possível, usar o resource id ao invés do resource value. Apesar disso, sabemos que código legível resulta em tempo de desenvolvimento menor, pois códigos complexos dificultam o desenvolvimento de software. Das ferramentas de análise de código analisadas por Verloop, a única que suporta XML é a Lint, desenvolvida pela Google para Android. [DIFERENÇA] 

Diferentemente de validar a presença de cheiros de código previamente catalogados conforme feito por Verloop \cite{MobileSmells:13}, esta dissertação objetiva identificar, catalogar e validar, com base na experiência de desenvolvedores, boas e más práticas específicas à \textbf{camada de apresentação de projetos Android}. 

Outro trabalho muito relevante realizado nesse tema é o de Reimann et al. \cite{ReimannBrylski2013} que, baseado na documentação do Android e sites técnicos, documentou 30 \textit{quality smells} específicos para Android. No texto, \textit{quality smells} são definidos como \textit{``uma determinada estrutura em um modelo, indicando que influência negativamente requisitos específicos de qualidade, que podem ser resolvidos por refatorações particulares ao modelo''} (tradução livre). Entretanto, esses requisitos de qualidade são centrados no usuário (estabilidade, tempo de início, conformidade com usuário, experiência do usuário e acessibilidade), consumo inteligente de recursos (eficiência geral e no uso de energia e memória) e segurança. Aspectos relacionados a qualidade de código não são considerados nesse trabalho de Reimann et al. \cite{ReimannBrylski2013}. Esta dissertação se difere do trabalho Reimann et al. \cite{ReimannBrylski2013} pois pretende-se encontrar cheiros de código em termos de qualidade de software, ou seja, que influenciam na legibilidade e manutenibilidade do código do projeto.
