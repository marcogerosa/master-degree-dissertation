% -*- root: dissertation.tex -*-
% \todo{Colocar sessão que fala sobre a importancia de maus cheiros, exemplo tirado dos slides da quali: Classes com antipatterns tendem a ter mais alterações e falhas. [Khomh et al., 2011]}

Aplicativos Android são desenvolvidos, em sua maioria, utilizando a linguagem de programação Java \cite{AndroidFundamentals}. Deste modo, um provável questionamento é: ``Por que investigar maus cheiros específicos ao Android quando já existem tantos maus cheiros e boas práticas documentadas para linguagens orientada a objetos como o Java?''. Para responder a esta pergunta temos as seguintes seções:

\begin{itemize}
  % \item A Seção \ref{android-vs-tradicional} apresenta pesquisas que investigaram e encontraram importantes características que diferenciam projetos Android de projetos de sistemas tradicionais, como projetos web e cliente/servidor. Essas características agregam complexidades ao desenvolvimento Android não encontradas no desenvolvimento de sistemas tradicionais. 

  \item A Seção \ref{maus-cheiros-tradicionais} apresenta pesquisas em torno de maus cheiros tradicionais. Existem diversos maus cheiros tradicionais catalogados. As pesquisas mais recentes buscam investigar as relações e implicações decorrentes da presença desses maus cheiros.

  \item A Seção \ref{maus-cheiros-especificos} apresenta pesquisas que têm demonstrado que diferentes tecnologias podem apresentar maus cheiros específicos. Há pesquisas que concluem que, tecnologias usadas na camada de apresentação de sistemas web tradicionais, apresentam maus cheiros diferentes das tecnologias usadas no restante do sistema. Essas pesquisas reforçam nossa hipótese de que o desenvolvimento da camada de apresentação Android também pode apresentar maus cheiros específicos e distintos do restante do código do aplicativo.

  \item A Seção \ref{maus-cheiros-android} apresenta pesquisas que investigaram (i) a presença de maus cheiros tradicionais em aplicativos Android, (ii) a existência de maus cheiro específicos ao Android e também (iii) compararam a presença de maus cheiros tradicionais com relação a presença de maus cheiros específicos em aplicativos Android. Essas pesquisas reforçam a relevância de investigarmos maus cheiros Android pois concluem que maus cheiros específicos aparecem com maior frequência do que os maus cheiros tradicionais.
\end{itemize}

Ao final desta seção esclarecemos os motivos pelo qual optamos por investigar maus cheiros de código relacionados à camada de apresentação Android e também damos uma visão sólida do estado da arte sobre o assunto.

% Muitas pesquisas têm sido realizadas sobre a plataforma Android, muitas delas focam em vulnerabilidades \cite{Y, F, G, X, P, D, E}, autenticação \cite{T, Yamashita6405287, R} e testes \cite{J, M}. Diferentemente dessas pesquisas, nossa pesquisa tem foco na percepção dos desenvolvedores sobre boas e más práticas de desenvolvimento na plataforma Android. 

\section{Maus Cheiros Tradicionais}
\label{maus-cheiros-tradicionais}
  Provavelmente o livro de Webster (1995) \cite{Webster:95} foi o primeiro catálogo de maus cheiros relacionados ao desenvolvimento orientado a objetos. Desde então, diversos desenvolvedores e pesquisadores têm estudado esse assunto. Como exemplo, Riel (1996) \cite{Riel:96} documentou mais de 60 heurísticas diferentes sobre o que representa um bom código orientado a objetos. Fowler (1999) \cite{Refactoring:99} sugere refatorações para mais de 20 maus cheiros de código tradicionais. Maus cheiros como Classe Deus e Inveja dos Dados são populares entre desenvolvedores e ferramentas de detecção automática de maus cheiros como por exemplo PMD \cite{PMD2016} e Sonar~\cite{Sonarqube2016}.

  Alguns pesquisadores têm focado seus esforços em entender os impactos de maus cheiros na qualidade de projetos. Khomh et al. \cite{Khomh:2009:ESI:1685994.1686210} conduziram um experimento empírico onde perceberam que classes afetadas por maus cheiros tendem a sofrer com mais alterações do que classes sem maus cheiros. Em outro estudo, Khomh et al. \cite{Khomh:2012:ESI:2158916.2158921} perceberam que além de maus cheiros impactarem negativamente a tendência a mudanças, também impactam negativamente a tendência a defeitos. 

  Li e Shatnawi \cite{Li:07} também analisaram empiricamente o impacto de maus cheiros e mostraram que existe uma alta relação entre a tendência a defeitos e alguns maus cheiros. Yamashita e Moonen \cite{Yamashita:2013:EII:2486788.2486878} mostraram que a existência de mais do que um único mau cheiro em uma classe pode afetar negativamente a manutenção desse trecho de código. Essa conclusão é confirmada por Abbes at al. \cite{Abbes:11} num experimento controlado para investigar o impacto de alguns maus cheiros na compreensão do sistema. Os autores mostraram que a existência de um único mau cheiro em uma classe não diminui significativamente o desempenho de um desenvolvedor durante as tarefas de manutenção. No entanto, quando uma classe apresenta mais de um mau cheiro, o desempenho do desenvolvedor é significativamente reduzido.

  Outros pesquisadores têm estudado sobre como os maus cheiros são percebidos por desenvolvedores. Palomba et al. \cite{Palomba_Do_2014} conduziram um experimento empírico para avaliar a percepção por desenvolvedores sobre maus cheiros tradicionais. Os resultados mostraram que maus cheiros ``simples'' são facilmente percebidos por desenvolvedores. Entretanto, a experiência e conhecimento desempenham um papel importante na identificação de maus cheiros relacionado a boas práticas de desenvolvimento orientado a objetos. 

  Taibi et al. \cite{Taibi:17} investigaram a percepção apenas de desenvolvedores experientes sobre maus cheiros tradicionais, totalizando mais de 100. Os resultados mostraram que apesar de desenvolvedores considerarem alguns maus cheiros críticos na teoria, na prática eles são mais toleráveis. Hozano et al. \cite{Hozano:18} investigaram a similaridade com que maus cheiros são percebidos por desenvolvedores. Seus resultados mostraram que desenvolvedores identificam maus cheiros de diversas formas diferentes. No entanto, grupos de desenvolvedores que utilizaram a mesma heurística apresentaram um maior grau de concordância do que grupos de desenvolvedores que apresentavam a mesma experiência.

  Arcoverde et al. \cite{arcoverde2011understanding} realizaram uma pesquisa para entender como os desenvolvedores reagem à presença de maus cheiros de código. Os resultados mostraram que desenvolvedores adiam a remoção para evitar modificações da API (do inglês \ac{API}). Peters e Zaidman \cite{Peters:12} analisaram o comportamento dos desenvolvedores em relação ao ciclo de vida dos maus cheiros e os resultados mostraram que, mesmo quando os desenvolvedores estão conscientes da presença de um mau cheiro, eles não refatoram.



% \section{Projetos Android vs. projetos de sistemas tradicionais}
% \label{android-vs-tradicional}

%   Minelli e Lanza \cite{Mantyla2013} investigaram diferenças no desenvolvimento de aplicativos em comparação a sistemas tradicionais em termos de tamanho, complexidade, uso de bibliotecas terceiras e presença de maus cheiros. Para isso os autores se utilizam da ferramenta SAMOA, desenvolvida por eles, para realizar a análise estática de código. Para focar a análise os autores segmentam o código em dois grupos, ``classes núcleo'' e ``classes não núcleo'', similar a Verloop \cite{MobileSmells:13}. Classes núcleo são classes que herdam do Android SDK e classes não núcleo seriam as outras. Os autores coletam quais códigos serão analisados a partir do arquivo \textit{AndroidManifest.xml}. Os resultados mostraram que aplicativos são muito menores que sistemas tradicionais e utilizam muito mais bibliotecas terceiras, dificultando sua manutenção e compreensão por outros desenvolvedores. 

\section{Maus Cheiros Específicos a uma Tecnologia}
\label{maus-cheiros-especificos}

  A constante e rápida evolução de tecnologias existentes e a criação de novas tecnologias faz com que diversos temas, como manutenibilidade de sistemas, estejam também em constante alta. Muitos pesquisadores vêm pesquisando sobre a existência de maus cheiros de código específicos a uma dada tecnologia, por exemplo, arcabouços Java \cite{MvcSmells:16, ORMSmells}, a linguagem CSS (do inglês \ac{CSS}) \cite{CSSCodeSmell} e fórmulas em planilhas \cite{SpreadsheetsSmells:12}.

  Chen et al. \cite{ORMSmells} viram a necessidade de estudar maus cheiros de código em arcabouços de Mapeamento Objeto-Relacional (ORM, do inglês \textit{Object-Relational Mapping}) pelo grande uso pela indústria e pela desatenção de desenvolvedores sobre ao impacto de seus códigos no desempenho do banco de dados que podiam causar estouro no limite de tempo de processamento e paradas nos sistemas. Os autores implementaram um arcabouço automatizado e sistemático para detectar e priorizar anti-padrões de desempenho em aplicações desenvolvidas usando ORM e também mapearam 2 anti-padrões específicos a arcabouços ORM.

  Aniche et al. \cite{AnicheSmellsMVC:17, MvcSmells:16, FinavaroAniche2016} investigaram maus cheiros de código relacionado ao arcabouço Spring MVC (do inglês \ac{MVC}), usado para o desenvolvimento da camada de apresentação de aplicações web Java. Os autores encontraram maus cheiros específicos de cada papel arquitetural do arcabouço Spring MVC: Modelo, Visualização e Controladora. Eles afirmam que cada papel arquitetural possui responsabilidades diferentes e que isso resulta em distribuições diferentes de valores de métricas de código e maus cheiros diferentes. Dentre as principais contribuições desse estudo, está um catálogo com 6 maus cheiros específicos validados relacionados ao arcabouço Spring MVC.

  Gharachorlu \cite{CSSCodeSmell} investigou maus cheiros em código CSS, linguagem amplamente utilizada na camada de apresentação de aplicações web para separar a semântica de apresentação do conteúdo HTML. De acordo com o autor, apesar da simplicidade de sintaxe do CSS, as características específicas da linguagem tornam a criação e manutenção de CSS uma tarefa desafiadora. Foi realizado um estudo empírico de larga escala onde os resultados indicaram que o CSS de hoje sofre significativamente de padrões inadequados e está longe de ser um código bem escrito. O autor propõe o primeiro modelo de qualidade de código CSS derivado de uma grande amostra de modo a ajudar desenvolvedores a obterem uma estimativa do número total de cheiros de código em seu código CSS. Sua principal contribuição foi um conjunto de 8 novos maus cheiros CSS detectados com o uso da ferramenta CSSNose, também implementada e disponibilizada pelo autor.

  Fard e Ali \cite{JavascriptSmells} investigaram maus cheiros de código no Javascript, que é uma flexível linguagem de \textit{script} para o desenvolvimento do comportamento do lado do cliente, que faz parte da camada de apresentação de aplicações web. Os autores afirmam que, devido a essa flexibilidade, o JavaScript é uma linguagem particularmente desafiadora para escrever e manter código. Um dos desafios citados é que, diferentemente de aplicativos Android, que são compilados, o Javascript é interpretado. Isso significa que normalmente não há compilador no ciclo de desenvolvimento para ajudar desenvolvedores a detectar código incorreto ou não otimizado. Além desses desafios, os autores também indicam como problema a natureza dinâmica, fracamente tipificada e assíncrona do Javascript. Eles propõem um conjunto de 13 maus cheiros de código JavaScript, sendo 7 maus cheiros tradicionais adaptados para o JavaScript e 6 maus cheiros específicos ao JavaScript derivados da pesquisa. Também é apresentada uma técnica automatizada, chamada JSNOSE, para detectar esses maus cheiros.

  % \todo{adicionar parágrafo sobre smells em planilhas, achar ref}

  Uma interessante relação que vemos é que muitas pesquisas buscaram por maus cheiros específicos em tecnologias usadas na camada de apresentação de aplicações web \cite{MvcSmells:16, JavascriptSmells, CSSCodeSmell} o que reforça nossa hipótese de que aplicativos Android podem seguir o mesmo comportamento possivelmente apresentando maus cheiros específicos à camada de apresentação não encontrados necessariamente nos demais códigos do aplicativo.

\section{Maus Cheiros em Aplicativos Android}
\label{maus-cheiros-android}

  % como vimos na Seção anterior X.X.X, que inclusive nos mostrou que é possível identificar maus cheiros no \textit{front-end} de aplicações de sistemas tradicionais e que estes, por sua vez, são diferentes dos maus cheiros encontrados no \textit{back-end}. Outras pesquisas concluem que projetos Android possuem características diferentes de projetos java \cite{Hecht:15, Mannan_Dig_Ahmed_Jensen_Abdullah_Almurshed, 30QualitySmells:14}, como vimos na Seção X.X.X. 

  % por exemplo, o \textit{front-end} é representado por arquivos XML e o ponto de entrada da aplicação é dado por \textit{event-handler} \cite{AndroidActivities2016} como o método \textsc{onCreate}. Encontramos também diversas pesquisas sobre \textit{code smells} sobre tecnologias usadas no desenvolvimento de \textit{front-end} web como CSS \cite{CSSCodeSmell} e JavaScript \cite{BB}. Essas pesquisas nos inspiraram a buscar entender se existem \textit{code smells} no \textit{front-end} Android. \\

  Pesquisas relacionadas a maus cheiros em aplicativos Android ainda são poucas. Umme et al. \cite{Mannan_Dig_Ahmed_Jensen_Abdullah_Almurshed} afirmam que, das principais conferências de manutenção de sistemas, dentre 2008 a 2015, apenas 10\% dos artigos consideraram em suas pesquisas projetos Android. Nenhuma outra plataforma móvel foi considerada. As conferências consideradas foram: ICSE, FSE, OOPSLA/SPLASH, ASE, ICSM/ICSME, MRS e ESEM. 

  Dentre as pesquisas relacionadas, para efeito desta pesquisa, temos: a Seção \ref{sec:maus-cheiros-tradicionais-em-android} com pesquisas que buscaram por maus cheiros tradicionais em aplicativos Android, a Seção \ref{sec:maus-cheiros-especificos-android} com pesquisas que buscaram por maus cheiros específicos a aplicativos Android, grupo ao qual nossa pesquisa está inserida e a Seção \ref{sec:maus-cheiros-tradicionais-especificos-android} com pesquisas que buscaram ambos os maus cheiros, específicos e tradicionais, em aplicativos Android e comparam a frequência e relevância entre eles. 

  % As seções seguintes tratam do estado da arte de cada um desses grupos bem como suas semelhanças e diferenças com nossa pesquisa.

  \subsection{Maus Cheiros Tradicionais em Aplicativos Android}
  \label{sec:maus-cheiros-tradicionais-em-android}
    Linares-Vásquez et al. \cite{DomainMatters} usaram a ferramenta DECOR para realizar a detecção de 18 diferentes anti-padrões orientado a objetos em aplicativos móveis desenvolvidos com J2ME (do inglês \ac{J2ME}) e entender a relação dos maus cheiros com o domínio do negócio e métricas de qualidade. Dentre as principais conclusões do estudo temos que, existe uma grande diferença nos valores das métricas de qualidade em aplicativos afetados pelos maus cheiros e pelos que não são, e que enquanto há maus cheiros presentes em todos os domínios, alguns são mais presentes em domínios específicos. %[\todo{quais as semelhanças e diferenças??? reler trabalho e comparar com o meu}]

    Verloop \cite{MobileSmells:13} investigou a presença de maus cheiros de código tradicionais propostos por Fowler \cite{Refactoring:99} (Método Longo, Classes Grande, Lista de Parâmetros Longa, Inveja dos Dados e Código Morto) em aplicativos Android para determinar se esses maus cheiros ocorrem mais frequentemente em ``classes núcleo'', classes no projeto Android que precisam herdar de classes do Android \acs{SDK}, como por exemplo \textit{Activities}, \textit{Fragments} e \textit{Services}, comparando com classes ``não núcleo''. Para isso, ele fez uso de 4 ferramentas de detecção automática de maus cheiros: JDeodorant, Checkstyle, PMD e UCDetector.  

    % O desenvolvimento Android é basicamente através da linguagem Java, considerando isso, uma pergunta óbvia seria: Por que buscar por maus cheiros específicos Android se já existem tantos definidos aplicáveis a código Java? Uma característica do Android é que, apesar de ser código Java, muitas classes em projetos Android precisam herdar de classes do SDK Android, por exemplo Activities, Fragments e Services.  Essa característica o torna diferente e portanto, sucetível a apresentar maus cheiros específicos. Verloop classifica todo código Java, em um projeto Android, que precisa herdar de classes do SDK Android como classes núcleo. Durante sua análise, ele compara a presença dos maus cheiros em classes núcleo e não núcleo, sendo esta última, classes puramente Java.

    % \todo{falar das muitas responsabilidades de activities no background de android}.%
    O autor afirma que classes núcleos tendem a apresentar os maus cheiros: Classe Deus, Método Longo, Comandos \textit{Switch} e Checagem de Tipo pela sua natureza de muitas responsabilidades. As classes mais observadas com esses maus cheiros foram \textit{Activities}, que é o principal componente da camada de apresentação Android. O autor também conclui que o mau cheiro tradicional Longa Lista de Parâmetros é menos provável de aparecer em classes núcleo pois, nessas classes, a maioria dos métodos são sobrecargas de métodos da classe herdada proveniente do Android SDK, e como para se realizar uma sobrecarga de método é necessário seguir a assinatura do método original, este normalmente não é afetado por este mau cheiro. Maus cheiros tradicionais não foram pensados considerando a natureza de projetos Android, que neste caso está relacionada a herança de classes núcleo.


    % Um ponto a se pensar é, se a natureza da Activity é de ter muitas responsabilidades, talvez estejamos analisando-a a partir de um ponto de vista inadequado ao buscarmos por \textit{God Class} ou \textit{Long Method}, visto que sabe-se agora de que estes maus cheiros de fato a afetam, mas que de certa forma, esse é o \textit{modus operandi} normal dela. Chegamos ao ponto que a natureza do Android pode implicar em maus cheiros específicos que tragam outros ponto de vista que respeitem a natureza de aplicativos Android, e proponham uma refatoração adequada.

    % O que é interessante é, se esta de classes núcleo, que caracterizam projetos Android (pois sem isso é apenas um projeto Java), será que estes maus cheiros tradicionais nos dão a informação necessária para refatorar e aumentar a manutenibilidade do código? Pois, se é da natureza da Activity ser assim, talvez as soluções propostas para refatorar estes maus cheiros não se apliquem ao Android. Logo, chegamos ao ponto que a natureza do Android pode implicar em maus cheiros específicos que tragam outras abordagens, que respeitem a natureza de projetos Android, para refatoração.

    

    % [explicar melhor estes resultados - chapter 6]
    Verloop \cite{MobileSmells:13} conclui propondo cinco refatorações com o objetivo de mitigar o mau cheiro Método Longo que se apresentou por diversos motivos em \textit{Activities} e \textit{Adapters}. Dentre essas cinco propostas de refatoração, ele implementou e experimentou três. porém após as refatorações, alguns códigos ainda apresentavam o mau cheiro.

    % , sendo que:

    % \begin{itemize}

    %   \item A primeira, uso do padrão \texttt{ViewHolder} em \texttt{Adapter}, de fato melhora a qualidade do código, no exemplo do autor, dos 12 \texttt{Adapter} afetados pelo mau cheiro \textit{Long Method}, após a refatoração apenas 4 continuaram apresentando o mau cheiro. Este padrão trás resultados não apenas em manutenibilidade, mas também em eficiência, realizando um consumo melhor de memória, processamento e energia. Por todos estes benefícios no uso desse padrão, atualmente o Android SDK já provê um componente com esta implementação de forma nativa, o componente \textit{RecyclerView} \footnote{https://developer.android.com/reference/android/support/v7/widget/RecyclerView.html}.
    
    %   \item A segunda, uma espécie de ViewHolder para \textit{Activities}, objetivava mitigar Long Method, porém não trouxe bons resultados sendo que das 13 \textit{Activities} refatoradas, nenhum deixou de ser afetada pelo Long Method. Dessa forma, o autor conclui que outros não trabalhados por meio da refatoração proposta influenciam na aparição deste mau cheiro em \textit{Activities}. Estes outros fatores estão relacionados a \textit{listeners} e classes anônimas usados para a implementação de comportamento dos elementos da camada de apresentação pois estes códigos são comumente colocados no método \texttt{onCreate} de Activities.
    
    %   \item A terceira propõe mitigar o mau cheiro Long Method em Activities trocando a atribuição de \textit{listeners} feitas com classes anônimas pelo uso do atributo \texttt{OnClick} no XML de layout respectivo. Os resultados aqui obtidos também não foram muito satisfatórios pois, das 13 classes refatoradas, 7 ainda apresentaram o mau cheiro devido ao uso de outros \textit{listeners} que não o de \textit{click}, que não possuem atributos correspondentes no XML de layout. Além disso, já se sabe hoje que o uso de atributos não é interessante devido ao acoplamento resultante da \texttt{Activity} com aquele determinado XML dentre outros problemas. Apesar disso, o autor considerou este resultado como positivo. %\todo{explicar e trazer ref}

    % \end{itemize}

    É interessante notar que dentro da definição de Verloop \cite{MobileSmells:13} de classes núcleo, estão incluídas classes que herdam de \textit{Services} e todas as demais que herdam de alguma classe do SDK Android, porém as únicas classes que apresentaram maus cheiros foram \textit{Activities} e \textit{Adapters}. Como vimos em \ref{sec:Android}, essas classes são responsáveis por lidar com a camada de apresentação Android. Isso reforça nossa hipótese de que podem haver maus cheiros específicos a camada de apresentação Android, não existentes no restante dos códigos do aplicativo, e por isso é interessante estudar mais a fundo. 
  
  \subsection{Maus Cheiros Específicos a Aplicativos Android}
  \label{sec:maus-cheiros-especificos-android}

    % \todo{explicar mais, com exemplos, do que se tratam os maus cheiros encontrados nesses trabalhos e por que os meus são diferentes}

    % \todo{quais?}
    Gottschalk et al. \cite{RemovingEnergySmells:12} conduziram um estudo sobre formas de detectar e refatorar maus cheiros de código relacionados ao uso eficiente de energia. Os autores compilaram um catálogo com 6 maus cheiros de código extraídos de outros trabalhos, e trabalharam sob um trecho de código Android para exemplificar um deles, o \textit{Carregar Recurso Muito Cedo}, quando algum recurso é alocado muito antes de precisar ser utilizado. Essa pesquisa é relacionada à nossa por ambas considerarem a tecnologia Android e se diferenciam pois focamos na busca por maus cheiros de código relacionados a manutenibilidade enquanto os autores tratam de eficiência, conforme conceitos de qualidade de sistemas apresentados da Seção \ref{sec:software-quality}.

    Reimann et al. \cite{30QualitySmells:14} correlacionam os conceitos de mau cheiro, qualidade e refatoração a fim de introduzir o termo mau cheiro de qualidade. Segundo os autores, um mau cheiro de qualidade é uma estrutura que influencia negativamente requisitos de qualidade específicos, que podem ser resolvidos por refatorações \cite{Reimann}. Os autores compilaram um catálogo de 30 maus cheiros de qualidade para Android. O formato dos maus cheiros de qualidade inclui: nome, contexto, requisitos de qualidade afetados e descrição. Esse formato foi baseado nos catálogos de Brown et al. \cite{AntiPatterns:98} e Fowler \cite{Refactoring:99}. Todo o catálogo pode ser encontrado online\footnote{http://www.modelrefactoring.org/smell\_catalog} e os mesmos também foram implementados no arcabouço Refactory \cite{Reimann}. Os requisitos de qualidade tratados por Reimann et al. \cite{30QualitySmells:14} são: centrados no usuário (estabilidade, tempo de inicio, conformidade com usuário, experiência do usuário e acessibilidade), consumo inteligente de recursos de hardware do dispositivo (eficiência no uso de energia, processamento e memória) e segurança. 

    Reimann et al. \cite{30QualitySmells:14} citam que ``\textit{o problema no desenvolvimento móvel é que os desenvolvedores estão cientes dos maus cheiros de qualidade apenas indiretamente, que suas definições são informais como melhores práticas e discussões em fóruns}''. Continua dizendo que ``\textit{os recursos para encontrá-los são distribuídos pela web e que é difícil coletar e analisar todas essas fontes sob um ponto de vista comum e fornecer suporte de ferramentas para desenvolvedores}''. Os autores derivaram os 30 maus cheiros de boas e más práticas documentadas na documentação online oficial do Android e de postagens em blogs de desenvolvedores que reportaram suas experiências. 
    % (segundo o paper de Geoffrey Hetch - abaixo).\todo{rever isso aqui}

  \subsection{Maus Cheiros Tradicionais e Específicos em Aplicativos Android}
  \label{sec:maus-cheiros-tradicionais-especificos-android}

    Hetch \cite{HetchDetectingAntipatternsAndroidApps:15} utilizou a ferramenta de detecção de maus cheiros Páprika\footnote{https://github.com/geoffreyhecht/paprika} para identificar 8 maus cheiros, dos quais 4 são tradicionais: Classe \textit{Blob} \cite{AntiPatterns:98}, Canivete Suíço \cite{AntiPatterns:98}, Classe Complexa \cite{Refactoring:99} e Método Longo \cite{Refactoring:99} e 4 são Android: \textit{Internal Getter/Setter} \cite{30QualitySmells:14}, \textit{No Low Memory Resolver} \cite{30QualitySmells:14}, \textit{Member Ignoring Method} \cite{30QualitySmells:14} e \textit{Leaking Inner Class} \cite{30QualitySmells:14}. O autor buscou os maus cheiros em 15 aplicativos Android populares como Facebook, Skype e Twitter. Isso foi possível pois a ferramenta Páprika utiliza o APK, arquivo instalável Android, para extrair os dados para análise e mesmo esses aplicativos não sendo software livre, o Páprika consegue extrair os dados a partir do instalável. Um ponto importante é que apesar de o autor utilizar o termo anti-padrão, ele se baseia em outras pesquisas que definiram os ``anti-padrões'' por ele analisado como maus cheiros de código. Logo, seguiremos com o termo mau cheiro daqui em diante. 
    % Vale considerar que, para se classificar como um anti-padrão, o item deve atender as duas características mencionadas em \cite{AntiPatterns:98} como abordamos na Seção \ref{sec:anti-patterns}.

    Hetch \cite{HetchDetectingAntipatternsAndroidApps:15} afirma que os maus cheiros tradicionais são tão frequentes em aplicativos Android como em não Android, com exceção do Canivete Suíço. Essa afirmação nos leva a entender que ele teria comparado a presença dos maus cheiros tradicionais em sistemas tradicionais com os mesmos maus cheiros em aplicativos Android, entretanto, não há informações de como o autor obteve a informação da presença de maus cheiros em projetos de sistemas tradicionais para compará-la com o resultado obtido em aplicativos Android. 

    Segundo o autor, \textit{Activities} tendem a ser mais sensíveis ao mau cheiro Classe \textit{Blob} \cite{AntiPatterns:98} (semelhante aos maus cheiros Classe Deus \cite{Riel:96} e Classe Grande \cite{Refactoring:99}). Conclusão essa muito similar a de Verloop \cite{MobileSmells:13}. Esses resultados reforçam nossa hipótese de que, códigos pertencentes à camada de apresentação Android, são mais propensos a apresentar trechos de códigos problemáticos. Ainda segundo o autor, maus cheiros específicos Android são muito mais frequentes do que os maus cheiros tradicionais. Essa constatação reforça a importância de se investigar quais seriam outros possíveis maus cheiros específicos ao Android, uma vez que eles tendem a se manifestar mais do que os maus cheiros tradicionais em aplicativos Android.

    

% \section{Android}
% geral android (opcional)
% Na prática, não acho que faz sentido pois não tenho muito comparar meu trabalho eu acho, mas deixa como opcional

% \section{Maus cheiros específicos ao Android}

%   \subsection{Removing Energy Code Smells with Reengineering Services}

%     Gottschalk et al \cite{RemovingEnergySmells:12} conduziram um estudo sobre formas de detectar e refatorar cheiros de código relacionados ao uso eficiente de energia. Os autores compilaram um catálogo com 6 cheiros de código extraído de outros trabalhos, e trabalharam sob um trecho de código Android para exemplificar um deles, o \textit{Carregar Recurso Muito Cedo}, quando algum recurso é alocado muito antes de precisar ser utilizado. Essa pesquisa é relacionada à nossa por ambas considerarem a tecnologia Android e se diferenciam pois focamos na busca por maus cheiros de código relacionados manutenibilidade enquanto eles tratam de eficiência, conforme conceitos de qualidade de sistemas apresentados da Seção 2.2.

%   \subsection{A Tool-Supported Quality Smell Catalogue For Android Developers - Reimann et al.}

%     Reimann et al. \cite{30QualitySmells:14} correlaciona os conceitos de mau cheiro, qualidade e refatoração a fim de introduzir o termo cheiro de qualidade (do inglês \textit{quality smell}). Um cheiro de qualidade é uma estrutura que influencia negativamente requisitos de qualidade específicos, que podem ser resolvidos por refatorações \cite{Reimann}.

%     Os autores compilaram um catálogo de 30 cheiros de qualidade para Android. O formato dos cheiros de qualidade incluem: nome, contexto, requisitos de qualidades afetados e descrição, este formato foi baseado nos catálogos de Brown et al. \cite{AntiPatterns:98} e Fowler \cite{Refactoring:99}. Todo o catálogo pode ser encontrado em [http://www.modelrefactoring.org/smell\_catalog](http://www.modelrefactoring.org/smell\_catalog) e os mesmos também foram implementados no framework Refactory \cite{Reimann}.

%     O requisitos de qualidade tratados por \cite{30QualitySmells:14} são: centrados no usuário (estabilidade, tempo de inicio, conformidade com usuário, experiência do usuário e acessibilidade), consumo inteligente de recursos de hardware do dispositivo (eficiência no uso de energia, processamento e memória) e segurança.

%     Reimann et al. \cite{30QualitySmells:14} cita que o problema no desenvolvimento móvel é que os desenvolvedores estão cientes de cheiros de qualidade apenas indiretamente porque suas definições são informais (melhores práticas, problemas de rastreamento de bugs, discussões de fórum etc.) e os recursos onde encontrá-los são distribuídos pela web e que é difícil coletar e analisar todas essas fontes sob um ponto de vista comum e fornecer suporte de ferramentas para desenvolvedores. 

%     Derivou os 30 maus cheiros de boas e más práticas documentadas online na documentação do Android e de postagens em blogs de desenvolvedores que reportaram suas experiências. (segundo o paper de Geoffrey Hetch - abaixo)


% \section{Presença de maus cheiros em projetos Android}

%   \subsection{Code Smells in the Mobile Applications Domain - Verloop}Long Method em Activities trocando atribuição de listener feitas com classes anônimas pelo uso do atributo OnClick no layout respectivo. Os resultados aqui obtidos não foram muito satisfatórios também pois, das 13 classes refatoradas, 7 ainda apresentaram o mau cheiro devido ao uso de outros listeners que não o de click, que não possuem atributos correspondentes. Além disso, já se sabe hoje que o uso de atributos não é interessante devido ao acoplamento resultante da Activity com aquele determiado XML dentre outros problemas [quais?]. Apesar disso, Verloop considerou os resultados bons.

%     É interessante notar que dentro da definição de classes núcleo estão incluídas classes que heram de Services, dentre outras, porém as únicas classes que apresentaram maus cheiros foram Activities e Adapters. Como vimos em BACKGROUND ANDROID, essas classes são responsáveis por lidar com a UI e estes resultados de Verloop reforçam nossa hipótese que o front-end Android tende a ser mais problemático que o restante dos códigos da aplicação e por isso vale a pena ser estudado mais a fundo. 
   
%   \subsection{An Approach to Detect Android Antipatterns - Geoffrey HetcLongo [12]) e 4 Android (Internal Getter/Setter, No Low Memory Resolver, Member Ignoring Method e Leaking Inner Class), definidos por [Reimann] em 15 aplicações Android populares como Facebook, Skype, Twitter. Isso foi possível pois a ferramenta Páprika se utiliza do APK para extrair os dados para análise. Um ponto importante é que apesar de Hetch utilizar do termo anti-patterns, ele se baseia em outros artigos que definiram os \textit{``antipatterns''} por ele analisado como maus cheiros. Logo, seguiremos com o termos mau cheiro, pois entendemos que apesar da divergência do termo, o autor se refere a ele. Vale considerar que, para se classificar como um antipattern o item deve atender as 2 (ou 3?) características mencionadas em [ref p/ livro de antipatterns] como abordamos na Seção X.X.X [sobre antipatterns] e não há evidências que de que os itens tratados por Hetch atendem as características mencionadas.

%     Hetch afirma que os maus cheiros tradicionais são tão frequentes em aplicativos Android como em não Android, com exceção ao Swiss Army Knife, mas não há evidências de ele ter executado o Páprika em busca dos mesmos maus cheiros em projetos não Android. Segundo o artigo, Activities tendem a ser mais sensíveis ao Blob Class, mau cheiro este muito similar a God Class e Large Class, também identificado como muito comum por Verloop [?], esta conclusão reforça nossa hipótese que códigos pertencentes ao front-end Android são mais propensos a apresentar trechos problemáticos, que, apesar de já existirem maus cheiros que os identificam, a refatoração proposta não é apropriada pois é da natureza de projetos Android apresentarem estes problemas, isso nos leva a pensar que essas situações em sí não são o problema de fato, e que talvez existam outras formas de definir e lidar com esses problemas no Android.

%     Outra conclusão interessante é que o artigo diz que maus cheiros específicos Android são muito mais frequentes do que os maus cheiros tradicionais, o que reafirma a necessidade de pesquisar se há outros maus cheiros específicos, que tendem também a ser mais frequentes.

  % \subsection{Detecting antipatterns in Android aplicativos - Geoffrey Hetch}
  %   ???

  % \subsection{Domain Matters: Bringing Further Evidence of the Relatonships among Anti-patterns, Application Domains, and Quality-Related Metrics in Java Mobile aplicativos - Linares-Vásquez et al.}

    % Linares-Vásquez et al. \cite{DomainMatters} usou a ferramenta DECOR para realizar a detecção de 18 diferentes \textit{anti-patterns} orientado a objetos em aplicativos móveis desenvolvidos com Java Mobile Edition (J2ME). Este estudo em larga escala mostra que a presença de antipatterns afeta negativamente as métricas de qualidade do sistemas, em particular as métricas relacionadas à falha.


% \section{aplicativos Android vs. sistemas Tradicional}

%   \subsection{sistemas analytics for mobile applications, insights \& lessons learned - Minelli e Lanza}

%     Os autores apresentam diferenças no desenvolvimento de aplicativos e sistemas tradicionais em termos de métricas de código, uso de APIs terceiras e evolução. Para isso se utilizam da ferramenta SAMOA de análise estática de código desenvolvida por eles.

%     É interessante que para análise do código Android eles também modelam o projeto em código core e não core, onde o código core está relacionado a classes que herdam do Android SDK, apesar disso, eles dizem coletar essa informação do Android Manifesto, considerando Activities e Services, entretanto, existem diversas outras classes em um projeto Android que herdam do Android SDK e não precisam ser declaradas no Android Manifesto, ou seja, a definição usada abrange muito mais código do que de fato analisado pela pesquisa.

%     Concluem com um conjunto de características de aplicativos e com um conjunto de hábitos dos desenvolvedores destes aplicativos que diferem de aplicações de sistemas tradicionais. Dentre as características, afirmam que algumas vezes core code do app é composto por uma, ou algumas, God Classes. E que herança é algo quase inexistente em aplicativos Android. O que reforça nossa identificação de falta de arquitetura padrão, visto que esta exige um conhecimento mais aprimorado de orientação a objetos que inclui herança.

Podemos notar algumas semelhanças nos trabalhos citados. A primeira semelhança importante é que diversas pesquisas que analisam a presença de maus cheiros, sejam tradicionais ou específicos ao Android, sentem a necessidade de delimitar o código a ser analisado. Podemos observar isso nos trabalhos de Verloop \cite{MobileSmells:13} e Minelli e Lanza \cite{Mantyla2013} através do termo ``classes/códigos núcleos'' onde, em ambas as pesquisas, significam \emph{classes que herdam do Android SDK}. Essa delimitação exclui todo o código puramente Java existente no projeto Android, chamado pelos autores de ``classes não núcleo'', que são classes Java tradicionais, pelo qual continua sendo possível a utilização de diversas boas práticas já existentes na literatura. 

Ainda com relação à delimitação do código, outra semelhança interessante é que, apesar de a definição de classes núcleo incluir classes como \textit{Services}, \textit{AsyncTasks} e muitas outras existentes no Android SDK, as classes que apareceram nos resultados se limitaram a \textit{Activities} e \textit{Adapters}, utilizadas respectivamente para a construção e resposta a eventos da camada de apresentação Android. 

Essas semelhanças reforçaram nosso intuito de focar nossa pesquisa no código relacionado à camada de apresentação Android, partindo da hipótese de que existem maus cheiros específicos a ela. De modo que pretendemos pela primeira vez catalogar maus cheiros de código, relacionados à manutenibilidade, especificamente relacionados à camada de apresentação de aplicativos do Android.


% Boa frase, só falta refs e colocar no lugar certo, talvez um bom local seja na descrição do método de pesquisa
% A percepção desempenha um importante papel na definição de maus cheiros de código relacionados a uma tecnologia, visto que maus cheiros possuem uma natureza subjetiva. Maus cheiros desempenham um importante papel na busca por qualidade de código, visto que, após mapeados, podemos chegar a heurísticas para identificá-los e com essas heurísticas, implementar ferramentas que automatizem o processo de identificar códigos problemáticos.