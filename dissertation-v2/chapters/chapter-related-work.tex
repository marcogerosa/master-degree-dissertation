% -*- root: article.tex -*-
Muitas pesquisas têm sido realizadas sobre a plataforma Android, muitas delas focam em vulnerabilidades \cite{Y, F, G, X, P, D, E}, autenticação \cite{T, Yamashita6405287, R} e testes \cite{J, M}. Diferentemente dessas pesquisas, nossa pesquisa tem foco na percepção dos desenvolvedores sobre boas e más práticas de desenvolvimento na plataforma Android. 

\section{Maus cheiros específicos a uma tecnologia}

  A constante e rápida evolução de tecnologias existentes e criação de novas tecnologias faz com que diversos temas, como manutenibilidade de software, estejam também em constante alta. Muitos pesquisadores veem pesquisando sobre a existência de maus cheiros de código específicos a uma dada tecnologia como por exemplo arcabouços Java \cite{MvcSmells:16, ORMSmells}, a linguagem CSS (\textit{Cascading Style Sheets}) \cite{CSSCodeSmell} e fórmulas em planilhas [??].

  Chen et al. \cite{ORMSmells} viu a necessidade de estudar maus cheiros de código em arcabouços Object-Relational Mapping (ORM) pelo grande uso pela indústria e pela desatenção de desenvolvedores com relação ao impacto dos seus códigos no desempenho do banco de dados que podiam causar \textit{timeouts} e paradas dos sistemas. Os autores implementaram um arcabouço automatizado e sistemático para detectar e priorizar anti-padrões de desempenho em aplicações desenvolvidas usando ORM e também mapearam dois anti-padrões específicos a arcabouços ORM.

  Aniche et al. \cite{MvcSmells:16} investigaram maus cheiros de código relacionado ao arcabouço Spring MVC, usado para o desenvolvimento do \textit{front-end} de aplicações web Java. Aniche et al. encontram maus cheiros específicos a cada camada do arcabouço Spring MVC, modelo, visualização e controladora, afirmando que cada papel arquitetural possui responsabilidades diferentes o que resulta em distribuições diferentes de valores de métrica de código e maus cheiros diferentes. Dentre as principais contribuições deste trabalho está um catálogo com seis maus cheiros específicos ao arcabouço Spring MVC mapeados e validados.

  Gharachorlu \cite{CSSCodeSmell} investigou maus cheiros em código CSS, linguagem amplamente utilizada no \textit{front-end} de aplicações web para separar a semântica de apresentação do conteúdo HTML. De acordo com o autor, apesar da simplicidade de sintaxe do CSS, as características específicas da linguagem tornam a criação e manutenção de CSS uma tarefa desafiadora. Foi realizando um estudo empírico de larga escala onde os resultados indicaram que o CSS de hoje sofre significativamente de padrões inadequados e está longe de ser um código bem escrito. Gharachorlu propõe o primeiro modelo de qualidade de código CSS derivado de uma grande amostra de aprendizagem de modo a ajudar desenvolvedores a obter uma estimativa do número total de cheiros de código em seu código CSS. Sua principal contribuição foram oito novos maus cheiros CSS detectados com o uso da ferramenta CSSNose, também implementada e disponibilizada pelo autor.

  Fard e Ali \cite{JavascriptSmells} investigaram maus cheiros de código no Javascript, que é uma flexível linguagem de \textit{script} para o desenvolvimento do comportamento do \textit{front-end} de aplicações web. Os autores afirmam que devido à essa flexibilidade, o JavaScript é uma linguagem particularmente desafiadora para escrever e manter código. Alguns dos desafios citados são a questão de, diferentemente de aplicações Android que são compiladas, o Javascript é interpretado, o que significa que normalmente não há compilador no ciclo de desenvolvimento que ajudaria os desenvolvedores a detectar código incorreto ou não otimizado no momento da compilação. Outro ponto que o autor indica como problema é a natureza dinâmica, fracamente tipificada e assíncrona, além de outros desafios citados. Os autores propõem um conjunto de 13 maus cheiros de código JavaScript, sendo 7 maus cheiros tradicionais adaptados para o JavaScript e 6 maus cheiros específicos ao JavaScript derivado da pesquisa. Também é apresentada uma técnica automatizada, chamada JSNOSE, para detectar esses maus cheiros.

  Um interessante relação que vemos é que muitas pesquisas buscaram por maus cheiros específicos em tecnologias usadas no \textit{front-end} de aplicações web \cite{JavascriptSmells, CSSCodeSmell, MvcSmells:16} o que reforça nossa hipótese de que apps Android podem seguir o mesmo comportamento possivelmente apresentando maus cheiros específicos ao \textit{front-end} Android não encontrados necessariamente nos demais códigos da aplicação.

\section{Maus cheiros em apps Android}

  Segundo diversos pesquisadores e confirmado durante nossos estudos, pesquisas em torno de maus cheiros em apps Android ainda são poucas. Das pesquisas existentes, podemos classificar em 3 grupos: aquelas que buscam por maus cheiros tradicionais em apps Android \cite{DomainMatters, MobileSmells:13}, as que buscam por maus cheiros específicos em apps Android \cite{30QualitySmells:14, RemovingEnergySmells:12}, nossa pesquisa está inserida neste grupo, e as que buscam ambos os maus cheiros, específicos e tradicionais, em apps Android e tentam comparar qual deles é mais frequente \cite{Hecht:15}. Neste sentido, as Seções seguintes tratam do estado da arte de cada um desses grupos, suas relações e diferenças com nossa pesquisa.

  \subsection{Maus cheiros tradicionais em apps Android}
    Linares-Vásquez et al. \cite{DomainMatters} usou a ferramenta DECOR para realizar a detecção de 18 diferentes \textit{anti-patterns} orientado a objetos em aplicativos móveis desenvolvidos com Java Mobile Edition (J2ME) e entender a relação dos maus cheiros com o domínio de negócio e métricas de qualidade. O estudo descobre que existe uma grande diferença nos valores das métricas de qualidade em apps afetados pelos maus cheiros e pelos que não e que enquanto há maus cheiros presentes em todos os domínios, alguns são mais presentes em domínios específicos.

    A tese de Verloop \cite{MobileSmells:13} consistiu em buscar maus cheiros de códigos tradicionais, sendo esses propostos por Fowler: Long Method, Large Class, Long Parameter List, Feature Envy e Dead Code, em projetos Android para determinar se esses maus cheiros ocorrem mais frequentemente em códigos relacionado ao Android. Para isso, ele fez uso de 4 ferramentas de detecção automática de maus cheiros: JDeodorant, Checkstyle, PMD and UCDetector.  

    Basicamente o desenvolvimento Android é feito com código Java, considerando isso, uma pergunta óbvia seria: Por que buscar por maus cheiros específicos Android se já existem tantos definidos aplicáveis a código Java? Uma característica do Android é que, apesar de ser código Java, muitas classes em projetos Android precisam herdar de classes do SDK Android, por exemplo Activities, Fragments e Services.  Essa característica o torna diferente e portanto, sucetível a apresentar maus cheiros específicos. Verloop classifica todo código Java, em um projeto Android, que precisa herdar de classes do SDK Android como classes núcleo. Durante sua análise, ele compara a presença dos maus cheiros em classes núcleo e não núcleo, sendo esta última, classes puramente Java.

    Verloop confirma que classes núcleos tendem a apresentar os maus cheiros God Class [conclui que dá na mesma mobile ou não, além de não se decidir de usar Large Class ou God Class], Long Method [afirma nos resultados], Switch Statement [nem comenta nos resultados, como assim mewww????] e Type Checking [afirma nos resultados] pela sua natureza (os demais não são mais propensos a aparecer em projetos Android), conforme explicamos na Seção (BACKGROUND SOBRE ACTIVITIES NO ANDROID - falar das muitas responsabilidades, etc). O que é interessante é, se esta de classes núcleo, que caracterizam projetos Android (pois sem isso é apenas um projeto Java), será que estes maus cheiros tradicionais nos dão a informação necessária para refatorar e aumentar a manutenibilidade do código? Pois, se é da natureza da Activity ser assim, talvez as soluções propostas para refatorar estes maus cheiros não se apliquem ao Android. Logo, chegamos ao ponto que a natureza do Android pode implicar em maus cheiros específicos que tragam outras abordagens, que respeitem a natureza de projetos Android, para refatoração.

    Outra constatação interessante de Verlopp é que o mau cheiro tradicional long Parameter List é menos provável de aparecer em classes núcleo pela razão de, nessas classes, a maioria dos métodos serem sobrecargas de métodos, e estes não são afetados por este mau cheiro. Novamente voltamos ao ponto que maus cheiros tradicionais não foram pensados considerando a natureza de projetos Android.

    Ao final do seu trabalho, Verloop propõe 5 refatorações com o objetivo de mitigar o mau cheiro Long Method que se apresentou por diversos motivos em Activities e Adapters. Dentre estas 5 propostas de refatoração, ele implementou e testou 3 [explicar melhor estes resultados - chapter 6], sendo que:

    A primeira, uso do padrão ViewHolder em Adapter de fato melhora a qualidade do código, no exemplo de Verloop, dos 12 Adapter afetados pelo mau cheiro Long Method, após a refatoração apenas 4 continuaram apresentando o mau cheiro. Este padrão tras resultados não apenas em manutenibilidade com de perfomance e consumo de energia também [explicar], por todos estes benefícios, hoje [em qual versão do android?] já existe um componente no SDK Android com esta implementação de forma nativa.
    A segunda, uma espécie de ViewHolder para Activities, objetivava mitigar Long Methods, porém não trouxe bons resultados sendo que das 13 Activities refatoradas, nenhum deixou de ser afetada pelo Long Method.
    A terceira propõe mitigar Long Methods em Activities trocando atribuição de listener feitas com classes anônimas pelo uso do atributo OnClick no layout respectivo. Os resultados aqui obtidos não foram muito satisfatórios também pois, das 13 classes refatoradas, 7 ainda apresentaram o mau cheiro devido ao uso de outros listeners que não o de click, que não possuem atributos correspondentes. Além disso, já se sabe hoje que o uso de atributos não é interessante devido ao acoplamento resultante da Activity com aquele determiado XML dentre outros problemas [quais?]. Apesar disso, Verloop considerou os resultados bons.

    É interessante notar que dentro da definição de classes núcleo estão incluídas classes que heram de Services, dentre outras, porém as únicas classes que apresentaram maus cheiros foram Activities e Adapters. Como vimos em BACKGROUND ANDROID, essas classes são responsáveis por lidar com a UI e estes resultados de Verloop reforçam nossa hipótese que o front-end Android tende a ser mais problemático que o restante dos códigos da aplicação e por isso vale a pena ser estudado mais a fundo. 
  
  \subsection{Maus cheiros específicos Android}

    Gottschalk et al \cite{RemovingEnergySmells:12} conduziram um estudo sobre formas de detectar e refatorar cheiros de código relacionados ao uso eficiente de energia. Os autores compilaram um catálogo com 6 cheiros de código extraído de outros trabalhos, e trabalharam sob um trecho de código Android para exemplificar um deles, o \textit{Carregar Recurso Muito Cedo}, quando algum recurso é alocado muito antes de precisar ser utilizado. Essa pesquisa é relacionada à nossa por ambas considerarem a tecnologia Android e se diferenciam pois focamos na busca por maus cheiros de código relacionados manutenibilidade enquanto eles tratam de eficiência, conforme conceitos de qualidade de software apresentados da Seção 2.2.

    Reimann et al. \cite{ReimannBrylski2013} correlaciona os conceitos de mau cheiro, qualidade e refatoração a fim de introduzir o termo cheiro de qualidade (do inglês \textit{quality smell}). Um cheiro de qualidade é uma estrutura que influencia negativamente requisitos de qualidade específicos, que podem ser resolvidos por refatorações \cite{Reimann:2013:QRE:2588611.2588737}.

    Os autores compilaram um catálogo de 30 cheiros de qualidade para Android. O formato dos cheiros de qualidade incluem: nome, contexto, requisitos de qualidades afetados e descrição, este formato foi baseado nos catálogos de Brown et al. \cite{WilleyAntiPatterns} e Fowler \cite{RefactoringFowler1999}. Todo o catálogo pode ser encontrado em [http://www.modelrefactoring.org/smell\_catalog](http://www.modelrefactoring.org/smell\_catalog) e os mesmos também foram implementados no framework Refactory \cite{Reimann:2013:QRE:2588611.2588737}.

    O requisitos de qualidade tratados por \cite{ReimannBrylski2013} são: centrados no usuário (estabilidade, tempo de inicio, conformidade com usuário, experiência do usuário e acessibilidade), consumo inteligente de recursos de hardware do dispositivo (eficiência no uso de energia, processamento e memória) e segurança.

    Reimann et al. \cite{ReimannBrylski2013} cita que o problema no desenvolvimento móvel é que os desenvolvedores estão cientes de cheiros de qualidade apenas indiretamente porque suas definições são informais (melhores práticas, problemas de rastreamento de bugs, discussões de fórum etc.) e os recursos onde encontrá-los são distribuídos pela web e que é difícil coletar e analisar todas essas fontes sob um ponto de vista comum e fornecer suporte de ferramentas para desenvolvedores. 

    Derivou os 30 maus cheiros de boas e más práticas documentadas online na documentação do Android e de postagens em blogs de desenvolvedores que reportaram suas experiências. (segundo o paper de Geoffrey Hetch - abaixo)

  \subsection{Frequência de maus cheiros tradicionais vs. maus cheiros específicos em apps Android}

    Hetch [?] utilizou a ferratementa de detecção de maus cheiros Páprika [?] para identificar 8 maus cheiros, sendo 4 tradicionais (Blob class [9], Swiss Army Knife [9], Complex Class [12] e Long Method [12]) e 4 Android (Internal Getter/Setter, No Low Memory Resolver, Member Ignoring Method e Leaking Inner Class), definidos por [Reimann] em 15 aplicações Android populares como Facebook, Skype, Twitter. Isso foi possível pois a ferramenta Páprika se utiliza do APK para extrair os dados para análise. Um ponto importante é que apesar de Hetch utilizar do termo anti-patterns, ele se baseia em outros artigos que definiram os \textit{``antipatterns''} por ele analisado como maus cheiros. Logo, seguiremos com o termos mau cheiro, pois entendemos que apesar da divergência do termo, o autor se refere a ele. Vale considerar que, para se classificar como um antipattern o item deve atender as 2 (ou 3?) características mencionadas em [ref p/ livro de antipatterns] como abordamos na Seção X.X.X [sobre antipatterns] e não há evidências que de que os itens tratados por Hetch atendem as características mencionadas.

    Hetch afirma que os maus cheiros tradicionais são tão frequentes em apps Android como em não Android, com exceção ao Swiss Army Knife, mas não há evidências de ele ter executado o Páprika em busca dos mesmos maus cheiros em projetos não Android. Segundo o artigo, Activities tendem a ser mais sensíveis ao Blob Class, mau cheiro este muito similar a God Class e Large Class, também identificado como muito comum por Verloop [?], esta conclusão reforça nossa hipótese que códigos pertencentes ao front-end Android são mais propensos a apresentar trechos problemáticos, que, apesar de já existirem maus cheiros que os identificam, a refatoração proposta não é apropriada pois é da natureza de projetos Android apresentarem estes problemas, isso nos leva a pensar que essas situações em sí não são o problema de fato, e que talvez existam outras formas de definir e lidar com esses problemas no Android.

    Outra conclusão interessante é que o artigo diz que maus cheiros específicos Android são muito mais frequentes do que os maus cheiros tradicionais, o que reafirma a necessidade de pesquisar se há outros maus cheiros específicos, que tendem também a ser mais frequentes. 

    Minelli e Lanza apresentam diferenças no desenvolvimento de apps e softwares tradicionais em termos de métricas de código, uso de APIs terceiras e evolução. Para isso se utilizam da ferramenta SAMOA de análise estática de código desenvolvida por eles.

    É interessante que para análise do código Android eles também modelam o projeto em código core e não core, onde o código core está relacionado a classes que herdam do Android SDK, apesar disso, eles dizem coletar essa informação do Android Manifesto, considerando Activities e Services, entretanto, existem diversas outras classes em um projeto Android que herdam do Android SDK e não precisam ser declaradas no Android Manifesto, ou seja, a definição usada abrange muito mais código do que de fato analisado pela pesquisa.

    Concluem com um conjunto de características de apps e com um conjunto de hábitos dos desenvolvedores destes apps que diferem de aplicações de software tradicionais. Dentre as características, afirmam que algumas vezes core code do app é composto por uma, ou algumas, God Classes. E que herança é algo quase inexistente em apps Android. O que reforça nossa identificação de falta de arquitetura padrão, visto que esta exige um conhecimento mais aprimorado de orientação a objetos que inclui herança.

% \section{Android}
% geral android (opcional)
% Na prática, não acho que faz sentido pois não tenho muito comparar meu trabalho eu acho, mas deixa como opcional

% \section{Maus cheiros específicos ao Android}

%   \subsection{Removing Energy Code Smells with Reengineering Services}

%     Gottschalk et al \cite{RemovingEnergySmells:12} conduziram um estudo sobre formas de detectar e refatorar cheiros de código relacionados ao uso eficiente de energia. Os autores compilaram um catálogo com 6 cheiros de código extraído de outros trabalhos, e trabalharam sob um trecho de código Android para exemplificar um deles, o \textit{Carregar Recurso Muito Cedo}, quando algum recurso é alocado muito antes de precisar ser utilizado. Essa pesquisa é relacionada à nossa por ambas considerarem a tecnologia Android e se diferenciam pois focamos na busca por maus cheiros de código relacionados manutenibilidade enquanto eles tratam de eficiência, conforme conceitos de qualidade de software apresentados da Seção 2.2.

%   \subsection{A Tool-Supported Quality Smell Catalogue For Android Developers - Reimann et al.}

%     Reimann et al. \cite{ReimannBrylski2013} correlaciona os conceitos de mau cheiro, qualidade e refatoração a fim de introduzir o termo cheiro de qualidade (do inglês \textit{quality smell}). Um cheiro de qualidade é uma estrutura que influencia negativamente requisitos de qualidade específicos, que podem ser resolvidos por refatorações \cite{Reimann:2013:QRE:2588611.2588737}.

%     Os autores compilaram um catálogo de 30 cheiros de qualidade para Android. O formato dos cheiros de qualidade incluem: nome, contexto, requisitos de qualidades afetados e descrição, este formato foi baseado nos catálogos de Brown et al. \cite{WilleyAntiPatterns} e Fowler \cite{RefactoringFowler1999}. Todo o catálogo pode ser encontrado em [http://www.modelrefactoring.org/smell\_catalog](http://www.modelrefactoring.org/smell\_catalog) e os mesmos também foram implementados no framework Refactory \cite{Reimann:2013:QRE:2588611.2588737}.

%     O requisitos de qualidade tratados por \cite{ReimannBrylski2013} são: centrados no usuário (estabilidade, tempo de inicio, conformidade com usuário, experiência do usuário e acessibilidade), consumo inteligente de recursos de hardware do dispositivo (eficiência no uso de energia, processamento e memória) e segurança.

%     Reimann et al. \cite{ReimannBrylski2013} cita que o problema no desenvolvimento móvel é que os desenvolvedores estão cientes de cheiros de qualidade apenas indiretamente porque suas definições são informais (melhores práticas, problemas de rastreamento de bugs, discussões de fórum etc.) e os recursos onde encontrá-los são distribuídos pela web e que é difícil coletar e analisar todas essas fontes sob um ponto de vista comum e fornecer suporte de ferramentas para desenvolvedores. 

%     Derivou os 30 maus cheiros de boas e más práticas documentadas online na documentação do Android e de postagens em blogs de desenvolvedores que reportaram suas experiências. (segundo o paper de Geoffrey Hetch - abaixo)


% \section{Presença de maus cheiros em projetos Android}

%   \subsection{Code Smells in the Mobile Applications Domain - Verloop}
%     A tese de Verloop \cite{MobileSmells:13} consistiu em buscar maus cheiros de códigos tradicionais, sendo esses propostos por Fowler: Long Method, Large Class, Long Parameter List, Feature Envy e Dead Code, em projetos Android para determinar se esses maus cheiros ocorrem mais frequentemente em códigos relacionado ao Android. Para isso, ele fez uso de 4 ferramentas de detecção automática de maus cheiros: JDeodorant, Checkstyle, PMD and UCDetector.  

%     Basicamente o desenvolvimento Android é feito com código Java, considerando isso, uma pergunta óbvia seria: Por que buscar por maus cheiros específicos Android se já existem tantos definidos aplicáveis a código Java? Uma característica do Android é que, apesar de ser código Java, muitas classes em projetos Android precisam herdar de classes do SDK Android, por exemplo Activities, Fragments e Services.  Essa característica o torna diferente e portanto, sucetível a apresentar maus cheiros específicos. Verloop classifica todo código Java, em um projeto Android, que precisa herdar de classes do SDK Android como classes núcleo. Durante sua análise, ele compara a presença dos maus cheiros em classes núcleo e não núcleo, sendo esta última, classes puramente Java.

%     Verloop confirma que classes núcleos tendem a apresentar os maus cheiros God Class [conclui que dá na mesma mobile ou não, além de não se decidir de usar Large Class ou God Class], Long Method [afirma nos resultados], Switch Statement [nem comenta nos resultados, como assim mewww????] e Type Checking [afirma nos resultados] pela sua natureza (os demais não são mais propensos a aparecer em projetos Android), conforme explicamos na Seção (BACKGROUND SOBRE ACTIVITIES NO ANDROID - falar das muitas responsabilidades, etc). O que é interessante é, se esta de classes núcleo, que caracterizam projetos Android (pois sem isso é apenas um projeto Java), será que estes maus cheiros tradicionais nos dão a informação necessária para refatorar e aumentar a manutenibilidade do código? Pois, se é da natureza da Activity ser assim, talvez as soluções propostas para refatorar estes maus cheiros não se apliquem ao Android. Logo, chegamos ao ponto que a natureza do Android pode implicar em maus cheiros específicos que tragam outras abordagens, que respeitem a natureza de projetos Android, para refatoração.

%     Outra constatação interessante de Verlopp é que o mau cheiro tradicional long Parameter List é menos provável de aparecer em classes núcleo pela razão de, nessas classes, a maioria dos métodos serem sobrecargas de métodos, e estes não são afetados por este mau cheiro. Novamente voltamos ao ponto que maus cheiros tradicionais não foram pensados considerando a natureza de projetos Android.

%     Ao final do seu trabalho, Verloop propõe 5 refatorações com o objetivo de mitigar o mau cheiro Long Method que se apresentou por diversos motivos em Activities e Adapters. Dentre estas 5 propostas de refatoração, ele implementou e testou 3 [explicar melhor estes resultados - chapter 6], sendo que:

%     A primeira, uso do padrão ViewHolder em Adapter de fato melhora a qualidade do código, no exemplo de Verloop, dos 12 Adapter afetados pelo mau cheiro Long Method, após a refatoração apenas 4 continuaram apresentando o mau cheiro. Este padrão tras resultados não apenas em manutenibilidade com de perfomance e consumo de energia também [explicar], por todos estes benefícios, hoje [em qual versão do android?] já existe um componente no SDK Android com esta implementação de forma nativa.
%     A segunda, uma espécie de ViewHolder para Activities, objetivava mitigar Long Methods, porém não trouxe bons resultados sendo que das 13 Activities refatoradas, nenhum deixou de ser afetada pelo Long Method.
%     A terceira propõe mitigar Long Methods em Activities trocando atribuição de listener feitas com classes anônimas pelo uso do atributo OnClick no layout respectivo. Os resultados aqui obtidos não foram muito satisfatórios também pois, das 13 classes refatoradas, 7 ainda apresentaram o mau cheiro devido ao uso de outros listeners que não o de click, que não possuem atributos correspondentes. Além disso, já se sabe hoje que o uso de atributos não é interessante devido ao acoplamento resultante da Activity com aquele determiado XML dentre outros problemas [quais?]. Apesar disso, Verloop considerou os resultados bons.

%     É interessante notar que dentro da definição de classes núcleo estão incluídas classes que heram de Services, dentre outras, porém as únicas classes que apresentaram maus cheiros foram Activities e Adapters. Como vimos em BACKGROUND ANDROID, essas classes são responsáveis por lidar com a UI e estes resultados de Verloop reforçam nossa hipótese que o front-end Android tende a ser mais problemático que o restante dos códigos da aplicação e por isso vale a pena ser estudado mais a fundo. 
   
%   \subsection{An Approach to Detect Android Antipatterns - Geoffrey Hetch}
%     Hetch [?] utilizou a ferratementa de detecção de maus cheiros Páprika [?] para identificar 8 maus cheiros, sendo 4 tradicionais (Blob class [9], Swiss Army Knife [9], Complex Class [12] e Long Method [12]) e 4 Android (Internal Getter/Setter, No Low Memory Resolver, Member Ignoring Method e Leaking Inner Class), definidos por [Reimann] em 15 aplicações Android populares como Facebook, Skype, Twitter. Isso foi possível pois a ferramenta Páprika se utiliza do APK para extrair os dados para análise. Um ponto importante é que apesar de Hetch utilizar do termo anti-patterns, ele se baseia em outros artigos que definiram os \textit{``antipatterns''} por ele analisado como maus cheiros. Logo, seguiremos com o termos mau cheiro, pois entendemos que apesar da divergência do termo, o autor se refere a ele. Vale considerar que, para se classificar como um antipattern o item deve atender as 2 (ou 3?) características mencionadas em [ref p/ livro de antipatterns] como abordamos na Seção X.X.X [sobre antipatterns] e não há evidências que de que os itens tratados por Hetch atendem as características mencionadas.

%     Hetch afirma que os maus cheiros tradicionais são tão frequentes em apps Android como em não Android, com exceção ao Swiss Army Knife, mas não há evidências de ele ter executado o Páprika em busca dos mesmos maus cheiros em projetos não Android. Segundo o artigo, Activities tendem a ser mais sensíveis ao Blob Class, mau cheiro este muito similar a God Class e Large Class, também identificado como muito comum por Verloop [?], esta conclusão reforça nossa hipótese que códigos pertencentes ao front-end Android são mais propensos a apresentar trechos problemáticos, que, apesar de já existirem maus cheiros que os identificam, a refatoração proposta não é apropriada pois é da natureza de projetos Android apresentarem estes problemas, isso nos leva a pensar que essas situações em sí não são o problema de fato, e que talvez existam outras formas de definir e lidar com esses problemas no Android.

%     Outra conclusão interessante é que o artigo diz que maus cheiros específicos Android são muito mais frequentes do que os maus cheiros tradicionais, o que reafirma a necessidade de pesquisar se há outros maus cheiros específicos, que tendem também a ser mais frequentes.

  % \subsection{Detecting antipatterns in Android apps - Geoffrey Hetch}
  %   ???

  % \subsection{Domain Matters: Bringing Further Evidence of the Relationships among Anti-patterns, Application Domains, and Quality-Related Metrics in Java Mobile Apps - Linares-Vásquez et al.}

    % Linares-Vásquez et al. \cite{DomainMatters} usou a ferramenta DECOR para realizar a detecção de 18 diferentes \textit{anti-patterns} orientado a objetos em aplicativos móveis desenvolvidos com Java Mobile Edition (J2ME). Este estudo em larga escala mostra que a presença de antipatterns afeta negativamente as métricas de qualidade do software, em particular as métricas relacionadas à falha.


% \section{Apps Android vs. Software Tradicional}

%   \subsection{Software analytics for mobile applications, insights \& lessons learned - Minelli e Lanza}

%     Os autores apresentam diferenças no desenvolvimento de apps e softwares tradicionais em termos de métricas de código, uso de APIs terceiras e evolução. Para isso se utilizam da ferramenta SAMOA de análise estática de código desenvolvida por eles.

%     É interessante que para análise do código Android eles também modelam o projeto em código core e não core, onde o código core está relacionado a classes que herdam do Android SDK, apesar disso, eles dizem coletar essa informação do Android Manifesto, considerando Activities e Services, entretanto, existem diversas outras classes em um projeto Android que herdam do Android SDK e não precisam ser declaradas no Android Manifesto, ou seja, a definição usada abrange muito mais código do que de fato analisado pela pesquisa.

%     Concluem com um conjunto de características de apps e com um conjunto de hábitos dos desenvolvedores destes apps que diferem de aplicações de software tradicionais. Dentre as características, afirmam que algumas vezes core code do app é composto por uma, ou algumas, God Classes. E que herança é algo quase inexistente em apps Android. O que reforça nossa identificação de falta de arquitetura padrão, visto que esta exige um conhecimento mais aprimorado de orientação a objetos que inclui herança.




\begin{center}
. . .
\end{center}




Esta dissertação pretende pela primeira vez catalogar cheiros de código especificamente relacionados a camada de apresentação de aplicativos Android. Pretende-se reaproveitar diversos dos métodos utilizados para a detecção e documentação de cheiros de código dos diversos trabalhos acima citados.


Aplicativos Android são escritos na linguagem de programação Java \cite{AndroidFundamentals}. Então a primeira questão é: por que buscar por \textit{smells} Android sendo que já existem tantos \textit{smells} Java? Pesquisas têm demonstrado que tecnologias diferentes podem apresentar \textit{code smells} específicos, como por exemplo Aniche et al. identificaram 6 \textit{code smells} específicos ao framework Spring MVC, um framework Java para desenvolvimento web. Outras pesquisas concluem que projetos Android possuem características diferentes de projetos java \cite{Hecht:15, Mannan_Dig_Ahmed_Jensen_Abdullah_Almurshed, ReimannBrylski2013}, por exemplo, o \textit{front-end} é representado por arquivos XML e o ponto de entrada da aplicação é dado por \textit{event-handler} \cite{AndroidActivities2016} como o método \textsc{onCreate}. Encontramos também diversas pesquisas sobre \textit{code smells} sobre tecnologias usadas no desenvolvimento de \textit{front-end} web como CSS \cite{CSSCodeSmell} e JavaScript \cite{BB}. Essas pesquisas nos inspiraram a buscar entender se existem \textit{code smells} no \textit{front-end} Android. \\
% 
% Umme et al. \cite{Mannan_Dig_Ahmed_Jensen_Abdullah_Almurshed} recentemente levantaram que, das principais conferências de manutenção de software (ICSE, FSE, OOPSLA/SPLASH, ASE, ICSM/ICSME, MRS e ESEM), dentre 2008 a 2015, apenas 10\% dos artigos consideraram em suas pesquisas, projetos Android. Nenhuma outra plataforma móvel foi considerada.  
% \textbf{[seção não finalizada, á concluir.]}


% Boa frase, só falta refs e colocar no lugar certo
% A percepção desempenha um importante papel na definição de maus cheiros de código relacionados a uma tecnologia, visto que maus cheiros possuem uma natureza subjetiva. Maus cheiros desempenham um importante papel na busca por qualidade de código, visto que, após mapeados, podemos chegar a heurísticas para identificá-los e com essas heurísticas, implementar ferramentas que automatizem o processo de identificar códigos problemáticos.