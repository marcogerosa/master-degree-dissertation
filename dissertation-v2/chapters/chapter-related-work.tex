% -*- root: article.tex -*-
% \todo{Colocar sessão que fala sobre a importancia de maus cheiros, exemplo tirado dos slides da quali: Classes com antipatterns tendem a ter mais alterações e falhas. [Khomh et al., 2011]}

Aplicativos Android são desenvolvidos, em sua maioria, utilizando a linguagem de programação Java \cite{AndroidFundamentals}. Deste modo, um provável questionamento é: ``Por que investigar maus cheiros específicos ao Android quando já existem tantos maus cheiros e boas práticas documentadas para linguagens orientada a objetos como o Java?''. Para responder a esta pergunta temos as seguintes Seções:

\begin{itemize}
  \item A Seção \ref{android-vs-tradicional} apresenta pesquisas que investigaram e encontraram importantes características que diferenciam projetos Android de projetos de software tradicionais, como projetos web e cliente/servidor. Estas características agregam complexidades ao desenvolvimento Android não encontradas no desenvolvimento de software tradicionais. 

  \item A Seção \ref{maus-cheiros-especificos} apresenta pesquisas que têm demonstrado que diferentes tecnologias podem apresentar maus cheiros específicos. Inclusive que o \textit{front-end} de softwares tradicionais apresentam maus cheiros específicos, e reforça nossa hipótese de que o desenvolvimento do \textit{front-end} Android pode seguir por este mesmo comportamento.

  \item A Seção \ref{maus-cheiros-android} apresenta pesquisas que já vem investigando (i) a presença de maus cheiros tradicionais em aplicativos Android, (ii) a existência de maus cheiro específicos ao Android e também (iii) comparando a presença dos maus cheiros tradicionais vs. a presença de maus cheiros específicos em aplicativos Android. Estas pesquisas reforçam a relevância de investigarmos maus cheiros específicos ao Android pois concluem que maus cheiros específicos aparecem muito mais do que os maus cheiros tradicionais.
\end{itemize}

Ao final desta seção pretende-se esclarecer os motivos pelo qual optamos por investigar maus cheiros de código relacionados ao \textit{front-end} Android e também dar uma visão sólida do estado da arte sobre o assunto.

% Muitas pesquisas têm sido realizadas sobre a plataforma Android, muitas delas focam em vulnerabilidades \cite{Y, F, G, X, P, D, E}, autenticação \cite{T, Yamashita6405287, R} e testes \cite{J, M}. Diferentemente dessas pesquisas, nossa pesquisa tem foco na percepção dos desenvolvedores sobre boas e más práticas de desenvolvimento na plataforma Android. 

\section{Projetos Android vs. projetos de software tradicionais}
\label{android-vs-tradicional}

Em construção.

\section{Maus cheiros específicos a uma tecnologia}
\label{maus-cheiros-especificos}

  A constante e rápida evolução de tecnologias existentes e criação de novas tecnologias faz com que diversos temas, como manutenibilidade de software, estejam também em constante alta. Muitos pesquisadores veem pesquisando sobre a existência de maus cheiros de código específicos a uma dada tecnologia como por exemplo arcabouços Java \cite{MvcSmells:16, ORMSmells}, a linguagem CSS (\textit{Cascading Style Sheets}) \cite{CSSCodeSmell} e fórmulas em planilhas \cite{SpreadsheetsSmells:12}.

  Chen et al. \cite{ORMSmells} viu a necessidade de estudar maus cheiros de código em arcabouços Object-Relational Mapping (ORM) pelo grande uso pela indústria e pela desatenção de desenvolvedores com relação ao impacto dos seus códigos no desempenho do banco de dados que podiam causar \textit{timeouts} e paradas dos sistemas. Os autores implementaram um arcabouço automatizado e sistemático para detectar e priorizar anti-padrões de desempenho em aplicações desenvolvidas usando ORM e também mapearam dois anti-padrões específicos a arcabouços ORM.

  Aniche et al. \cite{MvcSmells:16} investigaram maus cheiros de código relacionado ao arcabouço Spring MVC, usado para o desenvolvimento do \textit{front-end} de aplicações web Java. Aniche et al. encontram maus cheiros específicos a cada camada do arcabouço Spring MVC, modelo, visualização e controladora, afirmando que cada papel arquitetural possui responsabilidades diferentes o que resulta em distribuições diferentes de valores de métrica de código e maus cheiros diferentes. Dentre as principais contribuições deste trabalho está um catálogo com seis maus cheiros específicos ao arcabouço Spring MVC mapeados e validados.

  Gharachorlu \cite{CSSCodeSmell} investigou maus cheiros em código CSS, linguagem amplamente utilizada no \textit{front-end} de aplicações web para separar a semântica de apresentação do conteúdo HTML. De acordo com o autor, apesar da simplicidade de sintaxe do CSS, as características específicas da linguagem tornam a criação e manutenção de CSS uma tarefa desafiadora. Foi realizando um estudo empírico de larga escala onde os resultados indicaram que o CSS de hoje sofre significativamente de padrões inadequados e está longe de ser um código bem escrito. Gharachorlu propõe o primeiro modelo de qualidade de código CSS derivado de uma grande amostra de aprendizagem de modo a ajudar desenvolvedores a obter uma estimativa do número total de cheiros de código em seu código CSS. Sua principal contribuição foram oito novos maus cheiros CSS detectados com o uso da ferramenta CSSNose, também implementada e disponibilizada pelo autor.

  Fard e Ali \cite{JavascriptSmells} investigaram maus cheiros de código no Javascript, que é uma flexível linguagem de \textit{script} para o desenvolvimento do comportamento do \textit{front-end} de aplicações web. Os autores afirmam que devido à essa flexibilidade, o JavaScript é uma linguagem particularmente desafiadora para escrever e manter código. Alguns dos desafios citados são a questão de, diferentemente de aplicações Android que são compiladas, o Javascript é interpretado, o que significa que normalmente não há compilador no ciclo de desenvolvimento que ajudaria os desenvolvedores a detectar código incorreto ou não otimizado no momento da compilação. Outro ponto que o autor indica como problema é a natureza dinâmica, fracamente tipificada e assíncrona, além de outros desafios citados. Os autores propõem um conjunto de 13 maus cheiros de código JavaScript, sendo 7 maus cheiros tradicionais adaptados para o JavaScript e 6 maus cheiros específicos ao JavaScript derivado da pesquisa. Também é apresentada uma técnica automatizada, chamada JSNOSE, para detectar esses maus cheiros.

  % \todo{adicionar parágrafo sobre smells em planilhas, achar ref}

  Um interessante relação que vemos é que muitas pesquisas buscaram por maus cheiros específicos em tecnologias usadas no \textit{front-end} de aplicações web \cite{JavascriptSmells, CSSCodeSmell, MvcSmells:16} o que reforça nossa hipótese de que aplicativos Android podem seguir o mesmo comportamento possivelmente apresentando maus cheiros específicos ao \textit{front-end} não encontrados necessariamente nos demais códigos da aplicação.

\section{Maus cheiros em aplicativos Android}
\label{maus-cheiros-android}

  % como vimos na Seção anterior X.X.X, que inclusive nos mostrou que é possível identificar maus cheiros no \textit{front-end} de aplicações de software tradicionais e que estes, por sua vez, são diferentes dos maus cheiros encontrados no \textit{back-end}. Outras pesquisas concluem que projetos Android possuem características diferentes de projetos java \cite{Hecht:15, Mannan_Dig_Ahmed_Jensen_Abdullah_Almurshed, 30QualitySmells:14}, como vimos na Seção X.X.X. 

  % por exemplo, o \textit{front-end} é representado por arquivos XML e o ponto de entrada da aplicação é dado por \textit{event-handler} \cite{AndroidActivities2016} como o método \textsc{onCreate}. Encontramos também diversas pesquisas sobre \textit{code smells} sobre tecnologias usadas no desenvolvimento de \textit{front-end} web como CSS \cite{CSSCodeSmell} e JavaScript \cite{BB}. Essas pesquisas nos inspiraram a buscar entender se existem \textit{code smells} no \textit{front-end} Android. \\

  Pesquisas em torno de maus cheiros em aplicativos Android ainda são poucas. Umme et al. \cite{Mannan_Dig_Ahmed_Jensen_Abdullah_Almurshed} recentemente levantaram que, das principais conferências de manutenção de software, dentre 2008 a 2015, apenas 10\% dos artigos consideraram em suas pesquisas, projetos Android e nenhuma outra plataforma móvel foi considerada. As conferências consideradas foram as ICSE, FSE, OOPSLA/SPLASH, ASE, ICSM/ICSME, MRS e ESEM. 

  Dentre as pesquisas analisadas para efeitos deste trabalho, podemos classificar em 3 grupos: 1) aquelas que buscam por maus cheiros tradicionais em aplicativos Android, 2) as que buscam por maus cheiros específicos a aplicativos Android, grupo ao qual nossa pesquisa está inserida, 3) e as que buscam ambos os maus cheiros, específicos e tradicionais, em aplicativos Android e comparam qual deles é mais frequente. 

  As Seções seguintes tratam do estado da arte de cada um desses grupos bem como suas semelhanças e diferenças com nossa pesquisa.

  \subsection{Presença de maus cheiros tradicionais em aplicativos Android}
    Linares-Vásquez et al. \cite{DomainMatters} usaram a ferramenta DECOR para realizar a detecção de 18 diferentes anti-padrões orientado a objetos em aplicativos móveis desenvolvidos com Java Mobile Edition (J2ME) e entender a relação dos maus cheiros com o domínio de negócio e métricas de qualidade. Dentre as principais conclusões do estudo está a conclusão de que existe uma grande diferença nos valores das métricas de qualidade em aplicativos afetados pelos maus cheiros e pelos que não e que enquanto há maus cheiros presentes em todos os domínios, alguns são mais presentes em domínios específicos. %[\todo{quais as semelhanças e diferenças??? reler trabalho e comparar com o meu}]

    Verloop \cite{MobileSmells:13} investigou a presença de maus cheiros de códigos tradicionais propostos por Fowler \cite{Refactoring:99} (\textit{Long Method}, \textit{Large Class}, \textit{Long Parameter List}, \textit{Feature Envy} e \textit{Dead Code}) em aplicativos Android para determinar se esses maus cheiros ocorrem mais frequentemente em \emph{classes núcleo}, classes no projeto Android que precisam herdar de classes do SDK Android, como por exemplo \texttt{Activities}, \texttt{Fragments} e \texttt{Services}, comparando com classes não núcleo. Para isso, ele fez uso de 4 ferramentas de detecção automática de maus cheiros: JDeodorant, Checkstyle, PMD e UCDetector.  

    % O desenvolvimento Android é basicamente através da linguagem Java, considerando isso, uma pergunta óbvia seria: Por que buscar por maus cheiros específicos Android se já existem tantos definidos aplicáveis a código Java? Uma característica do Android é que, apesar de ser código Java, muitas classes em projetos Android precisam herdar de classes do SDK Android, por exemplo Activities, Fragments e Services.  Essa característica o torna diferente e portanto, sucetível a apresentar maus cheiros específicos. Verloop classifica todo código Java, em um projeto Android, que precisa herdar de classes do SDK Android como classes núcleo. Durante sua análise, ele compara a presença dos maus cheiros em classes núcleo e não núcleo, sendo esta última, classes puramente Java.

    % \todo{falar das muitas responsabilidades de activities no background de android}.%
    O autor afirma que classes núcleos tendem a apresentar os maus cheiros \textit{God Class}, \textit{Long Method}, \textit{Switch Statement} e \textit{Type Checking} pela sua natureza de muitas responsabilidades, sendo que a classe mais observada com estes maus cheiros foram \texttt{Activities}. Um ponto a se pensar é, se a natureza da Activity é de ter muitas responsabilidades, talvez estejamos analisando-a a partir de um ponto de vista inadequado ao buscarmos por \textit{God Class} ou \textit{Long Method}, visto que sabe-se agora de que estes maus cheiros de fato a afetam, mas que de certa forma, esse é o \textit{modus operandi} normal dela. Chegamos ao ponto que a natureza do Android pode implicar em maus cheiros específicos que tragam outros ponto de vista que respeitem a natureza de aplicativos Android, e proponham uma refatoração adequada.

    % O que é interessante é, se esta de classes núcleo, que caracterizam projetos Android (pois sem isso é apenas um projeto Java), será que estes maus cheiros tradicionais nos dão a informação necessária para refatorar e aumentar a manutenibilidade do código? Pois, se é da natureza da Activity ser assim, talvez as soluções propostas para refatorar estes maus cheiros não se apliquem ao Android. Logo, chegamos ao ponto que a natureza do Android pode implicar em maus cheiros específicos que tragam outras abordagens, que respeitem a natureza de projetos Android, para refatoração.

    O autor também conclui que o mau cheiro tradicional \textit{Long Parameter List} é menos provável de aparecer em classes núcleo pois nessas classes, a maioria dos métodos são sobrecargas de métodos da classe herdada proveniente do SDK Android, e como para se realizar uma sobrecarga de método é necessário seguir a assinatura do método original, este normalmente não é afetado por este mau cheiro. Novamente voltamos ao ponto que maus cheiros tradicionais não foram pensados considerando a natureza de projetos Android, que neste caso está relacionada a herança de classes núcleo.

    Verloop \cite{MobileSmells:13} conclui propondo 5 refatorações com o objetivo de mitigar o mau cheiro \textit{Long Method} que se apresentou por diversos motivos em \texttt{Activities} e \texttt{Adapters}. Dentre estas 5 propostas de refatoração, ele implementou e experimentou 3 [explicar melhor estes resultados - chapter 6], sendo que:

    \begin{itemize}

      \item A primeira, uso do padrão \texttt{ViewHolder} em \texttt{Adapter} de fato melhora a qualidade do código, no exemplo do autor, dos 12 \texttt{Adapter} afetados pelo mau cheiro Long Method, após a refatoração apenas 4 continuaram apresentando o mau cheiro. Este padrão trás resultados não apenas em manutenibilidade com de desempenho e consumo de energia [explicar], por todos estes benefícios, hoje [em qual versão do Android?] já existe um componente no SDK Android com esta implementação de forma nativa.
    
      \item A segunda, uma espécie de ViewHolder para \texttt{Activities}, objetivava mitigar Long Method, porém não trouxe bons resultados sendo que das 13 \texttt{Activities} refatoradas, nenhum deixou de ser afetada pelo Long Method. Dessa forma, o autor conclui que outros não trabalhados por meio da refatoração proposta influenciam na aparição deste mau cheiro em \texttt{Activities}. Estes outros fatores estão relacionados a \textit{listeners} e classes anônimas usados para a implementação de comportamento dos elementos do \textit{front-end} pois estes códigos são comumente colocados no método \texttt{onCreate} de Activities.
    
      \item A terceira propõe mitigar o mau cheiro Long Method em Activities trocando a atribuição de \textit{listeners} feitas com classes anônimas pelo uso do atributo \texttt{OnClick} no XML de layout respectivo. Os resultados aqui obtidos também não foram muito satisfatórios pois, das 13 classes refatoradas, 7 ainda apresentaram o mau cheiro devido ao uso de outros \textit{listeners} que não o de \textit{click}, que não possuem atributos correspondentes no XML de layout. Além disso, já se sabe hoje que o uso de atributos não é interessante devido ao acoplamento resultante da \texttt{Activity} com aquele determinado XML dentre outros problemas. Apesar disso, o autor considerou este resultado como positivo. %\todo{explicar e trazer ref}

    \end{itemize}

    É interessante notar que dentro da definição de Verloop \cite{MobileSmells:13} de classes núcleo, estão incluídas classes que herdam de \texttt{Services} e todas as demais que herdam de alguma classe do SDK Android, porém as únicas classes que apresentaram maus cheiros foram \texttt{Activities} e \texttt{Adapters}. Como vimos em BACKGROUND ANDROID, essas classes são responsáveis por lidar com o \textit{front-end} Android, o que reforça nossa hipótese de que o \textit{front-end} Android tende a ser mais problemático que o restante dos códigos da aplicação e por isso vale a pena ser estudado mais a fundo. 
  
  \subsection{Maus cheiros específicos Android}

    % \todo{explicar mais, com exemplos, do que se tratam os maus cheiros encontrados nesses trabalhos e por que os meus são diferentes}

    % \todo{quais?}
    Gottschalk et al \cite{RemovingEnergySmells:12} conduziram um estudo sobre formas de detectar e refatorar maus cheiros de código relacionados ao uso eficiente de energia. Os autores compilaram um catálogo com 6 cheiros de código extraídos de outros trabalhos, e trabalharam sob um trecho de código Android para exemplificar um deles, o \textit{Carregar Recurso Muito Cedo}, quando algum recurso é alocado muito antes de precisar ser utilizado. Essa pesquisa é relacionada à nossa por ambas considerarem a tecnologia Android e se diferenciam pois focamos na busca por maus cheiros de código relacionados manutenibilidade enquanto eles tratam de eficiência, conforme conceitos de qualidade de software apresentados da Seção 2.2.

    Reimann et al. \cite{30QualitySmells:14} correlaciona os conceitos de mau cheiro, qualidade e refatoração a fim de introduzir o termo mau cheiro de qualidade (do inglês \textit{quality smell}). Segundo os autores, um mau cheiro de qualidade é uma estrutura que influencia negativamente requisitos de qualidade específicos, que podem ser resolvidos por refatorações \cite{Reimann}.

    Os autores compilaram um catálogo de 30 cheiros de qualidade para Android. O formato dos cheiros de qualidade incluem: nome, contexto, requisitos de qualidades afetados e descrição, este formato foi baseado nos catálogos de Brown et al. \cite{AntiPatterns:98} e Fowler \cite{Refactoring:99}. Todo o catálogo pode ser encontrado online\footnote{http://www.modelrefactoring.org/smell\_catalog} e os mesmos também foram implementados no arcabouço Refactory \cite{Reimann}.

    Os requisitos de qualidade tratados por Reimann et al \cite{30QualitySmells:14} são: centrados no usuário (estabilidade, tempo de inicio, conformidade com usuário, experiência do usuário e acessibilidade), consumo inteligente de recursos de hardware do dispositivo (eficiência no uso de energia, processamento e memória) e segurança.

    Reimann et al. \cite{30QualitySmells:14} cita que o problema no desenvolvimento móvel é que os desenvolvedores estão cientes de cheiros de qualidade apenas indiretamente porque suas definições são informais (melhores práticas, problemas de rastreamento de bugs, discussões de fórum etc.) e os recursos onde encontrá-los são distribuídos pela web e que é difícil coletar e analisar todas essas fontes sob um ponto de vista comum e fornecer suporte de ferramentas para desenvolvedores. 

    Derivou os 30 maus cheiros de boas e más práticas documentadas online na documentação do Android e de postagens em blogs de desenvolvedores que reportaram suas experiências. (segundo o paper de Geoffrey Hetch - abaixo)

  \subsection{Presença de maus cheiros tradicionais vs. maus cheiros específicos em aplicativos Android}

    Hetch \cite{HetchDetectingAntipatternsAndroidApps:15} utilizou a ferramenta de detecção de maus cheiros Páprika\footnote{https://github.com/geoffreyhecht/paprika} para identificar 8 maus cheiros, sendo 4 tradicionais (\textit{Blob Class} \cite{AntiPatterns:98}, \textit{Swiss Army Knife} \cite{AntiPatterns:98}, \textit{Complex Class} \cite{Refactoring:99} e \textit{Long Method} \cite{Refactoring:99}) e 4 Android (\textit{Internal Getter/Setter} \cite{30QualitySmells:14}, \textit{No Low Memory Resolver} \cite{30QualitySmells:14}, \textit{Member Ignoring Method} \cite{30QualitySmells:14} e \textit{Leaking Inner Class} \cite{30QualitySmells:14}), em 15 aplicações Android populares como Facebook, Skype, Twitter. Isso foi possível pois a ferramenta Páprika se utiliza do APK para extrair os dados para análise e mesmo essas aplicações não sendo de código aberto, o Páprika consegue extrair os dados a partir do instalável. Um ponto importante é que apesar do autor utilizar do termo anti-padrão, ele se baseia em outras pesquisas que definiram os ``anti-padrões'' por ele analisado como maus cheiros de código. Logo, seguiremos com o termo mau cheiro daqui em diante, pois entendemos que apesar da diferença, o autor se refere a ele. Vale considerar que, para se classificar como um antipattern o item deve atender as 2 características mencionadas em \cite{AntiPatterns:98} como abordamos na Seção X.X.X e não há evidências que de que os itens tratados por Hetch atendem as características mencionadas.

    Hetch \cite{HetchDetectingAntipatternsAndroidApps:15} afirma que os maus cheiros tradicionais são tão frequentes em aplicativos Android como em não Android, com exceção ao \textit{Swiss Army Knife}. Essa afirmação nos leva a entender que ele teria comparado a presença dos maus cheiros tradicionais em software tradicionais com os mesmos maus cheiros em aplicativos Android, entretanto, não há informações de como ele chegou a informação da presença de maus cheiros em projetos de software tradicionais para compará-las com o resultado obtido em aplicativos Android. 

    Segundo o autor, \texttt{Activities} tendem a ser mais sensíveis ao \textit{Blob Class} \cite{AntiPatterns:98} (muito similar a \textit{God Class} \cite{Riel:96} e \textit{Large Class} \cite{Refactoring:99}) que reforça a conclusão de Verloop \cite{MobileSmells:13}. Esta conclusão reforça nossa hipótese que códigos pertencentes ao \textit{front-end} Android são mais propensos a apresentar trechos problemáticos, que, apesar de já existirem maus cheiros que os identificam, a refatoração proposta não é apropriada pois é da natureza de projetos Android apresentarem estes problemas, isso nos leva a pensar que essas situações em si não são o problema de fato, e que talvez existam outras formas de definir e lidar com esses problemas no Android. 

    Ainda segundo o autor, maus cheiros específicos Android são muito mais frequentes do que os maus cheiros tradicionais. Esta constatação reforça a importância de se investigar quais seriam outros possíveis maus cheiros específicos de forma que, eles tendem a se manifestar mais do que os maus cheiros tradicionais.

    Minelli e Lanza \cite{Mantyla2013} apresentam diferenças no desenvolvimento de aplicativos e softwares tradicionais em termos de métricas de código, uso de APIs terceiras e evolução. Para isso se utilizam da ferramenta SAMOA desenvolvida por eles de análise estática de código.

    É interessante que para análise do código Android eles modelam o projeto em código core e não core, similar ao realizado por \cite{MobileSmells:13}, onde o código core está relacionado a classes que herdam do Android SDK. Apesar disso, eles dizem coletar essa informação do Android Manifesto, considerando \textit{Activities} e \textit{Services}, entretanto, existem diversas outras classes em um projeto Android que herdam do Android SDK e não precisam ser declaradas no Android Manifesto, ou seja, a definição usada abrange muito mais código do que de fato analisado pela pesquisa.

    Os autores concluem com um conjunto de características de aplicativos Android e com um conjunto de hábitos dos desenvolvedores destes aplicativos que diferem de aplicações de software tradicionais. Dentre as características, afirmam que algumas vezes o código núcleo do app é composto por uma, ou algumas, \textit{God Classes} e que herança, para o uso de \textit{design} das classes, é algo quase inexistente em aplicativos Android. Estas constatações reforçam um mau cheiro por nós identificado sobre a falta de arquitetura padrão, visto que esta exige um conhecimento mais aprimorado de orientação a objetos.

% \section{Android}
% geral android (opcional)
% Na prática, não acho que faz sentido pois não tenho muito comparar meu trabalho eu acho, mas deixa como opcional

% \section{Maus cheiros específicos ao Android}

%   \subsection{Removing Energy Code Smells with Reengineering Services}

%     Gottschalk et al \cite{RemovingEnergySmells:12} conduziram um estudo sobre formas de detectar e refatorar cheiros de código relacionados ao uso eficiente de energia. Os autores compilaram um catálogo com 6 cheiros de código extraído de outros trabalhos, e trabalharam sob um trecho de código Android para exemplificar um deles, o \textit{Carregar Recurso Muito Cedo}, quando algum recurso é alocado muito antes de precisar ser utilizado. Essa pesquisa é relacionada à nossa por ambas considerarem a tecnologia Android e se diferenciam pois focamos na busca por maus cheiros de código relacionados manutenibilidade enquanto eles tratam de eficiência, conforme conceitos de qualidade de software apresentados da Seção 2.2.

%   \subsection{A Tool-Supported Quality Smell Catalogue For Android Developers - Reimann et al.}

%     Reimann et al. \cite{30QualitySmells:14} correlaciona os conceitos de mau cheiro, qualidade e refatoração a fim de introduzir o termo cheiro de qualidade (do inglês \textit{quality smell}). Um cheiro de qualidade é uma estrutura que influencia negativamente requisitos de qualidade específicos, que podem ser resolvidos por refatorações \cite{Reimann}.

%     Os autores compilaram um catálogo de 30 cheiros de qualidade para Android. O formato dos cheiros de qualidade incluem: nome, contexto, requisitos de qualidades afetados e descrição, este formato foi baseado nos catálogos de Brown et al. \cite{AntiPatterns:98} e Fowler \cite{Refactoring:99}. Todo o catálogo pode ser encontrado em [http://www.modelrefactoring.org/smell\_catalog](http://www.modelrefactoring.org/smell\_catalog) e os mesmos também foram implementados no framework Refactory \cite{Reimann}.

%     O requisitos de qualidade tratados por \cite{30QualitySmells:14} são: centrados no usuário (estabilidade, tempo de inicio, conformidade com usuário, experiência do usuário e acessibilidade), consumo inteligente de recursos de hardware do dispositivo (eficiência no uso de energia, processamento e memória) e segurança.

%     Reimann et al. \cite{30QualitySmells:14} cita que o problema no desenvolvimento móvel é que os desenvolvedores estão cientes de cheiros de qualidade apenas indiretamente porque suas definições são informais (melhores práticas, problemas de rastreamento de bugs, discussões de fórum etc.) e os recursos onde encontrá-los são distribuídos pela web e que é difícil coletar e analisar todas essas fontes sob um ponto de vista comum e fornecer suporte de ferramentas para desenvolvedores. 

%     Derivou os 30 maus cheiros de boas e más práticas documentadas online na documentação do Android e de postagens em blogs de desenvolvedores que reportaram suas experiências. (segundo o paper de Geoffrey Hetch - abaixo)


% \section{Presença de maus cheiros em projetos Android}

%   \subsection{Code Smells in the Mobile Applications Domain - Verloop}Long Method em Activities trocando atribuição de listener feitas com classes anônimas pelo uso do atributo OnClick no layout respectivo. Os resultados aqui obtidos não foram muito satisfatórios também pois, das 13 classes refatoradas, 7 ainda apresentaram o mau cheiro devido ao uso de outros listeners que não o de click, que não possuem atributos correspondentes. Além disso, já se sabe hoje que o uso de atributos não é interessante devido ao acoplamento resultante da Activity com aquele determiado XML dentre outros problemas [quais?]. Apesar disso, Verloop considerou os resultados bons.

%     É interessante notar que dentro da definição de classes núcleo estão incluídas classes que heram de Services, dentre outras, porém as únicas classes que apresentaram maus cheiros foram Activities e Adapters. Como vimos em BACKGROUND ANDROID, essas classes são responsáveis por lidar com a UI e estes resultados de Verloop reforçam nossa hipótese que o front-end Android tende a ser mais problemático que o restante dos códigos da aplicação e por isso vale a pena ser estudado mais a fundo. 
   
%   \subsection{An Approach to Detect Android Antipatterns - Geoffrey HetcLongo [12]) e 4 Android (Internal Getter/Setter, No Low Memory Resolver, Member Ignoring Method e Leaking Inner Class), definidos por [Reimann] em 15 aplicações Android populares como Facebook, Skype, Twitter. Isso foi possível pois a ferramenta Páprika se utiliza do APK para extrair os dados para análise. Um ponto importante é que apesar de Hetch utilizar do termo anti-patterns, ele se baseia em outros artigos que definiram os \textit{``antipatterns''} por ele analisado como maus cheiros. Logo, seguiremos com o termos mau cheiro, pois entendemos que apesar da divergência do termo, o autor se refere a ele. Vale considerar que, para se classificar como um antipattern o item deve atender as 2 (ou 3?) características mencionadas em [ref p/ livro de antipatterns] como abordamos na Seção X.X.X [sobre antipatterns] e não há evidências que de que os itens tratados por Hetch atendem as características mencionadas.

%     Hetch afirma que os maus cheiros tradicionais são tão frequentes em aplicativos Android como em não Android, com exceção ao Swiss Army Knife, mas não há evidências de ele ter executado o Páprika em busca dos mesmos maus cheiros em projetos não Android. Segundo o artigo, Activities tendem a ser mais sensíveis ao Blob Class, mau cheiro este muito similar a God Class e Large Class, também identificado como muito comum por Verloop [?], esta conclusão reforça nossa hipótese que códigos pertencentes ao front-end Android são mais propensos a apresentar trechos problemáticos, que, apesar de já existirem maus cheiros que os identificam, a refatoração proposta não é apropriada pois é da natureza de projetos Android apresentarem estes problemas, isso nos leva a pensar que essas situações em sí não são o problema de fato, e que talvez existam outras formas de definir e lidar com esses problemas no Android.

%     Outra conclusão interessante é que o artigo diz que maus cheiros específicos Android são muito mais frequentes do que os maus cheiros tradicionais, o que reafirma a necessidade de pesquisar se há outros maus cheiros específicos, que tendem também a ser mais frequentes.

  % \subsection{Detecting antipatterns in Android aplicativos - Geoffrey Hetch}
  %   ???

  % \subsection{Domain Matters: Bringing Further Evidence of the Relatonships among Anti-patterns, Application Domains, and Quality-Related Metrics in Java Mobile aplicativos - Linares-Vásquez et al.}

    % Linares-Vásquez et al. \cite{DomainMatters} usou a ferramenta DECOR para realizar a detecção de 18 diferentes \textit{anti-patterns} orientado a objetos em aplicativos móveis desenvolvidos com Java Mobile Edition (J2ME). Este estudo em larga escala mostra que a presença de antipatterns afeta negativamente as métricas de qualidade do software, em particular as métricas relacionadas à falha.


% \section{aplicativos Android vs. Software Tradicional}

%   \subsection{Software analytics for mobile applications, insights \& lessons learned - Minelli e Lanza}

%     Os autores apresentam diferenças no desenvolvimento de aplicativos e softwares tradicionais em termos de métricas de código, uso de APIs terceiras e evolução. Para isso se utilizam da ferramenta SAMOA de análise estática de código desenvolvida por eles.

%     É interessante que para análise do código Android eles também modelam o projeto em código core e não core, onde o código core está relacionado a classes que herdam do Android SDK, apesar disso, eles dizem coletar essa informação do Android Manifesto, considerando Activities e Services, entretanto, existem diversas outras classes em um projeto Android que herdam do Android SDK e não precisam ser declaradas no Android Manifesto, ou seja, a definição usada abrange muito mais código do que de fato analisado pela pesquisa.

%     Concluem com um conjunto de características de aplicativos e com um conjunto de hábitos dos desenvolvedores destes aplicativos que diferem de aplicações de software tradicionais. Dentre as características, afirmam que algumas vezes core code do app é composto por uma, ou algumas, God Classes. E que herança é algo quase inexistente em aplicativos Android. O que reforça nossa identificação de falta de arquitetura padrão, visto que esta exige um conhecimento mais aprimorado de orientação a objetos que inclui herança.

Podemos notar algumas semelhanças nos trabalhos acima citados. A primeira semelhança importante é que diversas pesquisas que analisam a presença de maus cheiros, sejam tradicionais ou específicos Android, sentem a necessidade de delimitar o código em análise como pôde ser visto nos trabalhos \cite{MobileSmells:13, Mantyla2013} através do termo \emph{classes núcleos} (ou \emph{código núcleo}), em ambas as pesquisas significando \emph{classes que herdam do SDK Android}, o que consequentemente exclui todo o código puramente Java existente no projeto Android, o que faz sentido pois, no código Java puro continua sendo possível se utilizar das diversas boas práticas já existentes na literatura. 

Ainda com relação a delimitação do código em estudo, outra semelhança interessante é que, apesar de a definição de classes núcleo incluir classes como \texttt{Services}, \texttt{AsyncTasks} dentre muitas outras existentes no SDK Android, as classes que apareceram nos resultados se limitaram a \texttt{Activities} e \texttt{Adapters}, ambas classes utilizadas para a construção e resposta a eventos do \textit{front-end} Android. 

Essas semelhanças reforçaram nossa curiosidade em focar nossa pesquisa no código relacionado ao \textit{front-end} Android, partindo da hipótese de que existem maus cheiros específicos a ele. De forma que esta dissertação pretende pela primeira vez catalogar maus cheiros de código relacionados a manutenibilidade, especificamente relacionados a camada de apresentação de aplicativos do Android.


% Boa frase, só falta refs e colocar no lugar certo, talvez um bom local seja na descrição do método de pesquisa
% A percepção desempenha um importante papel na definição de maus cheiros de código relacionados a uma tecnologia, visto que maus cheiros possuem uma natureza subjetiva. Maus cheiros desempenham um importante papel na busca por qualidade de código, visto que, após mapeados, podemos chegar a heurísticas para identificá-los e com essas heurísticas, implementar ferramentas que automatizem o processo de identificar códigos problemáticos.