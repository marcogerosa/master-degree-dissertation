% -*- root: article.tex -*-
Muitas pesquisas têm sido realizadas sobre a plataforma Android, muitas delas focam em vulnerabilidades \cite{Y, F, G, X, P, D, E}, autenticação \cite{T, Yamashita6405287, R} e testes \cite{J, M}. Diferentemente dessas pesquisas, nossa pesquisa tem foco na percepção dos desenvolvedores sobre boas e más práticas de desenvolvimento na plataforma Android. 

\section{Pesquisas sobre o \textit{front-end} Android}
% front-end android. Quais os problemas com o front android e pq focar os estudos nele?


\section{Maus cheiros específicos a uma tecnologia}
% cheiros de código específicos 

Diversos pesquisadores propuseram cheiros de código e práticas recomendadas para tecnologias ou plataformas específicas, como frameworks Java [21, A], linguagem Cascading Style Sheets (CSS) [72] e fórmulas em planilhas [54].

Chen et al. [21] afirma que frameworks Object-Relational Mapping (ORM) são amplamente utilizado na indústria. No entanto, os desenvolvedores geralmente escrevem código ORM sem considerar o impacto desse código no desempenho de banco de dados, levando a causar transações com timeout ou travamentos em sistemas em larga escala. Chen et al. [21] soluciona este problema com implementação de um framework automatizado e sistemático para detectar e priorizar anti-patterns de desempenho para aplicações desenvolvidas usando ORM. Estudos de caso mostraram que o framework pode detectar centenas ou milhares de instâncias de anti-patterns de desempenho ao mesmo tempo que prioriza efetivamente a correção dessas instâncias [21]. Foi descoberto que a correção dessas instâncias de anti-patterns de desempenho pode melhorar o tempo de resposta dos sistemas em até 98\% (e, em média, 35\%). Além do framework que é extensível podendo agregar outros anti-patterns, Chen et al. [21] contribui com o mapeamento de 2 anti-patterns específicos a frameworks ORM.

Aniche et al. [A] também investigou cheiros de código relacionado a um framework. Segundo o autor, para escrever código fácil de ser mantido e evoluído, e detectar pedaços de código problemáticos, desenvolvedores fazem uso de métricas de código e estratégias de detecção de maus cheiros de código. No entanto, métricas de código e estratégias de detecção de maus cheiros de código não levam em conta a arquitetura do software em análise o que significa que todas classes são avaliadas como se umas fossem iguais às outras. Aniche et al. [A] afirma que cada papel arquitetural possui resposabilidades diferentes o que resulta em distribuições diferentes de valores de métrica de código. Mostra ainda que classes que cumprem um papel arquitetural específico, como por exemplo \textsc{Controllers}, também contêm maus cheiros de código específicos. Uma das contribuições de Aniche et al. é um catálogo com 6 cheiros de códigos específicos ao framework Spring MVC mapeados e validados.

CSS é amplamente utilizado nas aplicações web de hoje para separar a semântica de apresentação do conteúdo HTML [72]. De acordo como Gharachorlu [72] apesar da simplicidade de síntaxe do CSS, as características específicas da linguagem tornam a criação e manutenção de CSS uma tarefa desafiadora. Foi realizando um estudo empírico de larga escala em 500 sites, 5060 arquivos no total, que consistem de mais de 10 milhões de linhas de código CSS. Segundo o autor, os resultados indicaram que o CSS de hoje sofre significativamente de padrões inadequados e está longe de ser um código bem escrito. Porfim Gharachorlu [72] propõe o primeiro modelo de qualidade de código CSS derivado de uma grande amostra de aprendizagem de modo a ajudar desenvolvedores a obter uma estimativa do número total de cheiros de código em seu código CSS. Sua principal contrinbuição foi oito novos cheiros de código CSS detectados com o uso da ferramenta CSSNose, também implementada e disponibilizada pelo autor.


Javascript é uma flexível linguagem de script para o desenvolvimento de aplicações Web 2.0 [23]. Fard e Ali [23] afirmam que devido à essa flexibilidade, o JavaScript é uma linguagem particularmente desafiadora para escrever e manter código. 

Os desafios são múltiplos. Primeiro, é uma linguagem interpretada, o que significa que normalmente não há compilador no ciclo de desenvolvimento que ajudaria os desenvolvedores a detectar código incorreto ou não otimizado. Segundo, tem uma natureza dinâmica, fracamente tipificada, assíncrona. Terceiro, ele suporta recursos intrincados, como prototypes [C], funções de primeira classe e closures [D]. E finalmente, ele interage com o DOM através de um mecanismo complexo baseado em eventos [E]. Os autores propõem um conjunto de 13 cheiros de código JavaScript, sendo 7 cheiros de códigos bem conhecidos adaptados para o JavaScript e 6 tipos específicos de códigos de JavaScript devidos do trabalho. Também é apresentada uma técnica automatizada, chamada JSNOSE, para detectar esses cheiros de código.

% \section{Android}
% geral android (opcional)
% Na prática, não acho que faz sentido pois não tenho muito comparar meu trabalho eu acho, mas deixa como opcional

\section{Maus cheiros tradicionais em projetos Android}

Verloop \cite{MobileSmells:13} e Minelli e Lanza \cite{Mantyla2013} estudam código-fonte de aplicativos para entender se e como eles diferem dos sistemas de software tradicionais e quais são as possíveis implicações para a manutenção de aplicativos. Os autores concluem que aplicações móveis são substancialmente diferentes das aplicações de software tradicionais, por exemplo, a falta de uma fonte de alimentação permanente, vida útil curta, times de desenvolvimento com poucos desenvolvedores, projetos menores, poder de processamento limitado, muitas dependências externas. E que devido a essas diferenças, pesquisas feita em aplicações de software tradicionais podem não se aplicar a aplicações móveis.

Minelli e Lanza \cite{Mantyla2013} realizam sua análise com uma ferramenta desenvolvida por ele chamada Samoa. Samoa é descrita como uma plataforma de análise de software baseada na web para analisar aplicações móveis de uma perspectiva estrutural e histórica. Ele mostra uma série de métricas de software para as aplicações que analisa e apresenta as métricas usando diferentes tipos de gráficos. As métricas utilizadas incluem o número de pacotes, o número de classes, o número de métodos, o número de chamadas internas, o número de chamadas externas, o número de elementos principais, dentre outras. Minelli e Lanza \cite{Mantyla2013} acreditam que no futuro, aplicações móveis poderão enfrentar os mesmos problemas que aplicações tradicionais.

A tese de Verloop \cite{MobileSmells:13} consistiu em encontrar cheiros de código tradicionais em projetos Android para determinar se os cheiros de código ocorrem com mais freqüência no código relacionado ao Android. Para isso, foram usadas ferramentas de detecção automática de cheiros de código. Das 8 ferramentas mencionadas, apenas uma foi desenvolvida especificamente para Android e suportava a linguagem XML (Lint). Vale considerar que, um projeto de aplicativo Android é composto por muitos arquivos XML \cite{AndroidResourcesOverview}. Desta análise Verloop \cite{MobileSmells:13} derivou 4 métricas (CoreCS, CoreNLOC, NonCoreCS e NonCoreNLOC, onde NLOC significa número de linhas de código, do inglês, Number Lines of Code) que foram usadas para calcular o número de cheiros de código. Na Figura X.X é apresentada uma tabela com o resultado.

% \begin{figure}[!htb]
%   \centering
%   \includegraphics[width=0.5\textwidth]{verloop-smells.png}
%   \caption{Número de cheiros de código encontrados por 1000 LOC agrupador por cheiro de código .}
%   \label{fig:VerloopSmells}
% \end{figure}

Verloop \cite{MobileSmells:13} mostra que o cheiro de código \textit{Long Method} é quase duas vezes mais provável de ocorrer nas classes núcleo, classes que herdam da estrutura do Android. Também mostra que o cheiro de código \textit{Large Class} é quase tão provável de ocorrer em classes núcleo como em classes não-núcleo. Uma possível razão para isso pode ser que o número de classes de \textsc{Activities} em comparação com o número total de classes é pequeno. O cheiro de código de  \textit{Long Parameter List} é quase inexistente em classes de núcleo. O cheiro de código \textit{Feature Envy}, tal como o cheiro \textit{Large Class}, é quase tão provável de ocorrer nas classes núcleo como nas classes não-núcleo. O cheiro de código \textit{Type Checking} foi encontrado menos de uma vez a cada 1000 LOC, mas foi encontrado duas vezes mais freqüentemente nas classes principais. Por último, o cheiro de código \textit{Dead Code} é mais provável de ser encontrado em classes não-núcleo. O autor ainda contribui com cincopossíveis refatorações e três delas foram implementadas em um plugin do Eclipse.

Verloop \cite{MobileSmells:13} diz que apesar do crescimento e mudanças do mercado móvel não há muita pesquisa a ser encontrada nesta nova área de desenvolvimento de software. Esses novos desafios enfrentados por desenvolvedores móveis e a quantidade limitada de pesquisa sobre o assunto têm tornado cheiros de código para aumentar a manutenibilidade dessas aplicações em um tópico interessante afirma Verloop \cite{MobileSmells:13}.



Linares-Vásquez et al. \cite{DomainMatters} usou a ferramenta DECOR para realizar a detecção de 18 diferentes \textit{anti-patterns} orientado a objetos em aplicativos móveis desenvolvidos com Java Mobile Edition (J2ME). Este estudo em larga escala mostra que a presença de antipatterns afeta negativamente as métricas de qualidade do software, em particular as métricas relacionadas à falha.


Gottschalk e Jelschen \cite{EnergyAndroidSmells} explicam como tentam melhorar o uso de energia de aplicações móveis, procurando por desperdício de energia, padrões esses que eles denominam de cheiro de código sobre energia (textit{quality code smell}). Os autores produzem um catálogo com um total de 6 cheiros de códigos de energia e salientam que os mesmos são \textit{cross-platform}, ou seja, independente de plataforma móvel. Entretanto, um código Android é dado no exemplo. Cada cheiro de código de energia catalogado tem uma descrição, instruções de como detectar e reestruturar. Reimann et al. \cite{ReimannBrylski2013} também trata sobre cheiros de qualidade e relacionados 20 que impactam no consumo inteligente de recursos de hardware do dispositivo como eficiencia no uso de energia, processamento e memória.


Reimann et al. \cite{ReimannBrylski2013} correlaciona os conceitos de mau cheiro, qualidade e refatoração a fim de introduzir o termo cheiro de qualidade (do inglês \textit{quality smell}). Um cheiro de qualidade é uma estrutura que influencia negativamente requisitos de qualidade específicos, que podem ser resolvidos por refatorações \cite{Reimann:2013:QRE:2588611.2588737}.

Os autores compilaram um catálogo de 30 cheiros de qualidade para Android. O formato dos cheiros de qualidade incluem: nome, contexto, requisitos de qualidades afetados e descrição, este formato foi baseado nos catálogos de Brown et al. \cite{WilleyAntiPatterns} e Fowler \cite{RefactoringFowler1999}. Todo o catálogo pode ser encontrado em [http://www.modelrefactoring.org/smell\_catalog](http://www.modelrefactoring.org/smell\_catalog) e os mesmos também foram implementados no framework Refactory \cite{Reimann:2013:QRE:2588611.2588737}.

O requisitos de qualidade tratados por \cite{ReimannBrylski2013} são: centrados no usuário (estabilidade, tempo de inicio, conformidade com usuário, experiência do usuário e acessibilidade), consumo inteligente de recursos de hardware do dispositivo (eficiência no uso de energia, processamento e memória) e segurança.

Reimann et al. \cite{ReimannBrylski2013} cita que o problema no desenvolvimento móvel é que os desenvolvedores estão cientes de cheiros de qualidade apenas indiretamente porque suas definições são informais (melhores práticas, problemas de rastreamento de bugs, discussões de fórum etc.) e os recursos onde encontrá-los são distribuídos pela web e que é difícil coletar e analisar todas essas fontes sob um ponto de vista comum e fornecer suporte de ferramentas para desenvolvedores. 



Esta dissertação pretende pela primeira vez catalogar cheiros de código especificamente relacionados a camada de apresentação de aplicativos Android. Pretende-se reaproveitar diversos dos métodos utilizados para a detecção e documentação de cheiros de código dos diversos trabalhos acima citados.



\section{Maus cheiros Android não relacionados a manutenibilidade}


Gottschalk et al \cite{RemovingEnergySmells:12} conduziram um estudo sobre formas de detectar e refatorar cheiros de código relacionados ao uso eficiente de energia. Os autores compilaram um catálogo com 8 cheiros de código e trabalharam sob um trecho de código Android para exemplificar um deles, o binding resource too early, quando algum recurso é alocado muito antes de precisar ser utilizado. Essaq pesquisa é relacionada à nossa por ambas considerarem a tecnologia Android e se diferenciam pois focamos na busca por cheiros de código relacionados a qualidade de código, no sentido de legibilidade e manutenablidade.

Aplicativos Android são escritos na linguagem de programação Java \cite{AndroidFundamentals}. Então a primeira questão é: por que buscar por \textit{smells} Android sendo que já existem tantos \textit{smells} Java? Pesquisas têm demonstrado que tecnologias diferentes podem apresentar \textit{code smells} específicos, como por exemplo Aniche et al. identificaram 6 \textit{code smells} específicos ao framework Spring MVC, um framework Java para desenvolvimento web. Outras pesquisas concluem que projetos Android possuem características diferentes de projetos java \cite{Hecht:15, Mannan_Dig_Ahmed_Jensen_Abdullah_Almurshed, ReimannBrylski2013}, por exemplo, o \textit{front-end} é representado por arquivos XML e o ponto de entrada da aplicação é dado por \textit{event-handler} \cite{AndroidActivities2016} como o método \textsc{onCreate}. Encontramos também diversas pesquisas sobre \textit{code smells} sobre tecnologias usadas no desenvolvimento de \textit{front-end} web como CSS \cite{CSSCodeSmell} e JavaScript \cite{BB}. Essas pesquisas nos inspiraram a buscar entender se existem \textit{code smells} no \textit{front-end} Android. \\
% 
% Umme et al. \cite{Mannan_Dig_Ahmed_Jensen_Abdullah_Almurshed} recentemente levantaram que, das principais conferências de manutenção de software (ICSE, FSE, OOPSLA/SPLASH, ASE, ICSM/ICSME, MRS e ESEM), dentre 2008 a 2015, apenas 10\% dos artigos consideraram em suas pesquisas, projetos Android. Nenhuma outra plataforma móvel foi considerada.  
% \textbf{[seção não finalizada, á concluir.]}


% Boa frase, só falta refs e colocar no lugar certo
% A percepção desempenha um importante papel na definição de maus cheiros de código relacionados a uma tecnologia, visto que maus cheiros possuem uma natureza subjetiva. Maus cheiros desempenham um importante papel na busca por qualidade de código, visto que, após mapeados, podemos chegar a heurísticas para identificá-los e com essas heurísticas, implementar ferramentas que automatizem o processo de identificar códigos problemáticos.