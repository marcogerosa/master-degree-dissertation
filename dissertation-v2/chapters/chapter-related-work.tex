% -*- root: article.tex -*-
Muitas pesquisas têm sido realizadas sobre a plataforma Android, muitas delas focam em vulnerabilidades \cite{Y, F, G, X, P, D, E}, autenticação \cite{T, Yamashita6405287, R} e testes \cite{J, M}. Diferentemente dessas pesquisas, nossa pesquisa tem foco na percepção dos desenvolvedores sobre boas e más práticas de desenvolvimento na plataforma Android. 

\section{Pesquisas sobre o \textit{front-end} Android}


\section{Maus cheiros específicos a uma tecnologia}
  Diversos pesquisadores propuseram cheiros de código e práticas recomendadas para tecnologias ou plataformas específicas, como frameworks Java [21, A], linguagem Cascading Style Sheets (CSS) [72] e fórmulas em planilhas [54].

  Chen et al. [21] afirma que frameworks Object-Relational Mapping (ORM) são amplamente utilizado na indústria. No entanto, os desenvolvedores geralmente escrevem código ORM sem considerar o impacto desse código no desempenho de banco de dados, levando a causar transações com timeout ou travamentos em sistemas em larga escala. Chen et al. [21] soluciona este problema com implementação de um framework automatizado e sistemático para detectar e priorizar anti-patterns de desempenho para aplicações desenvolvidas usando ORM. Estudos de caso mostraram que o framework pode detectar centenas ou milhares de instâncias de anti-patterns de desempenho ao mesmo tempo que prioriza efetivamente a correção dessas instâncias [21]. Foi descoberto que a correção dessas instâncias de anti-patterns de desempenho pode melhorar o tempo de resposta dos sistemas em até 98\% (e, em média, 35\%). Além do framework que é extensível podendo agregar outros anti-patterns, Chen et al. [21] contribui com o mapeamento de 2 anti-patterns específicos a frameworks ORM.

  Aniche et al. [A] também investigou cheiros de código relacionado a um framework. Segundo o autor, para escrever código fácil de ser mantido e evoluído, e detectar pedaços de código problemáticos, desenvolvedores fazem uso de métricas de código e estratégias de detecção de maus cheiros de código. No entanto, métricas de código e estratégias de detecção de maus cheiros de código não levam em conta a arquitetura do software em análise o que significa que todas classes são avaliadas como se umas fossem iguais às outras. Aniche et al. [A] afirma que cada papel arquitetural possui resposabilidades diferentes o que resulta em distribuições diferentes de valores de métrica de código. Mostra ainda que classes que cumprem um papel arquitetural específico, como por exemplo \textsc{Controllers}, também contêm maus cheiros de código específicos. Uma das contribuições de Aniche et al. é um catálogo com 6 cheiros de códigos específicos ao framework Spring MVC mapeados e validados.

  CSS é amplamente utilizado nas aplicações web de hoje para separar a semântica de apresentação do conteúdo HTML [72]. De acordo como Gharachorlu [72] apesar da simplicidade de síntaxe do CSS, as características específicas da linguagem tornam a criação e manutenção de CSS uma tarefa desafiadora. Foi realizando um estudo empírico de larga escala em 500 sites, 5060 arquivos no total, que consistem de mais de 10 milhões de linhas de código CSS. Segundo o autor, os resultados indicaram que o CSS de hoje sofre significativamente de padrões inadequados e está longe de ser um código bem escrito. Porfim Gharachorlu [72] propõe o primeiro modelo de qualidade de código CSS derivado de uma grande amostra de aprendizagem de modo a ajudar desenvolvedores a obter uma estimativa do número total de cheiros de código em seu código CSS. Sua principal contrinbuição foi oito novos cheiros de código CSS detectados com o uso da ferramenta CSSNose, também implementada e disponibilizada pelo autor.


  Javascript é uma flexível linguagem de script para o desenvolvimento de aplicações Web 2.0 [23]. Fard e Ali [23] afirmam que devido à essa flexibilidade, o JavaScript é uma linguagem particularmente desafiadora para escrever e manter código. 

  Os desafios são múltiplos. Primeiro, é uma linguagem interpretada, o que significa que normalmente não há compilador no ciclo de desenvolvimento que ajudaria os desenvolvedores a detectar código incorreto ou não otimizado. Segundo, tem uma natureza dinâmica, fracamente tipificada, assíncrona. Terceiro, ele suporta recursos intrincados, como prototypes [C], funções de primeira classe e closures [D]. E finalmente, ele interage com o DOM através de um mecanismo complexo baseado em eventos [E]. Os autores propõem um conjunto de 13 cheiros de código JavaScript, sendo 7 cheiros de códigos bem conhecidos adaptados para o JavaScript e 6 tipos específicos de códigos de JavaScript devidos do trabalho. Também é apresentada uma técnica automatizada, chamada JSNOSE, para detectar esses cheiros de código.

% \section{Android}
% geral android (opcional)
% Na prática, não acho que faz sentido pois não tenho muito comparar meu trabalho eu acho, mas deixa como opcional

\section{Maus cheiros específicos ao Android}

  \subsection{Removing Energy Code Smells with Reengineering Services}

    Gottschalk et al \cite{RemovingEnergySmells:12} conduziram um estudo sobre formas de detectar e refatorar cheiros de código relacionados ao uso eficiente de energia. Os autores compilaram um catálogo com 6 cheiros de código extraído de outros trabalhos, e trabalharam sob um trecho de código Android para exemplificar um deles, o \textit{Carregar Recurso Muito Cedo}, quando algum recurso é alocado muito antes de precisar ser utilizado. Essa pesquisa é relacionada à nossa por ambas considerarem a tecnologia Android e se diferenciam pois focamos na busca por maus cheiros de código relacionados manutenibilidade enquanto eles tratam de eficiência, conforme conceitos de qualidade de software apresentados da Seção 2.2.

  \subsection{A Tool-Supported Quality Smell Catalogue For Android Developers - Reimann et al.}

    Reimann et al. \cite{ReimannBrylski2013} correlaciona os conceitos de mau cheiro, qualidade e refatoração a fim de introduzir o termo cheiro de qualidade (do inglês \textit{quality smell}). Um cheiro de qualidade é uma estrutura que influencia negativamente requisitos de qualidade específicos, que podem ser resolvidos por refatorações \cite{Reimann:2013:QRE:2588611.2588737}.

    Os autores compilaram um catálogo de 30 cheiros de qualidade para Android. O formato dos cheiros de qualidade incluem: nome, contexto, requisitos de qualidades afetados e descrição, este formato foi baseado nos catálogos de Brown et al. \cite{WilleyAntiPatterns} e Fowler \cite{RefactoringFowler1999}. Todo o catálogo pode ser encontrado em [http://www.modelrefactoring.org/smell\_catalog](http://www.modelrefactoring.org/smell\_catalog) e os mesmos também foram implementados no framework Refactory \cite{Reimann:2013:QRE:2588611.2588737}.

    O requisitos de qualidade tratados por \cite{ReimannBrylski2013} são: centrados no usuário (estabilidade, tempo de inicio, conformidade com usuário, experiência do usuário e acessibilidade), consumo inteligente de recursos de hardware do dispositivo (eficiência no uso de energia, processamento e memória) e segurança.

    Reimann et al. \cite{ReimannBrylski2013} cita que o problema no desenvolvimento móvel é que os desenvolvedores estão cientes de cheiros de qualidade apenas indiretamente porque suas definições são informais (melhores práticas, problemas de rastreamento de bugs, discussões de fórum etc.) e os recursos onde encontrá-los são distribuídos pela web e que é difícil coletar e analisar todas essas fontes sob um ponto de vista comum e fornecer suporte de ferramentas para desenvolvedores. 

    Derivou os 30 maus cheiros de boas e más práticas documentadas online na documentação do Android e de postagens em blogs de desenvolvedores que reportaram suas experiências. (segundo o paper de Geoffrey Hetch - abaixo)



\section{Presença de maus cheiros em projetos Android}

  \subsection{Code Smells in the Mobile Applications Domain - Verloop}
    A tese de Verloop \cite{MobileSmells:13} consistiu em buscar maus cheiros de códigos tradicionais, sendo esses propostos por Fowler: Long Method, Large Class, Long Parameter List, Feature Envy e Dead Code, em projetos Android para determinar se esses maus cheiros ocorrem mais frequentemente em códigos relacionado ao Android. Para isso, ele fez uso de 4 ferramentas de detecção automática de maus cheiros: JDeodorant, Checkstyle, PMD and UCDetector.  

    Basicamente o desenvolvimento Android é feito com código Java, considerando isso, uma pergunta óbvia seria: Por que buscar por maus cheiros específicos Android se já existem tantos definidos aplicáveis a código Java? Uma característica do Android é que, apesar de ser código Java, muitas classes em projetos Android precisam herdar de classes do SDK Android, por exemplo Activities, Fragments e Services.  Essa característica o torna diferente e portanto, sucetível a apresentar maus cheiros específicos. Verloop classifica todo código Java, em um projeto Android, que precisa herdar de classes do SDK Android como classes núcleo. Durante sua análise, ele compara a presença dos maus cheiros em classes núcleo e não núcleo, sendo esta última, classes puramente Java.

    Verloop confirma que classes núcleos tendem a apresentar os maus cheiros God Class [conclui que dá na mesma mobile ou não, além de não se decidir de usar Large Class ou God Class], Long Method [afirma nos resultados], Switch Statement [nem comenta nos resultados, como assim mewww????] e Type Checking [afirma nos resultados] pela sua natureza (os demais não são mais propensos a aparecer em projetos Android), conforme explicamos na Seção (BACKGROUND SOBRE ACTIVITIES NO ANDROID - falar das muitas responsabilidades, etc). O que é interessante é, se esta de classes núcleo, que caracterizam projetos Android (pois sem isso é apenas um projeto Java), será que estes maus cheiros tradicionais nos dão a informação necessária para refatorar e aumentar a manutenibilidade do código? Pois, se é da natureza da Activity ser assim, talvez as soluções propostas para refatorar estes maus cheiros não se apliquem ao Android. Logo, chegamos ao ponto que a natureza do Android pode implicar em maus cheiros específicos que tragam outras abordagens, que respeitem a natureza de projetos Android, para refatoração.

    Outra constatação interessante de Verlopp é que o mau cheiro tradicional long Parameter List é menos provável de aparecer em classes núcleo pela razão de, nessas classes, a maioria dos métodos serem sobrecargas de métodos, e estes não são afetados por este mau cheiro. Novamente voltamos ao ponto que maus cheiros tradicionais não foram pensados considerando a natureza de projetos Android.

    Ao final do seu trabalho, Verloop propõe 5 refatorações com o objetivo de mitigar o mau cheiro Long Method que se apresentou por diversos motivos em Activities e Adapters. Dentre estas 5 propostas de refatoração, ele implementou e testou 3 [explicar melhor estes resultados - chapter 6], sendo que:

    A primeira, uso do padrão ViewHolder em Adapter de fato melhora a qualidade do código, no exemplo de Verloop, dos 12 Adapter afetados pelo mau cheiro Long Method, após a refatoração apenas 4 continuaram apresentando o mau cheiro. Este padrão tras resultados não apenas em manutenibilidade com de perfomance e consumo de energia também [explicar], por todos estes benefícios, hoje [em qual versão do android?] já existe um componente no SDK Android com esta implementação de forma nativa.
    A segunda, uma espécie de ViewHolder para Activities, objetivava mitigar Long Methods, porém não trouxe bons resultados sendo que das 13 Activities refatoradas, nenhum deixou de ser afetada pelo Long Method.
    A terceira propõe mitigar Long Methods em Activities trocando atribuição de listener feitas com classes anônimas pelo uso do atributo OnClick no layout respectivo. Os resultados aqui obtidos não foram muito satisfatórios também pois, das 13 classes refatoradas, 7 ainda apresentaram o mau cheiro devido ao uso de outros listeners que não o de click, que não possuem atributos correspondentes. Além disso, já se sabe hoje que o uso de atributos não é interessante devido ao acoplamento resultante da Activity com aquele determiado XML dentre outros problemas [quais?]. Apesar disso, Verloop considerou os resultados bons.

    É interessante notar que dentro da definição de classes núcleo estão incluídas classes que heram de Services, dentre outras, porém as únicas classes que apresentaram maus cheiros foram Activities e Adapters. Como vimos em BACKGROUND ANDROID, essas classes são responsáveis por lidar com a UI e estes resultados de Verloop reforçam nossa hipótese que o front-end Android tende a ser mais problemático que o restante dos códigos da aplicação e por isso vale a pena ser estudado mais a fundo. 

  \subsection{An Approach to Detect Android Antipatterns - Geoffrey Hetch}
    Hetch [?] utilizou a ferratementa de detecção de maus cheiros Páprika [?] para identificar 8 maus cheiros, sendo 4 tradicionais (Blob class [9], Swiss Army Knife [9], Complex Class [12] e Long Method [12]) e 4 Android (Internal Getter/Setter, No Low Memory Resolver, Member Ignoring Method e Leaking Inner Class), definidos por [Reimann] em 15 aplicações Android populares como Facebook, Skype, Twitter. Isso foi possível pois a ferramenta Páprika se utiliza do APK para extrair os dados para análise. Um ponto importante é que apesar de Hetch utilizar do termo anti-patterns, ele se baseia em outros artigos que definiram os \textit{``antipatterns''} por ele analisado como maus cheiros. Logo, seguiremos com o termos mau cheiro, pois entendemos que apesar da divergência do termo, o autor se refere a ele. Vale considerar que, para se classificar como um antipattern o item deve atender as 2 (ou 3?) características mencionadas em [ref p/ livro de antipatterns] como abordamos na Seção X.X.X [sobre antipatterns] e não há evidências que de que os itens tratados por Hetch atendem as características mencionadas.

    Hetch afirma que os maus cheiros tradicionais são tão frequentes em apps Android como em não Android, com exceção ao Swiss Army Knife, mas não há evidências de ele ter executado o Páprika em busca dos mesmos maus cheiros em projetos não Android. Segundo o artigo, Activities tendem a ser mais sensíveis ao Blob Class, mau cheiro este muito similar a God Class e Large Class, também identificado como muito comum por Verloop [?], esta conclusão reforça nossa hipótese que códigos pertencentes ao front-end Android são mais propensos a apresentar trechos problemáticos, que, apesar de já existirem maus cheiros que os identificam, a refatoração proposta não é apropriada pois é da natureza de projetos Android apresentarem estes problemas, isso nos leva a pensar que essas situações em sí não são o problema de fato, e que talvez existam outras formas de definir e lidar com esses problemas no Android.

    Outra conclusão interessante é que o artigo diz que maus cheiros específicos Android são muito mais frequentes do que os maus cheiros tradicionais, o que reafirma a necessidade de pesquisar se há outros maus cheiros específicos, que tendem também a ser mais frequentes.

  % \subsection{Detecting antipatterns in Android apps - Geoffrey Hetch}
  %   ???

  % \subsection{Domain Matters: Bringing Further Evidence of the Relationships among Anti-patterns, Application Domains, and Quality-Related Metrics in Java Mobile Apps - Linares-Vásquez et al.}

    % Linares-Vásquez et al. \cite{DomainMatters} usou a ferramenta DECOR para realizar a detecção de 18 diferentes \textit{anti-patterns} orientado a objetos em aplicativos móveis desenvolvidos com Java Mobile Edition (J2ME). Este estudo em larga escala mostra que a presença de antipatterns afeta negativamente as métricas de qualidade do software, em particular as métricas relacionadas à falha.


\section{Apps Android vs. Software Tradicional}

  \subsection{Software analytics for mobile applications, insights \& lessons learned - Minelli e Lanza}

    Os autores apresentam diferenças no desenvolvimento de apps e softwares tradicionais em termos de métricas de código, uso de APIs terceiras e evolução. Para isso se utilizam da ferramenta SAMOA de análise estática de código desenvolvida por eles.

    É interessante que para análise do código Android eles também modelam o projeto em código core e não core, onde o código core está relacionado a classes que herdam do Android SDK, apesar disso, eles dizem coletar essa informação do Android Manifesto, considerando Activities e Services, entretanto, existem diversas outras classes em um projeto Android que herdam do Android SDK e não precisam ser declaradas no Android Manifesto, ou seja, a definição usada abrange muito mais código do que de fato analisado pela pesquisa.

    Concluem com um conjunto de características de apps e com um conjunto de hábitos dos desenvolvedores destes apps que diferem de aplicações de software tradicionais. Dentre as características, afirmam que algumas vezes core code do app é composto por uma, ou algumas, God Classes. E que herança é algo quase inexistente em apps Android. O que reforça nossa identificação de falta de arquitetura padrão, visto que esta exige um conhecimento mais aprimorado de orientação a objetos que inclui herança.




\begin{center}
. . .
\end{center}




Esta dissertação pretende pela primeira vez catalogar cheiros de código especificamente relacionados a camada de apresentação de aplicativos Android. Pretende-se reaproveitar diversos dos métodos utilizados para a detecção e documentação de cheiros de código dos diversos trabalhos acima citados.


Aplicativos Android são escritos na linguagem de programação Java \cite{AndroidFundamentals}. Então a primeira questão é: por que buscar por \textit{smells} Android sendo que já existem tantos \textit{smells} Java? Pesquisas têm demonstrado que tecnologias diferentes podem apresentar \textit{code smells} específicos, como por exemplo Aniche et al. identificaram 6 \textit{code smells} específicos ao framework Spring MVC, um framework Java para desenvolvimento web. Outras pesquisas concluem que projetos Android possuem características diferentes de projetos java \cite{Hecht:15, Mannan_Dig_Ahmed_Jensen_Abdullah_Almurshed, ReimannBrylski2013}, por exemplo, o \textit{front-end} é representado por arquivos XML e o ponto de entrada da aplicação é dado por \textit{event-handler} \cite{AndroidActivities2016} como o método \textsc{onCreate}. Encontramos também diversas pesquisas sobre \textit{code smells} sobre tecnologias usadas no desenvolvimento de \textit{front-end} web como CSS \cite{CSSCodeSmell} e JavaScript \cite{BB}. Essas pesquisas nos inspiraram a buscar entender se existem \textit{code smells} no \textit{front-end} Android. \\
% 
% Umme et al. \cite{Mannan_Dig_Ahmed_Jensen_Abdullah_Almurshed} recentemente levantaram que, das principais conferências de manutenção de software (ICSE, FSE, OOPSLA/SPLASH, ASE, ICSM/ICSME, MRS e ESEM), dentre 2008 a 2015, apenas 10\% dos artigos consideraram em suas pesquisas, projetos Android. Nenhuma outra plataforma móvel foi considerada.  
% \textbf{[seção não finalizada, á concluir.]}


% Boa frase, só falta refs e colocar no lugar certo
% A percepção desempenha um importante papel na definição de maus cheiros de código relacionados a uma tecnologia, visto que maus cheiros possuem uma natureza subjetiva. Maus cheiros desempenham um importante papel na busca por qualidade de código, visto que, após mapeados, podemos chegar a heurísticas para identificá-los e com essas heurísticas, implementar ferramentas que automatizem o processo de identificar códigos problemáticos.