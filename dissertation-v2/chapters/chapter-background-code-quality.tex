% -*- root: index.tex -*-
\section{Qualidade de Software}

Para entendermos o conceito de qualidade de software precisamos primeiro entender o conceito de qualidade. Há décadas diversos autores e organizações vem trabalhando em suas próprias definições de qualidade. Segundo o ISO 9000 \cite{ISO9000:00}, qualidade é \emph{``o grau em que um conjunto de características inerentes a um produto, processo ou sistema cumpre os requisitos inicialmente estipulados para estes''}. Juran \cite{JuranQuality:1998}, um dos principais autores sobre o assunto, tem duas definições para qualidade: \emph{``as características dos produtos que atendem as necessidades dos clientes, e, assim, proporcionam a satisfação do mesmo''} e \emph{``qualidade é a ausência de deficiências''}. 

Stefan \cite{StefanSoftwareQuality:13} também examinou diversas definições e identificou que na maioria delas era possível identificar uma mesma ideia central sobre qualidade, de certa forma, todas elas se resumiam a \emph{``requisitos que precisam ser satisfeitos para ter qualidade''} \cite[p~6]{StefanSoftwareQuality:13}. 

% \emph{Qualidade de software} é uma área do conhecimento da engenharia de software que trata das características desejadas em um projeto de software, sejam elas funcionais, o quanto o software atende as necessidades de negócio, ou estruturais, o quão bem o software funciona. Diversas características são desejáveis em um software, dentre elas confiabilidade, eficiência e manutenibilidade. A área de conhecimento sobre qualidade de software nos serve justamente para definir conceitos que suportam a criação de práticas e ferramentas que visam aumentar a qualidade de softwares. Muitos estudos já mostraram que problemas de qualidade em software demandam altos custos a empresas. Desta forma, essa área do conhecimento orienta nossos esforços para melhorar a qualidade de projetos de software visando, dentre outras coisas, reduzir os custos.

% Muitas são as definições dadas ao termo qualidade de software. Segundo a norma ISO 9000 (versão 2000), ``qualidade é o grau em que um conjunto de características inerentes a um produto, processo ou sistema cumpre os requisitos inicialmente estipulados para estes''. Já Juran, um dos principais autores sobre o assunto, tem duas definições para qualidade ``a característica dos produtos que atendem as necessidades dos clientes, e, assim, proporcionar a satisfação do mesmo[2]'' e ``qualidade é a ausência de deficiências[2]''. 

As primeiras contribuições referente a qualidade em termos de software foram publicadas no fim da década de 70. Boehm et al. \cite{Boehm:78} e McCall et al. \cite{McCall:77} descrevem modelos de qualidade de software através de conceitos e subconceitos. Ambos se utilizam de uma decomposição hierárquica e dentre os conceitos encontramos por exemplo manutenibilidade e confiabilidade \cite[p~29-30]{StefanSoftwareQuality:13}. Com o tempo, diversas variações desse modelo começaram a surgir como é possível observar na Tabela \ref{tab:QualityModels}. Entretanto, o grande valor que esse modelo de decomposição hierárquica trouxe foi a ideia de decompor o conceito de qualidade até um nível que se possa mensurar e então estimar a qualidade \cite{StefanSoftwareQuality:13}.

\begin{table}[h]
\centering
\renewcommand*{\arraystretch}{1.5}
\scriptsize
\begin{tabular}{@{}p{4.5cm}p{11.5cm}@{}}
\toprule
\textbf{Nome do Modelo} & \textbf{Descrição} \\
\hline
ISO/IEC 9126 \cite{ISO9126:91} & Substituído pela ISO/IEC 25010:2011 (SQuaRE) decompõe qualidade de software em 6 áreas () e sub-áreas.   \\
ISO/IEC 25010 (SQuaRE) \cite{ISO25010:11} & 3 perspectivas de qualidade (interna, externa e em uso)    \\
CISQ & Decompõe qualidade de software em 5 conceitos () e foi fundado em 2011 e se apoia nas definições do ISO 9126. \\
SWEBOK \cite{SWEBOK:14} & Decompõe qualidade de software em 4 áreas e considera que qualidade está envolvido com as qualidades estáticas do software. \\
FURPS \cite{ModelFURPS:87} & Decompõe qualidade de software em funcionalidade, usabilidade, confiabilidade, desempenho e suporte. \\
\toprule
\end{tabular}
\caption{Modelos de Qualidade de Software}
\label{tab:QualityModels}
\end{table}

O padrão ISO/IEC 9126 foi inspirado nestes trabalhos \todo{ref?}.

O padrão ISO/IEC 9126, substituído pelo ISO/IEC 25010 (SQuaRE) é considerado atualmente como principal referência  para a definição de qualidade de software e a define como ``a capacidade do produto de software satisfazer as necessidades implícitas e explícitas quando usado em condições específicas''. O SQuaRE subdivide qualidade de software em seis conceitos, cada qual contendo um conjunto de sub-conceitos, a Figura \ref{fig:QualityCharacteristics} apresenta os seis conceitos e seus sub-conceitos e a seguir apresentamos uma descrição de cada conceito e sub-conceito. 

% Segundo o SWEBOK (\textit{Software Engineering Body of Knowledge}) qualidade de software pode se referir ``as características desejadas de produtos de software, a extensão em que um produto de software em particular possui essas características e aos processos, ferramentas e técnicas que são usadas para garantir essas características'' \cite[p.~174]{SWEBOK:14}.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=1\textwidth]{caracteristicas-software-qualidade-pt.png}
  \caption{Características de Qualidade de Software segundo norma ISO/IEC 25010}
  \label{fig:QualityCharacteristics}
\end{figure}

% \todo{para embasar as truduções na imagem https://pt.wikipedia.org/wiki/Qualidade\_de\_software\#/media/File:Qualidade\_de\_Produto\_de\_Sistemas\_e\_Software.jpg}

\subsection{Funcionalidade} 

A capacidade de um software prover funcionalidades que satisfaçam o usuário em suas necessidades declaradas e implícitas, dentro de um determinado contexto de uso. Seus sub-conceitos são: 
\begin{itemize}
  \item \emph{Adequação}, que mede o quanto o conjunto de funcionalidades é adequado às necessidades do usuário;
  \item \emph{Acurácia} (ou precisão) representa a capacidade do software de fornecer resultados precisos ou com a precisão dentro do que foi acordado/solicitado;
  \item \emph{Interoperabilidade} que trata da maneira como o software interage com outro(s) sistema(s) especificados;
  \item \emph{Segurança} mede a capacidade do sistema de proteger as informações do usuário e fornecê-las apenas (e sempre) às pessoas autorizadas. Segurança também pode estar dirigida em, processar gerar e armazenar as informações;
  \item \emph{Conformidade} trata da padronização, políticas e normas de um projeto.
\end{itemize}

\subsection{Confiabilidade}   

O produto se mantém no nível de desempenho nas condições estabelecidas. Seus sub-conceitos são: 
\begin{itemize}
  \item \emph{Maturidade}, entendida como sendo a capacidade do software em evitar falhas decorrentes de defeitos no software;
  \item \emph{Tolerância a Falhas} representando a capacidade do software em manter o funcionamento adequado mesmo quando ocorrem defeitos nele ou nas suas interfaces externas;
  \item \emph{Recuperabilidade} que foca na capacidade de um software se recuperar após uma falha, restabelecendo seus níveis de desempenho e recuperando os seus dados;
  \item \emph{Conformidade} tempo ou utilização de recursos.
\end{itemize}

\subsection{Usabilidade}   

A capacidade do produto de software ser compreendido, seu funcionamento aprendido, ser operado e ser atraente ao usuário. Seus sub-conceitos são:
\begin{itemize}
  \item \emph{Inteligibilidade} que representa a facilidade com que o usuário pode compreender as suas funcionalidades e avaliar se o mesmo pode ser usado para satisfazer as suas necessidades específicas;
  \item \emph{Apreensibilidade} identifica a facilidade de aprendizado do sistema para os seus potenciais usuários;
  \item \emph{Operacionalidade} é como o produto facilita a sua operação por parte do usuário, incluindo a maneira como ele tolera erros de operação;
  \item \emph{Proteção frente a erros de usuários} como produto consegue prevenir erros dos usuários;
  \item \emph{Atratividade} envolve características que possam atrair um potencial usuário para o sistema, o que pode incluir desde a adequação das informações prestadas para o usuário até os requintes visuais utilizados na sua interface gráfica;
  \item \emph{Acessibilidade} refere-se a prática inclusiva de fazer softwares que possam ser utilizados por todas as pessoas que tenham deficiência ou não. Quando os softwares são corretamente concebidos, desenvolvidos e editados, todos os usuários podem ter igual acesso à informação e funcionalidades;  
\end{itemize}

\subsection{Eficiência}   

O tempo de execução e os recursos envolvidos são compatíveis com o nível de desempenho do software. Seus sub-conceitos são:
\begin{itemize}
  \item \emph{Comportamento em Relação ao Tempo} que avalia se os tempos de resposta (ou de processamento) estão dentro das especificações;
  \item \emph{Utilização de Recursos} que mede tanto os recursos consumidos quanto a capacidade do sistema em utilizar os recursos disponíveis;
\end{itemize}

\subsection{Manutenibilidade}   

A capacidade (ou facilidade) do produto de software ser modificado, incluindo tanto as melhorias ou extensões de funcionalidade quanto as correções de defeitos, falhas ou erros. Seus sub-conceitos são:
\begin{itemize}
  \item \emph{Analisabilidade} identifica a facilidade em se diagnosticar eventuais problemas e identificar as causas das deficiências ou falhas;
  \item \emph{Modificabilidade} caracteriza a facilidade com que o comportamento do software pode ser modificado;
  \item \emph{Estabilidade} avalia a capacidade do software de evitar efeitos colaterais decorrentes de modificações introduzidas;
  \item \emph{Testabilidade} representa a capacidade de se testar o sistema modificado, tanto quanto as novas funcionalidades quanto as não afetadas diretamente pela modificação;
\end{itemize}

\subsection{Portabilidade}   

A capacidade do sistema ser transferido de um ambiente para outro. Seus sub-conceitos são: 
\begin{itemize}
  \item \emph{Adaptabilidade}, representando a capacidade do software se adaptar a diferentes ambientes sem a necessidade de ações adicionais (configurações); 
  \item \emph{Instalabilidade} identifica a facilidade com que pode se instalar o sistema em um novo ambiente; 
  \item \emph{Coexistência} mede o quão facilmente um software convive com outros instalados no mesmo ambiente; 
  \item \emph{Substituibilidade} representa a capacidade que o sistema tem de substituir outro sistema especificado, em um contexto de uso e ambiente específicos. Este atributo interage tanto com adaptabilidade quanto com instalabilidade; 
\end{itemize}

\begin{center}
  . . .
\end{center}

Esta pesquisa está inserida no contexto de \emph{manutenabilidade}, mais especificamente \emph{analisabilidade} e \emph{modificabilidade} visto que, conforme veremos na seção X.XX, maus cheiros de código visam apontar códigos possivelmente problemáticos que podem se beneficiar de refatorações, incrementando a manutenibilidade do software. 

Muito embora tenha-se provado que investir em qualidade pode reduzir os custos de um projeto \todo{refs?}, aumentar a satisfação dos usuários e desenvolvedores \todo{refs??}, qualidade de software costuma ser esquecido ou deixado em segundo plano \todo{refs?}. Quem nunca ouviu a frase ``depois eu testo'', ou ``depois eu refatoro'' no dia a dia? Manutenibilidade está relacionada as \emph{necessidades implícitas} do software mencionada na definição de qualidade das normas ISO/EIC 9126 e ISO/IEC 25010 e que aparecem nas outras definições de outras maneiras. 

Focado nesse conceito, ao longo dos últimos anos diversas boas práticas de software vem sendo documentadas objetivando servir de ferramenta a desenvolvedores menos experientes para aumentar a qualidade do software. Por exemplo os padrões de projeto do GoF veem com o objetivo de documentar \emph{melhores soluções para problemas comuns} originadas a partir do conhecimento empírico de desenvolvedores de software experientes. Anti-padrões são padrões antes recomendados que passaram a ser evitados pois percebeu-se que os problemas em usá-los superavam os benefícios \todo{referencia aqui do livro anti-patterns}, um dos maiores exemplos de anti-padrão é o \textit{Singleton} \todo{breve desc aqui}. \emph{Maus cheiros de código} que trataremos melhor na seção \todo{colocar seção aqui}, apontam sintomas que podem indicar um problema mais profundo no software. É interessante notar que, enquanto que padrões de projetos são conceitos que indicam \textit{``o que fazer''}, anti-padrões e maus cheiros são conceitos que servem como alertas sobre \textit{``o que não fazer''} ou sobre \textit{``o que evitar''}. Esse conjunto de documentos são comumente generalizados entre os desenvolvedores simplesmente pelo termo \emph{boas práticas de software} \cite{CodeComplete:04} \todo{rever ref}. 

% citações diretas sobre vários autores com relação a importância de qualidade
A importância de qualidade de software tem se reforçado ano após anos e podemos ver isso em resultados de pesquisas e no dia a dia quando enfrentamos problemas relativos a ela. Os erros de construção detectados no teste do sistema custam 10 vezes mais para consertar do que na fase de construção. Os erros de construção detectados postrelease custaram 10-25 vezes mais para consertar do que na fase de construção (Fagan 1976; Dunn 1984; Boehm \& Turner 2004, Shull et al., 2002). O Laboratório de Engenharia de Software da NASA descobriu que a leitura de código detectou 3,3 defeitos por hora de esforço: o teste detectou cerca de 1,8 erros por hora. A leitura do código encontrou 20 a 60\% mais erros durante a vida do projeto do que os vários tipos de testes (Card 1987). 50\% a 80\% das declarações ``if'' simples deveriam ter tido um ``else'' cláusula (Elshoff, 1976). Poucas pessoas podem entender mais de 3 ou 4 níveis de ifs aninhados (Yourdon 1986; Ledgard \& Tauer, 1987). A complexidade do fluxo de controle tem sido correlacionada com baixa confiabilidade e erros freqüentes (McCabe 1976, Shen et al., 1985, Ward, 1989). A remoção de defeitos de software é o mais caro e demorado forma de trabalho para software (Jones 2000). \todo{http://www.ifsq.org/resources/level-2/booklet.pdf}

% É comum no dia a dia de desenvolvimento de software ouvirmos o termo \textit{boas práticas} como uma generalização para se referir a termos como por exemplo: padrões de projetos, anti-padrões e \emph{maus cheiros de código} que encapsulam ideias sobre como criar códigos com \emph{mais qualidade}. Apesar dessa comum generalização, cada um desses termos possui um significado distinto. 

% Para melhor entendimento sobre o contexto desta pesquisa, nesta seção apresentamos a definição dos principais termos que se confundem: boas práticas, padrões de projeto, anti-padrões e maus cheiros de código. Ao final, concluímos com uma reflexão das semelhanças e diferenças entre eles.

\section{Boas Práticas de Software}

% Segundo o dicionário Aurélio \cite{AurelioPratica}, \textit{prática} significa ``maneira habitual de proceder''. O termo não é restrito a uma área do conhecimento, e a depender da área em que é usado, englobará um conjunto diferente de maneiras habituais. 

Em desenvolvimento de software, \emph{boas práticas de código} são um conjunto de regras que a comunidade de desenvolvimento de software aprendeu ao longo do tempo, e que pode ajudar a melhorar a qualidade do software \cite{CodeComplete:04}. Dentre este conjunto de regras temos padrões de projetos, anti-padrões e \emph{maus cheiros de código} que detalhamos a seguir.


\subsection{Padrões de Projeto}

  
  \epigraph{\emph{\textbf{Padrão:} Algo que serve como modelo. Um exemplo para os outros seguirem.}}{--- \textup{Dicionário Oxford [2]}}

  Não podemos falar sobre \emph{padrões de projetos} sem antes falarmos sobre \emph{padrões}. Segundo o dicionário Oxford um padrão é \emph{algo que serve como modelo, um exemplo para os outros seguirem} [2]. Padrões não são invenção de algo novo, é uma forma de organizar o conhecimento de experiências [1].

  Para engenharia de software, a principal definição sobre \emph{padrões} provém do livro Uma Linguagem de Padrões do arquiteto Christopher Alexander (1977) [50] onde ele define um \emph{padrão} como sendo uma regra de \emph{três partes} que expressa a \emph{relação} entre um certo \textbf{contexto}, um \textbf{problema} e uma \textbf{solução}. Martin Fowler apresenta uma definição mais simples que diz que \emph{um padrão é uma ideia que foi útil em algum contexto prático e provavelmente será útil em outros} [9]. 

  % A seguir, apresentamos a citação original completa:

  % \begin{quote}
  %   Cada padrão descreve um \emph{problema} no nosso \emph{ambiente} e o cerne de sua \emph{solução}, de tal forma que você possa usar essa solução mais de um milhão de vezes, sem nunca fazê-lo da mesma maneira. --- Christopher Alexander, Uma Linguagem de Padrões [50]
  % \end{quote}

  Inspirados por Alexander [50], Kent Beck e Ward Cunnigham fizeram alguns experimentos do uso de padrões na área de desenvolvimento de software e apresentaram estes resultados na OOPSLA em 1987. E, apoiando-se na definição de padrões de Alexander, Design Pattern - GoF (1994) foi o primeiro livro sobre padrões de projeto de software a ser lançado, documentando X padrões. 

  Para se documentar um padrão, é comum seguir um formato específico. O formato indica onde e como cada aspecto como problema, contexto ou solução será encontrado. Alguns formatos incluem uma série de outros elementos além destes três bases de todos padrão. Ao longo dos anos, alguns formatos foram se destacando, a Figura X.X mostra alguns principais formatos de padrões. 

  % Em seguida, Padrões de Software: Contos da Comunidade de Software (1996) 


\subsection{Anti-Padrões}

  Um anti-padrão é uma resposta comum a um problema recorrente que geralmente é ineficaz e corre o risco de ser altamente contraproducente. O termo foi cunhado por Andrew Koenig em um artigo publicado em 1995, inspirado pelo livro GoF [??]. 

  O termo se popularizou 3 anos após, em 1998 com o livro Antipatterns [?]. Segundo o livro, para diferenciar um anti-padrão de um mal hábito, má prática ou ideia ruim um anti-padrão deve apresentar dois elementos: 1) um processo, estrutura ou padrão de ação comumente usado que, apesar de inicialmente parecer ser uma resposta adequada e efetiva a um problema, tem mais consequências ruins do que as boas, 2) existe outra solução que é documentada, repetitiva e provada ser eficaz.

  É muito comum ver o termo anti-padrão ser equivocadamente usado para indicar mau cheiro de código pois ambos tratam de práticas que influenciam negativamente a manutenibilidade do software. O equívoco ocorre pois, primeiro para se tornar um anti-padrão em algum momento o mesmo deve ter sido considerado um padrão, e segundo, deve-se apresentar os dois elementos mencionados no livro Antippaterns. Muitos dos trabalhos relacionados a esta pesquisa cometeram este equívoco.


\section{Maus Cheiros de Código}

  \epigraph{``Se cheirar mau, troque-o."}{--- \textup{Citação da avó Beck no Livro Refactoring \cite{Webster:95}}}

  Podemos entender um mau cheiro de código como uma percepção empírica de que algo não está certo no software, percepção semelhante o dito popular ``Algo não cheira bem!'' quando uma pessoa está desconfiada de que há um problema em dada situação.

  Um dos primeiros livro a usar o \emph{conceito} de mau cheiro de código foi o livro de Webster (1995) \cite{Webster:95} através do termo \emph{``armadilha''}. No livro são apresentadas 82 \emph{armadilhas} no Desenvolvimento Orientado a Objetos originadas da experiência do autor. Longos métodos e complexidade excessiva por exemplo são definidos na \emph{armadilha} \textit{Letting objects Become Bloated} \cite[p.~180]{Webster:95}. 

  Apesar do conceito já permear em livros e publicações sobre desenvolvimento de software desde o começo da década de 90, o termo só se popularizou após o livro \textit{Refatoração: Aperfeiçoando o Projeto de Código Existente} (Fowler, M 1999) \cite{Refactoring:99}. Refatoração, segundo Fowler, é o ato de ``\emph{alterarmos o código sem alterar seu comportamento com o objetivo de torná-lo mais fácil de ser entendido e menos custoso de ser modificado}''. No livro são apresentadas diversas técnicas de  refatoração. O termo mau cheiro de código é usado para explicar ao leitor o \emph{``quando''} uma refatoração deve ser aplicada. Segundo o livro, \textbf{\emph{``mau cheiro de código são indicações de que existe um problema que pode ser resolvido por meio de uma refatoração''}}. Essas indicações provém do conhecimento empírico de desenvolvedores experientes, que ao longo dos anos, após trabalharem em diversos códigos bons e ruins, são capazes de listar características que podem indicar se um trecho de código é problemático. 

  Em uma postagem em seu site oficial em 2006 \cite{CodeSmell:06}, Fowler afrouxou um pouco mais a definição do termo dizendo que \emph{``mau cheiro de código são indicações superficiais que geralmente corresponde a um problema mais profundo no sistema''}.

  No livro são apresentados 22 maus cheiros e mais de 70 técnicas de refatoração. \textit{Código Duplicado} \cite[p.~63]{Refactoring:99} é um exemplo de mau cheiro que trata de problemas comuns que podem resultar na duplicação de código, por exemplo, ter a mesma expressão em dois métodos da mesma classe ou em duas subclasses irmãs. Para resolver este mau cheiro é indicada a refatoração \textit{Extrair Método} \cite[p.~89]{Refactoring:99}, ou seja, extrair a expressão duplicada para um novo método e substituí-lo nos lugares onde a expressão era usada. 

  Nos anos seguintes o termo mau cheiro se tornou frequente em livros \cite{CleanCode:08, Refactoring:14} e pesquisas acadêmicas. No livro \textit{Clean Code} (Martin, R 2008) \cite{CleanCode:08}, que se tornou muito popular entre desenvolvedores de software, são definidos novos maus cheiros além de citar alguns já apresentados por Fowler \cite{Refactoring:99}. Ele se apoia na definição de Fowler para explicar o conceito de mau cheiro.


% \subsection{Definindo Novos Maus Cheiros}

%   Tão importante quanto saber o que é um mau cheiro é entender como identificá-lo, validá-lo e documentá-lo. Nas últimas 3 décadas este tema veem despertando a curiosidade de diversos pesquisadores ao redor do mundo.

%   É possível perceber que a identificação parte de coleta de dados empíricos, por meio de questionários e entrevistas.  

\subsection{Formato dos Maus Cheiros}

  Os primeiros maus cheiros definidos vieram em formato textual e diferente do que vimos com padrões, não encontramos referências formais sobre como documentar adequadamente um mau cheiro. 

  Fowler \cite{Refactoring:99} por exemplo, se utiliza de \textit{título} e um \textit{texto explicativo}. No \textit{texto explicativo}, é possível encontrarmos informações sobre contexto, exemplos de problemas comuns e possíveis refatorações, dentre as listadas no livro, que resolveriam o mau cheiro. A seguir, temos o mau cheiro \textit{Código Duplicado} \cite[p.~71]{Refactoring:99}. O \textit{título} do mau cheiro indica o contexto por ele tratado. No parágrafo (1) podemos observar uma breve resumo do que faz cheirar mal e uma possível refatoração. Nos parágrafos seguintes (2-4) são apresentadas em mais detalhes situações comuns que podem indicar a presença do mau cheiro. \\

  \begin{square}
    \small
    \textbf{Código Duplicado}

    O número um no \textit{ranking} dos cheiros é o código duplicado. Se você vir o mesmo código em mais de um lugar, pode ter certeza de que seu programa será melhor se você encontrar uma maneira de unificá-los (1). 

    O problema mais simples de código duplicado é quando você tem a mesma expressão em dois métodos da mesma classe. Tudo o que você tem que fazer então é utilizar o \textit{Extrair Método} e chamar o código de ambos os lugares (2). 

    Outro problema de duplicação comum é quando você tem a mesma expressão em duas subclasses irmãs. Você pode eliminar essa duplicação usando \textit{Extrair Método} em ambas as classes e então \textit{Subir Método na Hierarquia}. Se o código for similar mas não o mesmo, você precisa usar \textit{Extrair Método} para separar as partes semelhantes daquelas diferentes. Você pode então descobrir que pode usar \textit{Criar um Método Padrão}. Se os métodos fazem a mesma coisa com um algoritmo diferente, você pode escolher o mais claro deles e usar \textit{Substituir o Algoritmo} (3).

    Se você tem código duplicado em duas classes não relacionadas, considere usar \textit{Extrair Classe} em uma classe e então usar o novo componente na outra. Uma outra possibilidade é de que o método realmente pertença a apenas uma das classes e deva ser chamado pela outra ou que o método pertença a uma terceira classe que deva ser referida por ambas as classes originais. Você tem que decidir onde o método faz mais sentido e garantir que ele esteja lá e em mais nenhum lugar (4).
  \end{square}


  Martin \cite{CleanCode:08} usa a mesma estrutura usada por Fowler e adiciona a ela uma \textit{sigla}. O \textit{texto explicativo} é apresentado em parágrafo único e é possível encontrar contexto, alguns exemplos de problemas comuns e exemplos de código, sendo que alguns maus cheiros apresentam todas essas informações ou apenas uma combinação delas. O \textit{título} usado por Martin aponta de certa forma o problema (o uso de convenção durante o desenvolvimento) e a solução (sempre que possível, preferir o uso de estruturas acima da convenção). 

  A seguir temos o mau cheiro \textit{G27: Estrutura acima de convenção} \cite[p.~301]{CleanCode:08}. No \textit{texto explicativo} em parágrafo único, podemos observar em orações a mesma estrutura que vimos no mau cheiro anterior, porém em parágrafos. Na oração (1) temos algo relacionado ao que faz cheirar mal, na oração (2) uma possível refatoração, na (3) é dado um exemplo e na (4) é indicado o problema resultante de se basear em convenção. \\

  \begin{square}
    \small
    \textbf{G27: Estrutura acima de convenção}

    Insista para que as decisões do projeto baseiem-se em estrutura acima de convenção (1). Convenções de nomenclaturas são boas, mas são inferiores a estruturas, que forçam um certo cumprimento (2). Por exemplo, \texttt{switch/case} com enumerações bem nomeadas são inferiores a classes base com métodos abstratos (3). Ninguém é obrigado a implementar a estrutura \texttt{switch/case} da mesma forma o tempo todo; mas as classes bases obrigam a implementação de todos os métodos abstratos das classes concretas (4).
  \end{square}

  Em pesquisas que definem novos maus cheiros, observamos um formato similar aos mencionados porém, adicionado uma estratégia de detecção, com foco em automatizar a identificação do mau cheiro \cite{MvcSmells:16, CSSCodeSmell}. Estas estratégias comumente se baseiam em métricas de software já existentes, como as métricas CK \todo{ref}.

\subsection{Formato Adotado}

% Se não for ter esta seção não faz nem sentido comentar sobre formato










% \subsection{Boas Práticas vs Padrões/Anti-Padrões vs Maus Cheiros de Código}

% Para entender melhor o que seria um mau cheiro e sua relação com padrões, antipadrões e práticas, pense no seguinte cenário: você na rua observa um homem correndo com uma bolsa feminina e uma mulher correndo atrás dele. Este cenário facilmente pode se encaixar num contexto de um homem que rouba a bolsa de uma mulher, e por padrão, ao vermos uma situação como esta, provavelmente devemos chamar a polícia. Mas este mesmo cenário pode representar um casal com pressa de pegar um ônibus ou táxi por exemplo, e neste contexto, não precisamos fazer nada.

% Podemos pensar que o cenário que descrevemos representa um mau cheiro de forma que, ele não é um problema, mas pode apontar para problemas mais profundos ou não, mas que certamente vale uma análise para chegar a essas conclusões. Veja que, se for identificado que é um roubo, podemos então aplicar um padrão: ``chamar a polícia''. Logo, um mau cheiro pode representar um \textbf{contexto} de um padrão (ou anti-padrão), sendo assim, pode ser que a aplicação do padrão o resolva. Entretanto, pode ser que não exista ainda nenhum padrão para resolver o mau cheiro, então uma solução terá de ser criada.

% Podemos dizer então que um padrão é a documentação formal de boas práticas.

% BIO
% =================================================================

% PRATICAS
% [1] https://dicionariodoaurelio.com/pratica
% [2] https://en.wikipedia.org/wiki/Best_practice #Critique
% [3] http://www.farrell-associates.com.au/Papers/Best%20Practice.pdf


% PADROES
% [1] mono ita 
% [2] https://en.oxforddictionaries.com/definition/pattern
% [9] FOWLER, M. Analysis Patterns: Reusable Object Models. Addison-Wesley Professional, 1996. 

% ANTI-PADROES
% [1]  Koenig, Andrew (March–April 1995). "Patterns and Antipatterns". Journal of Object-Oriented Programming. 8 (1): 46–48.; was later re-printed in the: Rising, Linda (1998). The patterns handbook: techniques, strategies, and applications. Cambridge, U.K.: Cambridge University Press. p. 387. ISBN 0-521-64818-1. "An antipattern is just like a pattern, except that instead of a solution it gives something that looks superficially like a solution, but isn't one."
% Buscar mais aqui https://en.wikipedia.org/wiki/Anti-pattern#Software_engineering




% QUALIDADE DE CÓDIGO
% [1] https://en.wikipedia.org/wiki/Software_quality#cite_note-34
% [2] https://www.iso.org/standard/35733.html