% -*- root: index.tex -*-
\section{Qualidade de Software}
\label{sec:software-quality}

Antes de falarmos sobre qualidade de software, é importante falarmos brevemente sobre qualidade. Há décadas, diversos autores e organizações vem trabalhando em suas próprias definições de qualidade. Segundo o ISO 9000 \cite{ISO9000:00} desenvolvido pela Organização Internacional de Normalização (\acl{ISO} - \acs{ISO}), qualidade é \emph{``o grau em que um conjunto de características inerentes a um produto, processo ou sistema cumpre os requisitos inicialmente estipulados para estes''}. Segundo Juran \cite{JuranQuality:1998}, um dos principais autores sobre o assunto, qualidade está relacionado ``as características dos produtos que atendem as necessidades dos clientes, e assim, proporcionam a satisfação do mesmo'' e a ``ausência de deficiências''. Stefan \cite[p~6]{StefanSoftwareQuality:13} também examinou diversas definições e identificou que na maioria delas é possível identificar uma mesma ideia central sobre qualidade: todas elas apontam para ``requisitos que precisam ser satisfeitos para ter qualidade''. 

% \emph{Qualidade de software} é uma área do conhecimento da engenharia de software que trata das características desejadas em um projeto de software, sejam elas funcionais, o quanto o software atende as necessidades de negócio, ou estruturais, o quão bem o software funciona. Diversas características são desejáveis em um software, dentre elas confiabilidade, eficiência e manutenibilidade. A área de conhecimento sobre qualidade de software nos serve justamente para definir conceitos que suportam a criação de práticas e ferramentas que visam aumentar a qualidade de softwares. Muitos estudos já mostraram que problemas de qualidade em software demandam altos custos a empresas. Desta forma, essa área do conhecimento orienta nossos esforços para melhorar a qualidade de projetos de software visando, dentre outras coisas, reduzir os custos.

% Muitas são as definições dadas ao termo qualidade de software. Segundo a norma ISO 9000 (versão 2000), ``qualidade é o grau em que um conjunto de características inerentes a um produto, processo ou sistema cumpre os requisitos inicialmente estipulados para estes''. Já Juran, um dos principais autores sobre o assunto, tem duas definições para qualidade ``a característica dos produtos que atendem as necessidades dos clientes, e, assim, proporcionar a satisfação do mesmo[2]'' e ``qualidade é a ausência de deficiências[2]''. 

\begin{table}[!htb]
\centering
\renewcommand*{\arraystretch}{1.5}
\caption[Modelos de qualidade de software baseados no modelo de decomposição hierárquica de Boehm et al. e McCall et al.]{Modelos de qualidade de software baseados no modelo de decomposição hierárquica de Boehm et al. \cite{Boehm:78} e McCall et al. \cite{McCall:77}.}
\footnotesize
\begin{tabular}{@{}p{4.5cm}p{11.5cm}@{}}
\toprule
\textbf{Nome do Modelo} & \textbf{Descrição} \\
\bottomrule
\acs{ISO}/\acs{IEC} 9126 & Teve sua primeira publicação em 1991, foi revisado em 2001 e em 2011 substituído pela \acs{ISO}/\acs{IEC} 25010, conhecida por \ac{SQuaRE}. Decompõe qualidade de software em 6 áreas: manutenibilidade, eficiência, portabilidade, confiabilidade, funcionalidade e usabilidade \cite{ISO9126:91}.\\
\acs{ISO}/\acs{IEC} 25010 (\acs{SQuaRE}) & Teve sua primeira publicação em 2005, revisado em 2011, quando passou a substituir a \acs{ISO}/\acs{IEC} 9126. Decompõe qualidade de software em 8 áreas: manutenibilidade, eficiência, portabilidade, confiabilidade, funcionalidade, usabilidade, compatibilidade e segurança \cite{ISO25010:11}.\\
\acs{CISQ} & Fundado em 2009 \cite{CISQAnnounce:09}, decompõe qualidade de software em 4 características: segurança, confiabilidade, desempenho/eficiência e manutenibilidade. Se baseia nas definições do \ac{SQuaRE} \cite{CISQ}.\\
% \acs{SWEBOK} \cite{SWEBOK:14} & Decompõe qualidade de software em 4 áreas e considera que qualidade está envolvido com as qualidades estáticas do software. \\
\acs{FURPS} & FURPS é um acrônimo para: Funcionalidade, Usabilidade, Confiabilidade (do inglês \textit{Reliability}), Desempenho (do inglês \textit{Performance}) e Suportabilidade \cite{ModelFURPS:87}. \\
\bottomrule
\end{tabular}
\label{tab:QualityModels}
\end{table}

As primeiras contribuições referente a qualidade em termos de software foram publicadas no fim da década de 70. Boehm et al. \cite{Boehm:78} e McCall et al. \cite{McCall:77} descrevem modelos de qualidade de software através de conceitos e subconceitos. Ambos se utilizaram de uma estratégia de decomposição hierárquica do conceito de qualidade em fatores como manutenibilidade e confiabilidade \cite[p~29-30]{StefanSoftwareQuality:13}. Com o tempo, diversas variações desse modelo começaram a surgir. A Tabela \ref{tab:QualityModels} apresenta algumas dessas variações e uma breve descrição da forma como qualidade de software foi decomposta. Entretanto, o grande valor do modelo de decomposição hierárquico foi a ideia de decompor qualidade até um nível em que seja possível medir e estimar~\cite{StefanSoftwareQuality:13}.

O padrão ISO/IEC 9126 é considerado ainda como principal referência para a definição de qualidade de software e a define como ``a capacidade do produto de software satisfazer as necessidades implícitas e explícitas quando usado em condições específicas'' \cite[p~10]{StefanSoftwareQuality:13}. O \acs{ISO}/\acs{IEC} 9126 subdivide qualidade de software em seis conceitos, cada qual contendo um conjunto de sub-conceitos, conforme apresentado na Figura \ref{fig:QualityCharacteristics}.

% Segundo o SWEBOK (\textit{Software Engineering Body of Knowledge}) qualidade de software pode se referir ``as características desejadas de produtos de software, a extensão em que um produto de software em particular possui essas características e aos processos, ferramentas e técnicas que são usadas para garantir essas características'' \cite[p.~174]{SWEBOK:14}.

% \todo{para embasar as truduções na imagem https://pt.wikipedia.org/wiki/Qualidade\_de\_software\#/media/File:Qualidade\_de\_Produto\_de\_Sistemas\_e\_Software.jpg}

Dentre os conceitos apresentados na Figura \ref{fig:QualityCharacteristics}, os mais relevantes nesta dissertação são \textbf{\small manutenibilidade}, pois é onde esta pesquisa está inserida, e \textbf{\small usabilidade} e \textbf{\small eficiência}, pois é o contexto onde encontramos alguns trabalhos relacionados sobre maus cheiros de código Android \cite{RemovingEnergySmells:12, 30QualitySmells:14}. Apresentamos uma breve descrição sobre cada um destes três conceitos a seguir. \\

\begin{figure}[!htb]
  \centering
  \includegraphics[width=1\textwidth]{caracteristicas-software-qualidade-pt.png}
  \caption[Características de Qualidade de Software segundo norma ISO/IEC 9126.]{Características de Qualidade de Software segundo norma ISO/IEC 9126 \cite{ISO9126:91}.}
  \label{fig:QualityCharacteristics}
\end{figure}


% \subsection{Funcionalidade} 
% A capacidade de um software prover funcionalidades que satisfaçam o usuário em suas necessidades declaradas e implícitas, dentro de um determinado contexto de uso. Seus sub-conceitos são: 
% \begin{itemize}
%   \item \emph{Adequação}, que mede o quanto o conjunto de funcionalidades é adequado às necessidades do usuário.
%   \item \emph{Acurácia} (ou precisão) representa a capacidade do software de fornecer resultados precisos ou com a precisão dentro do que foi acordado/solicitado.
%   \item \emph{Interoperabilidade} que trata da maneira como o software interage com outro(s) sistema(s) especificados.
%   \item \emph{Segurança} mede a capacidade do sistema de proteger as informações do usuário e fornecê-las apenas (e sempre) às pessoas autorizadas. Segurança também pode estar dirigida em, processar gerar e armazenar as informações.
%   \item \emph{Conformidade} trata da padronização, políticas e normas de um projeto.
% \end{itemize}

% \subsection{Confiabilidade}   
% O produto se mantém no nível de desempenho nas condições estabelecidas. Seus sub-conceitos são: 
% \begin{itemize}
%   \item \emph{Maturidade}, entendida como sendo a capacidade do software em evitar falhas decorrentes de defeitos no software.
%   \item \emph{Tolerância a Falhas} representando a capacidade do software em manter o funcionamento adequado mesmo quando ocorrem defeitos nele ou nas suas interfaces externas.
%   \item \emph{Recuperabilidade} que foca na capacidade de um software se recuperar após uma falha, restabelecendo seus níveis de desempenho e recuperando os seus dados.
%   \item \emph{Conformidade} tempo ou utilização de recursos.
% \end{itemize}

\noindent \textbf{\small Manutenibilidade} A capacidade (ou facilidade) do produto de software ser modificado, incluindo tanto as melhorias ou extensões de funcionalidade quanto as correções de defeitos, falhas ou erros. Seus sub-conceitos são:
\begin{itemize}
  \itemsep0em 
  \item \emph{Analisabilidade} Facilidade em se diagnosticar eventuais problemas e identificar as causas das deficiências ou falhas.
  \item \emph{Modificabilidade} Facilidade com que o comportamento do software pode ser modificado.
  \item \emph{Estabilidade} Capacidade do software de evitar efeitos colaterais decorrentes de modificações introduzidas.
  \item \emph{Testabilidade} Capacidade de se testar o sistema modificado, tanto quanto as novas funcionalidades quanto as não afetadas diretamente pela modificação.
\end{itemize}

\noindent \textbf{\small Usabilidade}   
A capacidade do produto de software ser compreendido, seu funcionamento aprendido, ser operado e ser atraente ao usuário. Seus sub-conceitos são:
\begin{itemize}
  \itemsep0em 
  \item \emph{Inteligibilidade} Facilidade com que o usuário pode compreender as suas funcionalidades e avaliar se o mesmo pode ser usado para satisfazer as suas necessidades específicas.
  \item \emph{Apreensibilidade} Facilidade de aprendizado do sistema para os seus potenciais usuários.
  \item \emph{Operacionalidade} Como o produto facilita a sua operação por parte do usuário, incluindo a maneira como ele tolera erros de operação.
  \item \emph{Proteção frente a erros de usuários} Como produto consegue prevenir erros dos usuários.
  \item \emph{Atratividade} Envolve características que possam atrair um potencial usuário para o sistema, o que pode incluir desde a adequação das informações prestadas para o usuário até os requintes visuais utilizados na sua interface gráfica.
  \item \textbf{\small Acessibilidade} Prática inclusiva de fazer softwares que possam ser utilizados por todas as pessoas que tenham deficiência ou não. Quando os softwares são corretamente concebidos, desenvolvidos e editados, todos os usuários podem ter igual acesso à informação e funcionalidades.  
\end{itemize}

\noindent \textbf{\small Eficiência}   
O tempo de execução e os recursos envolvidos são compatíveis com o nível de desempenho do software. Seus sub-conceitos são:
\begin{itemize}
  \itemsep0em 
  \item \emph{Comportamento em Relação ao Tempo} Avalia se os tempos de resposta (ou de processamento) estão dentro das especificações.
  \item \emph{Utilização de Recursos} Mede tanto os recursos consumidos quanto a capacidade do sistema em utilizar os recursos disponíveis.
\end{itemize}

% \subsection{Portabilidade}   
% A capacidade do sistema ser transferido de um ambiente para outro. Seus sub-conceitos são: 
% \begin{itemize}
%   \item \emph{Adaptabilidade}, representando a capacidade do software se adaptar a diferentes ambientes sem a necessidade de ações adicionais (configurações). 
%   \item \emph{Instalabilidade} identifica a facilidade com que pode se instalar o sistema em um novo ambiente. 
%   \item \emph{Coexistência} mede o quão facilmente um software convive com outros instalados no mesmo ambiente. 
%   \item \emph{Substituibilidade} representa a capacidade que o sistema tem de substituir outro sistema especificado, em um contexto de uso e ambiente específicos. Este atributo interage tanto com adaptabilidade quanto com instalabilidade. 
% \end{itemize}

Esta pesquisa está inserida no contexto de \emph{manutenibilidade}, mais especificamente \emph{analisabilidade} e \emph{modificabilidade}, pois, conforme descrito na Seção \ref{sec:back-maus-cheiros}, maus cheiros de código visam apontar trechos de códigos possivelmente problemáticos que podem se beneficiar de refatorações, melhorando a manutenibilidade do software. 

Muito embora tenhamos ciência que investir em qualidade pode reduzir os custos de um projeto, aumentar a satisfação dos usuários e desenvolvedores, qualidade de software costuma ser esquecida ou deixada em segundo plano\footnote{http://www.ifsq.org/resources/level-2/booklet.pdf}. Frases como ``depois eu testo'' ou ``depois eu refatoro'' são comuns no dia a dia de desenvolvimento. Manutenibilidade está relacionada às ``necessidades implícitas do software'' \cite{ISO9126:91}. 

Focado nesse conceito, ao longo dos últimos anos, diversas boas práticas de software vêm sendo documentadas objetivando servir de ferramenta a desenvolvedores menos experientes para aumentar a qualidade do software. Por exemplo, os padrões de projeto da Gangue dos Quatro (\textit{Gang of Four} - GoF) documentam as \emph{melhores soluções para problemas comuns} originadas a partir do conhecimento empírico de desenvolvedores de software experientes. Em contrapartida, anti-padrões são padrões antes recomendados que passaram a ser evitados, pois percebeu-se que os problemas em usá-los superavam os benefícios \cite{AntiPatterns:98}. Um dos mais notáveis exemplos de anti-padrão é o \textit{Singleton}, que visa limitar a instanciação de uma classe em um único objeto \cite{GoF:95}. 

% Na Seção \ref{sec:back-maus-cheiros} abordaremos \emph{maus cheiros}, que apontam sintomas que podem indicar um problema mais profundo no software. 
É relevante destacar que, enquanto que padrões de projetos são conceitos que indicam \textit{``o que fazer''}, anti-padrões e maus cheiros são conceitos que servem como alertas sobre \textit{``o que não fazer''} ou sobre \textit{``o que evitar''}. Esse conjunto de documentos são comumente generalizados entre os desenvolvedores simplesmente pelo termo \emph{boas práticas de software}~\cite{CodeComplete:04}. 

% \todo{breve desc de singleton}

% citações diretas sobre vários autores com relação a importância de qualidade
% A importância de qualidade de software tem se reforçado ano após anos e podemos ver isso em resultados de pesquisas e no dia a dia quando enfrentamos problemas relativos a ela. Os erros de construção detectados no teste do sistema custam 10 vezes mais para consertar do que na fase de construção. Os erros de construção detectados postrelease custaram 10-25 vezes mais para consertar do que na fase de construção (Fagan 1976; Dunn 1984; Boehm \& Turner 2004, Shull et al., 2002). O Laboratório de Engenharia de Software da NASA descobriu que a leitura de código detectou 3,3 defeitos por hora de esforço: o teste detectou cerca de 1,8 erros por hora. A leitura do código encontrou 20 a 60\% mais erros durante a vida do projeto do que os vários tipos de testes (Card 1987). 50\% a 80\% das declarações ``if'' simples deveriam ter tido um ``else'' cláusula (Elshoff, 1976). Poucas pessoas podem entender mais de 3 ou 4 níveis de ifs aninhados (Yourdon 1986; Ledgard \& Tauer, 1987). A complexidade do fluxo de controle tem sido correlacionada com baixa confiabilidade e erros freqüentes (McCabe 1976, Shen et al., 1985, Ward, 1989). A remoção de defeitos de software é o mais caro e demorado forma de trabalho para software (Jones 2000). \todo{http://www.ifsq.org/resources/level-2/booklet.pdf}

% É comum no dia a dia de desenvolvimento de software ouvirmos o termo \textit{boas práticas} como uma generalização para se referir a termos como por exemplo: padrões de projetos, anti-padrões e \emph{maus cheiros de código} que encapsulam ideias sobre como criar códigos com \emph{mais qualidade}. Apesar dessa comum generalização, cada um desses termos possui um significado distinto. 

% Para melhor entendimento sobre o contexto desta pesquisa, nesta seção apresentamos a definição dos principais termos que se confundem: boas práticas, padrões de projeto, anti-padrões e maus cheiros de código. Ao final, concluímos com uma reflexão das semelhanças e diferenças entre eles.

\section{Boas Práticas de Software}
\label{sec:good-practices}

% Segundo o dicionário Aurélio \cite{AurelioPratica}, \textit{prática} significa ``maneira habitual de proceder''. O termo não é restrito a uma área do conhecimento, e a depender da área em que é usado, englobará um conjunto diferente de maneiras habituais. 

No desenvolvimento de software, \emph{boas práticas de código} são um conjunto de regras que a comunidade de desenvolvimento de software aprendeu ao longo do tempo, e que pode ajudar a melhorar a qualidade do software \cite{CodeComplete:04}. A seguir introduzimos conceitos de boas práticas: padrões de projetos, anti-padrões e \emph{maus cheiros de código}.


\subsection{Padrões de Projeto}

  
  % \epigraph{\emph{\textbf{Padrão:} Algo que serve como modelo. Um exemplo para os outros seguirem.}}{--- \textup{Dicionário Oxford [2]}}

  \epigraph{\emph{``Cada padrão descreve um \textbf{{\small problema}} no nosso \textbf{{\small ambiente}} e o cerne de sua \textbf{{\small solução}}, de tal forma que você possa usar essa solução mais de um milhão de vezes, sem nunca fazê-lo da mesma maneira.''}} {\footnotesize -- Christopher Alexander, Uma Linguagem de Padrões \cite{PatternAlexander:77}}



  Não podemos falar sobre \emph{padrões de projetos} sem antes falarmos sobre \emph{padrões}. Segundo o dicionário Oxford um padrão é \emph{algo que serve como modelo, um exemplo para os outros seguirem} \cite{PetternByOxford}. Padrões não são invenção de algo novo, são uma forma de organizar o conhecimento proveniente de experiências \cite{PadroesAgeisSuelen:11}.

  Para engenharia de software, a principal definição sobre ``padrões'' provém do livro Uma Linguagem de Padrões do arquiteto Christopher Alexander (1977) \cite{PatternAlexander:77} onde ele define um padrão como sendo uma regra de três partes que expressa ``a relação entre um certo \textbf{contexto}, um \textbf{problema} e uma \textbf{solução}''. Martin Fowler apresenta uma definição mais simples que diz que ``um padrão é uma ideia que foi útil em algum contexto prático e provavelmente será útil em outros'' \cite{AnalysysPattern:97}. 

  Inspirados por Alexander \cite{PatternAlexander:77}, Kent Beck e Ward Cunnigham fizeram alguns experimentos do uso de padrões na área de desenvolvimento de software e apresentaram os resultados na OOPSLA em 1987. Apoiando-se na definição de padrões de Alexander \cite{PatternAlexander:77}, Design Patterns - GoF (1994) foi o primeiro livro sobre padrões de projeto de software a ser lançado, documentando 23 padrões de projetos. 
  
  Para se documentar um padrão, é comum seguir um formato específico. O formato indica onde e como cada aspecto, como problema, contexto ou solução, será encontrado. Alguns formatos incluem uma série de outras informações além destas três. Ao longo dos anos, alguns formatos foram se destacando. A Figura \ref{fig:formato-padroes} apresenta a tradução de um gráfico criado por Joshua Kerievsky \cite{PatternsFormats} contendo quatro formatos existentes de se escrever padrões. Os formatos são nomeados como Portland, Coplien, \ac{GoF} e Alexandrino, e foram posicionadas no gráfico de acordo com seu nível de maturidade e clareza.

  \begin{figure}[!htb]
    \centering
    \includegraphics[width=.7\textwidth]{formato-padroes.png}
    \caption[Formatos de padrões de acordo com seu nível de maturidade e clareza segundo Joshua Kerievsky.]{Formatos de padrões de acordo com seu nível de maturidade e clareza segundo Joshua Kerievsky~\cite{PatternsFormats}.}
    \label{fig:formato-padroes}
  \end{figure}

  É possível observar na Figura \ref{fig:formato-padroes} que quanto mais para cima e mais a direita do gráfico, mais claro e maduro é o formato do padrão. Sendo assim, o mais claro e maduro é o formato Alexandrino seguido por Gof, Coplien e por último Portland.

  \newpage

  % Um mau cheiro se difere de padrões pois o primeiro, como vimos.... já o mau cheiro...

  % Em seguida, Padrões de Software: Contos da Comunidade de Software (1996) 


\subsection{Anti-Padrões}
\label{sec:anti-patterns}
  \epigraph{\emph{``Um anti-padrão é como um padrão, exceto que em vez de uma solução, ele dá algo que parece superficialmente como uma solução, mas não é.''}} {\footnotesize -- Andrew Koenig, O Manual de Padrões: Técnicas, Estratégias e Aplicações \cite{KoenigPatterns:98}}

  Um anti-padrão é uma resposta comumente usada para um problema recorrente que geralmente é ineficaz e corre o risco de ser altamente contraproducente. O termo foi cunhado por Andrew Koenig em um artigo publicado em 1995 \cite{KoenigPatterns:98}, inspirado pelo livro GoF \cite{GoF:95}. 

  O termo se popularizou três anos após, no livro de Brown (1998) \cite{AntiPatterns:98}. Segundo Brown \cite{AntiPatterns:98}, para diferenciar um anti-padrão de um mau hábito, má prática ou ideia ruim 1) existe um processo, estrutura ou padrão de ação comumente usado que, apesar de inicialmente parecer ser uma resposta adequada e efetiva a um problema, tem mais consequências ruins do que as boas, 2) existe outra solução que é documentada, repetitiva e provada ser eficaz.

  É muito comum ver o termo anti-padrão ser equivocadamente usado para indicar mau cheiro de código. O equívoco ocorre geralmente por ambos tratarem de práticas que influenciam negativamente a manutenibilidade do software. Entretanto, anti-padrões se diferem de maus cheiros pois maus cheiros são sintomas que podem ou não indicar um problema mais profundo no código enquanto que um anti-padrão é uma solução com passos bem definidos para um problema específico, porém uma solução que deixou de ser recomendada.

% \subsection{Débito Técnico}

\section{Maus Cheiros de Código}
\label{sec:back-maus-cheiros}

  % \todo{``smells are certain structures in the code that indicate violation of fundamental design principles and negatively impact design quality.'' \cite[p.~258]{Refactoring:14}}

  % \todo{``Bad code smells can be an indicator of factors that contribute to technical debt'' \cite{StartsBadSmells:15}}

  % \todo{Code smells are usually not bugs-they are not technically incorrect and do not currently prevent the program from functioning. Instead, they indicate weaknesses in design that may be slowing down development or increasing the risk of bugs or failures in the future.}

  % \epigraph{``Se cheirar mau, troque-o.''}{--- \textup{Citação da avó Beck no Livro Refatoração \cite{Webster:95}}}

  \epigraph{\emph{``Maus cheiros são certas estruturas no código que indicam a violação de princípios fundamentais de \textit{design} e impactam negativamente a qualidade do projeto.''}}{\footnotesize -- \textup{Refactoring for Software Design Smells: Managing Rechnical Debt \cite{Refactoring:14}}}
  
  Um mau cheiro de código é uma sugestão de que algo não está certo no código, semelhante ao dito popular ``Algo não cheira bem!'' quando alguém desconfia de que há algum problema em dada situação. Segundo Fowler \cite{Refactoring:14}, maus cheiros \emph{``são indicações de que existe um problema que pode ser resolvido por meio de uma refatoração''}. Do ponto de vista de qualidade de software, \emph{``são certas estruturas no código que indicam a violação de princípios fundamentais de \textit{design} e impactam negativamente a qualidade do projeto.''} \cite[p.~258]{Refactoring:14}. 

  Entretanto, maus cheiros não são erros --- eles não estão tecnicamente incorretos e não impedem o funcionamento do software. Em vez disso, eles indicam deficiências no código que podem dificultar a manutenibilidade do software e aumentar o risco de erros ou falhas no futuro \cite{Khomh:2009:ESI:1685994.1686210, Sjoberg_Quantifying_2013, Yamashita6405287, Yamashita:2013:EII:2486788.2486878}.

  \textit{Pitfalls of Object-Oriented Development} \cite{Webster:95}, escrito por Webster em 1995, foi um dos primeiros livros a usar o conceito de maus cheiros através do termo \emph{armadilha}. No livro são apresentadas 82 armadilhas no desenvolvimento orientado a objetos originadas da experiência do autor. Longos métodos e complexidade excessiva, por exemplo, são definidos na armadilha \textit{Letting objects Become Bloated} \cite[p.~180]{Webster:95}. Há indícios informais de que o termo ``maus cheiros de código'' foi cunhado em meados da década de 90 por Kent Beck \cite{WikiCodeSmell, WardsWikiCodeSmell}. Apesar do conceito já permear em livros e publicações sobre desenvolvimento de software desde o começo da década de 90, o termo só se popularizou após o livro \textit{Refatoração: Aperfeiçoando o Projeto de Código Existente} (Fowler, M. 1999) \cite{Refactoring:99}. 

  No livro são apresentados 22 maus cheiros e mais de 70 técnicas de refatoração. \textit{Código Duplicado} \cite[p.~63]{Refactoring:99} é um exemplo de mau cheiro que trata de problemas comuns que podem resultar na duplicação de código como por exemplo, ter a mesma expressão em dois métodos da mesma classe ou em duas subclasses irmãs. Para resolver este mau cheiro é indicada a refatoração \textit{Extrair Método} \cite[p.~89]{Refactoring:99}, ou seja, extrair a expressão duplicada para um novo método e substituí-lo nos lugares onde a expressão era usada. 

  % Refatoração, segundo Fowler, é o ato de ``\emph{alterarmos o código sem alterar seu comportamento com o objetivo de torná-lo mais fácil de ser entendido e menos custoso de ser modificado}''. No livro são apresentadas diversas técnicas de  refatoração. 

  % O termo mau cheiro de código é usado para explicar ao leitor o \emph{``quando''} uma refatoração deve ser aplicada. Segundo o livro, \textbf{\emph{``mau cheiro de código são indicações de que existe um problema que pode ser resolvido por meio de uma refatoração''}}. 

  Maus cheiros provêm do profundo conhecimento e experiências de desenvolvedores experientes que ao longo dos anos desenvolveram a ``intuição'' para o bom \textit{design} possibilitando-os olhar para um \textit{design} ou código e obter imediatamente uma ``intuição'' sobre sua qualidade, sem ter que dar ``argumentos logicamente detalhados'' sobre o porquê de sua conclusão \cite{WardsWikiCodeSmell}. Ou seja, é por natureza subjetivo, baseado em opiniões e experiências \cite{JavascriptSmells, JavaQADetectingSmells:02}. No livro \textit{Clean Code} (Martin, R. 2008) \cite{CleanCode:08}, que se tornou muito popular entre desenvolvedores de software, são definidos novos maus cheiros além de citar alguns já apresentados por Fowler \cite{Refactoring:99}. O autor se apoia na definição de Fowler para explicar o conceito de mau cheiro.

  % Em uma postagem em seu site oficial em 2006 \cite{CodeSmell:06}, Fowler afrouxou um pouco mais a definição do termo dizendo que \emph{``mau cheiro de código são indicações superficiais que geralmente corresponde a um problema mais profundo no sistema''}.

  % Nos anos seguintes o termo mau cheiro se tornou frequente em livros \cite{CleanCode:08, Refactoring:14} e pesquisas acadêmicas. No livro \textit{Clean Code} (Martin, R. 2008) \cite{CleanCode:08}, que se tornou muito popular entre desenvolvedores de software, são definidos novos maus cheiros além de citar alguns já apresentados por Fowler \cite{Refactoring:99}. Ele se apoia na definição de Fowler para explicar o conceito de mau cheiro.


% \subsection{Definindo Novos Maus Cheiros}

%   Tão importante quanto saber o que é um mau cheiro é entender como identificá-lo, validá-lo e documentá-lo. Nas últimas 3 décadas este tema veem despertando a curiosidade de diversos pesquisadores ao redor do mundo.

%   É possível perceber que a identificação parte de coleta de dados empíricos, por meio de questionários e entrevistas.  

\subsection{Formato dos Maus Cheiros}

  Os primeiros maus cheiros definidos vieram em formato textual e diferente do que vimos com padrões, não encontramos referências formais sobre como documentar adequadamente um mau cheiro. 

  Fowler \cite{Refactoring:99} por exemplo, se utiliza de \textit{título} e um \textit{texto explicativo}. No \textit{texto explicativo}, é possível encontrar informações sobre contexto, exemplos de problemas comuns e possíveis refatorações que resolveriam o mau cheiro. Na caixa a seguir, exemplificamos o mau cheiro \textit{Código Duplicado} \cite[p.~71]{Refactoring:99}. O \textit{título} do mau cheiro indica o contexto por ele tratado. No parágrafo (1) podemos observar um breve resumo do que faz ``cheirar mal'' e uma possível refatoração. Nos parágrafos seguintes (2-4) são apresentadas em mais detalhes situações comuns que podem indicar a presença do mau cheiro. \\

  \begin{square}
    \small
    \textbf{Código Duplicado}

    O número um no \textit{ranking} dos cheiros é o código duplicado. Se você vir o mesmo código em mais de um lugar, pode ter certeza de que seu programa será melhor se você encontrar uma maneira de unificá-los (1). 

    O problema mais simples de código duplicado é quando você tem a mesma expressão em dois métodos da mesma classe. Tudo o que você tem que fazer então é utilizar o \textit{Extrair Método} e chamar o código de ambos os lugares (2). 

    Outro problema de duplicação comum é quando você tem a mesma expressão em duas subclasses irmãs. Você pode eliminar essa duplicação usando \textit{Extrair Método} em ambas as classes e então \textit{Subir Método na Hierarquia}. Se o código for similar mas não o mesmo, você precisa usar \textit{Extrair Método} para separar as partes semelhantes daquelas diferentes. Você pode então descobrir que pode usar \textit{Criar um Método Padrão}. Se os métodos fazem a mesma coisa com um algoritmo diferente, você pode escolher o mais claro deles e usar \textit{Substituir o Algoritmo} (3).

    Se você tem código duplicado em duas classes não relacionadas, considere usar \textit{Extrair Classe} em uma classe e então usar o novo componente na outra. Uma outra possibilidade é de que o método realmente pertença a apenas uma das classes e deva ser chamado pela outra ou que o método pertença a uma terceira classe que deva ser referida por ambas as classes originais. Você tem que decidir onde o método faz mais sentido e garantir que ele esteja lá e em mais nenhum lugar (4).
  \end{square}


  Martin \cite{CleanCode:08} usa a mesma estrutura usada por Fowler e adiciona a ela uma \textit{sigla}. O \textit{texto explicativo} é apresentado em parágrafo único e é possível encontrar contexto, alguns exemplos de problemas comuns e exemplos de código, sendo que alguns maus cheiros apresentam todas essas informações ou apenas uma combinação delas. O \textit{título} usado por Martin aponta de certa forma o problema (o uso de convenção durante o desenvolvimento) e a solução (sempre que possível, preferir o uso de estruturas acima da convenção). 

  A seguir temos o mau cheiro \textit{G27: Estrutura acima de convenção} \cite[p.~301]{CleanCode:08}. No \textit{texto explicativo} em parágrafo único, podemos observar em orações a mesma estrutura que vimos no mau cheiro anterior, porém em parágrafos. Na oração (1) temos algo relacionado ao que faz cheirar mal, na oração (2) uma possível refatoração, na (3) é dado um exemplo e na (4) é indicado o problema resultante de se basear em convenção. \\

  \begin{square}
    \small
    \textbf{G27: Estrutura acima de convenção}

    Insista para que as decisões do projeto baseiem-se em estrutura acima de convenção (1). Convenções de nomenclaturas são boas, mas são inferiores a estruturas, que forçam um certo cumprimento (2). Por exemplo, \texttt{switch/case} com enumerações bem nomeadas são inferiores a classes base com métodos abstratos (3). Ninguém é obrigado a implementar a estrutura \texttt{switch/case} da mesma forma o tempo todo; mas as classes bases obrigam a implementação de todos os métodos abstratos das classes concretas (4).
  \end{square}

  Em pesquisas que definem novos maus cheiros, observamos um formato similar aos mencionados porém, adicionado uma estratégia de detecção, com foco em automatizar a identificação do mau cheiro \cite{MvcSmells:16, CSSCodeSmell}. 

  % Estas estratégias comumente se baseiam em métricas de software já existentes, como as métricas CK \todo{ref}.



% \subsection{Formato Adotado}

% Como apresentado na seção anterior, são muitos os formatos usados na literatura e em pesquisas para se catalogar maus cheiros. Com a evolução de pesquisas sobre o assunto, cada vez mais é possível refiná-los criando heurísticas, ferramentas automatizadas de detecção e inclusive propondo soluções padrões. 

% Entretanto, este trabalho é uma pesquisa exploratória sobre maus cheiros relacionados a manutenibilidade da camada de apresentação Android dando os primeiros passos nesse sentido, portanto optamos pelo formato mais simples de mau cheiro, contendo:

% \begin{itemize}
%   \item \emph{título}, 

%   \item \emph{descrição dos sintomas},  
%   % \item e algumas \emph{frases de participantes} que nos levaram a conclusão dos sintomas definidos.
% \end{itemize}
 

% Esta escolha de focar pelo formato textual, sem a definição de heurísticas, automatização de ferramentas e propôr soluções se dá pois consideramos cada um desses outros passos também muito complexos, sendo este primeiro passo muito 

% \todo{ler melhor este parágrafo}
% Acreditamos que essas definições iniciais são passos importantes e poderão servir de base para pesquisas futuras buscarem por heurísticas, automatizações de ferramentas de detecção e, inclusive propôr soluções para estes e outros maus cheiros Android.

% Se não for ter esta seção não faz nem sentido comentar sobre formato





% \subsection{Boas Práticas vs Padrões/Anti-Padrões vs Maus Cheiros de Código}

% Para entender melhor o que seria um mau cheiro e sua relação com padrões, antipadrões e práticas, pense no seguinte cenário: você na rua observa um homem correndo com uma bolsa feminina e uma mulher correndo atrás dele. Este cenário facilmente pode se encaixar num contexto de um homem que rouba a bolsa de uma mulher, e por padrão, ao vermos uma situação como esta, provavelmente devemos chamar a polícia. Mas este mesmo cenário pode representar um casal com pressa de pegar um ônibus ou táxi por exemplo, e neste contexto, não precisamos fazer nada.



% Podemos pensar que o cenário que descrevemos representa um mau cheiro de forma que, ele não é um problema, mas pode apontar para problemas mais profundos ou não, mas que certamente vale uma análise para chegar a essas conclusões. Veja que, se for identificado que é um roubo, podemos então aplicar um padrão: ``chamar a polícia''. Logo, um mau cheiro pode representar um \textbf{contexto} de um padrão (ou anti-padrão), sendo assim, pode ser que a aplicação do padrão o resolva. Entretanto, pode ser que não exista ainda nenhum padrão para resolver o mau cheiro, então uma solução terá de ser criada.

% Podemos dizer então que um padrão é a documentação formal de boas práticas.

% BIO
% =================================================================

% PRATICAS
% [1] https://dicionariodoaurelio.com/pratica
% [2] https://en.wikipedia.org/wiki/Best_practice #Critique
% [3] http://www.farrell-associates.com.au/Papers/Best%20Practice.pdf


% PADROES
% [1] mono ita 
% [2] https://en.oxforddictionaries.com/definition/pattern
% [9] FOWLER, M. Analysis Patterns: Reusable Object Models. Addison-Wesley Professional, 1996. 

% ANTI-PADROES

%[1]Koenig, Andrew Patterns and Antipatterns. The patterns handbook: techniques, strategies, and applications. Cambridge, U.K.: Cambridge University Press. p. 387. ISBN 0-521-64818-1. "An antipattern is just like a pattern, except that instead of a solution it gives something that looks superficially like a solution, but isnt one."

% Buscar mais aqui https://en.wikipedia.org/wiki/Anti-pattern\#Software_engineering




% QUALIDADE DE CÓDIGO
% [1] https://en.wikipedia.org/wiki/Software_quality#cite_note-34
% [2] https://www.iso.org/standard/35733.html