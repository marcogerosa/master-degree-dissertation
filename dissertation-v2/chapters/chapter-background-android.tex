% -*- root: index.tex -*-

% explicar os pontos fortes e fracos, tentar mostrar porque o front é problematico, dar exemplos, etc Verloop no cap 2.3.3 tem uns bons exemplos disso

\section{Android}
\label{sec:Android}

O Android é uma plataforma para desenvolvimento móvel, baseada no Kernel do Linux, lançada em 2008 pelo Google em parceria com diversas empresas \cite{OHAReleasesAndroidSDK:07, AndroidPlatformArchitecture}. No início de 2011 tomou o liderança, se tornando a plataforma móvel com maior participação no mercado global. Desde então se mantém líder aumentando sua participação a cada ano, tendo em 2017 atingido mais de 86\% de participação de mercado. Seus principais concorrentes são iOS da Apple, com participação de mercado de aproximadamente 13\% e o Windows Phone, oficialmente descontinuado pela Microsoft em 2017\footnote{https://support.microsoft.com/en-us/help/4001737/products-reaching-end-of-support-for-2017}. A Figura \ref{fig:MobileMarketShare09-17} apresenta a participação de mercado das principais plataformas móveis de 2009 a 2017 \cite{GlobalSmartphoneSales:09-17}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=.8\textwidth]{android-marketshare-09-17.png}
	\caption{Participação de mercado global de sistemas operacionais móveis do Q1 (1º quadrimestre) de 2009 até o Q1 de 2017 \cite{GlobalSmartphoneSales:09-17}.}
	\label{fig:MobileMarketShare09-17}
\end{figure}

Enquanto que o iOS só é utilizado por iPhones e iPads, que são fabricados pela Apple, totalizando aproximadamente 30 dispositivos diferentes \cite{WikiIosDevices}, o Android é utilizado por mais de 24 mil dispositivos diferentes segundo levantamento realizado em 2015 \cite{AndroidFragmentation}. Em termos de desenvolvimento de software, essa grande variedade de dispositivos trás grandes desafios no desenvolvimento Android, desde desafios relacionados a desempenho, por conta das diferentes configurações de hardware, e desafios relacionados a camada de apresentação, pelas diversas configurações de tamanhos de telas e resoluções.

% comentar sobre andrid wears, auto, etc

Aplicativos Android, desde seu lançamento em 2008, são desenvolvidos utilizando a linguagem de programação Java. Recentemente, em Maio de 2017, o Google anunciou o Kotlin como linguagem oficial do Android\footnote{https://blog.jetbrains.com/kotlin/2017/05/kotlin-on-android-now-official}. Para efeitos desta dissertação, utilizamos todos os códigos na linguagem Java, pois a pesquisa iniciou antes desse anúncio. Acreditamos que essa inclusão não interfere na relevância da pesquisa pois: 1) foram quase uma década de aplicativos Android sendo desenvolvidos em Java, 2) Kotlin é interoperável com Java, deste modo, os código antes escritos em Java não precisam necessariamente ser migrados para Kotlin, podendo continuar existindo, precisando de manutenções e evoluções, e 3) como este anúncio é muito recente, acreditamos que ainda levará algum tempo para que o mercado comece a adotar esta nova linguagem. 

As seções seguintes apresentam os fundamentos e bases do desenvolvimento de aplicativos Android. Todos os códigos de exemplo na dissertação foram implementados e testados utilizando a linguagem Java.

% \subsection{Arquitetura da Plataforma}

% Android é um sistema operacional de código aberto, baseado no kernel do Linux criado para um amplo conjunto de dispositivos. Para prover acesso aos recursos específicos dos dispositivos como câmera ou \textit{bluetooth}, o Android possui uma camada de abstração de \textit{hardware} (HAL do inglês \textit{Hardware Abstraction Layer}) exposto aos desenvolvedores através de um arcabouço de Interfaces de Programação de Aplicativos (APIs do inglês \textit{Applications Programming Interfaces}) Java \cite{AndroidPlatformArchitecture}. A Figura \ref{fig:AndroidPlatform} apresenta uma visão geral da arquitetura do sistema operacional Android.

% \begin{figure}[!htb]
% 	\centering
% 	\includegraphics[width=0.5\textwidth]{android-architecture.png}
% 	\caption{Arquitetura do sistema operacional Android.}
% 	\label{fig:AndroidPlatform}
% \end{figure}

% Cada aplicativo é executado em um novo processo de sistema que contém sua própria instância do ambiente de execução Android. A partir da versão 5 (API nível 21), o ambiente de execução padrão é o Android Runtime (ART), antes desta versão era a Dalvik. ART foi escrita para executar multiplas instâncias de máquina virtual em dispositivos com pouca memória. Suas funcionalidades incluem: duas forma de compilação, a frente do tempo (AOT do inglês \textit{Ahead-of-time}) e apenas no momento (JIT do inglês \textit{Just-in-time}), o coletor de lixo, ferramentas de depuração e um relatório de diagnósticos de erros e exceções.

% Muitos dos componentes e serviços básicos do Android, como ART e HAL, foram criados a partir de código nativo que depende de bibliotecas nativas escritas em C e C++. A plataforma Android provê arcabouços de APIs Java para expôr as funcionalidade de algumas destas bibliotecas nativas para os aplicativos. Por exemplo, OpenGL ES pode ser acessado através do arcabouço Android Java OpenGL API, de forma a adicionar suporte ao desenho e manipulação de gráficos 2D e 3D no aplicativo.

% Todo as funcionalidades da plataforma Android estão disponíveis para os aplicativos através de APIs Java. Estas APIs compõem os elementos básicos para a construção de aplicativos Android. Dentre eles, os mais relevantes para esta dissertação são:

% \begin{itemize}
% 	\item Um rico e extensível \textbf{Sistema de Visualização} para a contrução de interfaces com o usuário, também chamadas de arquivos de \textit{layout}, do aplicativo. Incluindo listas, grades ou tabelas, caixas de textos, botões, dentre outros.

% 	\item Um \textbf{Gerenciador de Recursos}, provendo acesso aos recursos ``não-java'' como textos, elementos gráficos, arquivos de \textit{layout}.

% 	\item Um \textbf{Gerenciador de Activity} que gerencia o ciclo de vida dos aplicativos e provê uma navegação comum.
% \end{itemize}

% O Android já vem com um conjunto de aplicativos básicos como por exemplo, para envio e recebimento de SMS, calendário, navegador, contatos e outros. Estes aplicativos vindos com a plataforma não possuem nenhum diferencial com relação aos aplicativos de terceiros. Todo aplicativo tem acesso ao mesmo arcabouço de APIs do Android, seja ele aplicativo da plataforma ou de terceiro. Desta forma, um aplicativo de terceiro pode se tornar o aplicativo padrão para navegar na internet, receber e enviar SMS e assim por diante.

% Aplicativos da plataforma provem capacidades básicas que aplicativos de terceiros podem reutilizar. Por exemplo, se um aplicativo de terceiro quer possibilitar o envio de SMS, o mesmo pode redirecionar esta funcionalidade de forma a abrir o aplicativo de SMS já existente, ao invés de implementar por si só.

\subsection{Fundamentos do Desenvolvimento Android}

O Android Studio \cite{AndroidStudio} é o ambiente integrado de desenvolvimento (\acl{IDE} - \acs{IDE}) oficial e gratuito, mantido pelo Google e comumente usado para o desenvolvimento Android. Juntamente com o Android Studio vem instalado o kit de desenvolvimento Android (\acl{SDK} - \acs{SDK}). O Android \acs{SDK} é um conjunto de ferramentas para o desenvolvimento Android. Entre as ferramentas podemos encontrar o compilador, depurador de código, emulador, bibliotecas de componentes base para a criação de aplicativos Android, e outras. O arquivo instalável de um aplicativo Android possui a extensão \texttt{.apk}, acrônimo para \emph{Android PacKage} \cite{AndroidFundamentals}. 

Na estrutura de um projeto Android existem dois diretórios e um arquivo principais. O diretório \texttt{src} (de \textit{source}) contém todo o código Java, o diretório \texttt{res} (de \textit{resource}) contém todos os recursos da aplicação, que são códigos \emph{``não java''} como imagens, XMLs de layout, dentre outros. Por fim, o arquivo \texttt{AndroidManifest.xml} contém configurações gerais do aplicativo como permissões, declarações de componentes dentre outras \cite{AndroidDevProjectStructure}.

O Android \ac{SDK} provê diversos componentes base para o desenvolvimento Android que não estão disponíveis no desenvolvimento Java tradicional \cite{AndroidUI1:17}. Alguns componentes são utilizados na camada de apresentação, outros para processamentos em segundo plano, outros para persistência em banco de dados local, dentre outros. Por exemplo, \textit{Activities} são usadas para a criação de telas com \ac{UI} pelo qual usuários podem interagir \cite{AndroidActivities2016}. \textit{Services} são usados para longos processamentos em segundo plano e não possuem \ac{UI} \cite{AndroidDevServices}. \textit{BroadcastReceivers} são usados como ouvintes, registrando interesse por mensagens enviadas pelo sistema operacional Android, como bateria baixa, ou por outros componentes \cite{AndroidDevBroadcast}. \textit{AsyncTasks} são usadas para curtos processamentos em segundo plano de forma assíncrona, com o objetivo de não bloquear a \ac{UI} \textit{Thread}, principal \textit{Thread} em um aplicativo Android \cite{AndroidDevAsyncTask, AndroidDeveloperMainThread}. 

Cada componente do Android \ac{SDK} possui um conjunto de métodos de retorno que podem ou devem ser sobrescritos pelo desenvolvedor e que são invocados pelo sistema operacional Android. Ciclo de vida de um componente diz respeito a como ele é criado, mantido e destruído. O ciclo de vida é composto por um conjunto de métodos de retorno que são sempre invocados e em uma sequência específica \cite{AndroidActivities2016, AndroidDeveloperLifeCycle}. Componentes de \ac{UI} como \textit{Activities} costumam ter ciclos de vida mais extensos, e portanto mais complexos, que componentes que não lidam com a camada de apresentação. A Figura \ref{fig:android-lifecycles} apresenta como exemplo os ciclos de vida de \textit{Activities}, que estão diretamente relacionadas a camada de apresentação, e \textit{Services}, que não estão relacionados a camada de apresentação.

\begin{figure*}[!htb]
\centering
	\begin{subfigure}[b]{.55\textwidth}
	  \centering
	  \includegraphics[width=.9\textwidth]{activity-lifecycle.png}
	  \caption{Principais métodos de retorno do ciclo de vida de \textit{Activities}.}
	  \label{fig:activity-lifecycle}
	\end{subfigure}
	\begin{subfigure}[b]{.44\textwidth}
	  \centering
	  \includegraphics[width=.9\textwidth]{service-lifecycle.png}
	  \caption{Métodos de retorno do ciclo de vida de \textit{Services}.}
	  \label{fig:service-lifecycle}
	\end{subfigure}% 
\caption{Comparação do ciclo de vida de \textit{Activities} e \textit{Services}.}
\label{fig:android-lifecycles}
\vspace{-.5cm} 
\end{figure*}

O ciclo de vida de \textit{Activities} é complexo, com mais de dez métodos de retorno \cite{AndroidDevActivityReference}. A Figura \ref{fig:activity-lifecycle} apresenta os sete principais métodos de retorno representados pelos retângulos em cinza. Além desses principais, as \textit{Activities} possuem outros, dentre eles, \textit{onUserLeaveHint}, \textit{onPostCreate} e \textit{onPostResume}. 

O ciclo de vida de \textit{Services} é bem menor se comparado com o de \textit{Activities}, contendo até quatro métodos de retorno. A Figura \ref{fig:service-lifecycle} apresenta os dois possíveis ciclos de vida de \textit{Services}, que variam de acordo com o método usado na sua criação, podendo ser \textit{startService} ou \textit{bindService}. Em ambos os casos, os métodos de retorno \textit{onCreate} e \textit{onDestroy} são chamados, a depender de como ele foi criado, no primeiro caso será chamado o \textit{onStartCommand} e no segundo o \textit{onBind} e \textit{onUnbind}.

Recursos são arquivos ``não Java'', utilizados na construção da \ac{UI} e necessários para a criação de aplicativos Android \cite{AndroidFundamentals}. Recursos podem ser imagens, arquivos de áudio ou arquivos XML, sendo as \textit{tags} e atributos usados no XML, derivados do Android \ac{SDK}. Recursos de \textit{Layout} são XMLs responsáveis pela estrutura da \ac{UI} como posicionamento, botões e caixas de textos. Recursos de \textit{String} são XMLs responsáveis pelo armazenamento dos textos usados no aplicativo e possibilitam a internacionalização, ou seja, traduzir o aplicativo em outros idiomas. Recursos de \textit{Style} são XMLs responsáveis pelo armazenamento dos estilos usados nos recursos de \textit{layout}. Recursos \textit{Drawable} são gráficos que podem ser imagens ou arquivos XML que criam animações ou efeitos de estado de botões como pressionado ou desabilitado. Apesar de ser possível implementar os recursos via código Java, é fortemente recomendado pela plataforma que isso não seja feito \cite{AndroidProvidingResources}.


\subsection{Elementos da Camada de Apresentação Android}

São muitos os componentes e recursos disponibilizados pelo Android \ac{SDK}. Nosso estudo objetiva analisar os que estão relacionados a camada de apresentação Android. Em termos de componentes, fizemos uma extensa revisão na documentação oficial do Android \cite{AndroidDeveloperSite2016} e chegamos em quatro, são eles: \textit{Activities}, \textit{Fragments}, \textit{Adapters} e \textit{Listeners}. 

Em termos de recursos, todos são por natureza relacionados a camada de apresentação. O Android provê mais de quinze diferentes tipos de recursos \cite{AndroidResourceType}. Com o objetivo de focar a pesquisa, optamos por selecionar os principais com base no modelo padrão de projeto do Android Studio \cite{FirstApp2017}, são eles: recursos de \textit{Layout}, recursos de \textit{Strings}, recursos de \textit{Style} e recursos \textit{Drawable}. De modo genérico chamaremos os componentes e recursos mencionados aqui de ``elementos'' da camada de apresentação Android.

A seguir introduzimos brevemente cada um dos oito elementos da camada de apresentação Android considerados na pesquisa. 

\noindent \textbf{\textit{Activity}} é um dos principais componentes de aplicações Android e representa uma tela pelo qual o usuário pode interagir com a \ac{UI}. Possui um ciclo de vida, como mencionado na seção anterior. Toda \textit{Activity} deve indicar no método de retorno \textit{onCreate} o recurso de \textit{layout} que deve ser usado para a construção de sua \ac{UI} \cite{AndroidActivities2016, AndroidDevActivityReference}. 

% ============================= início OPÇÃO MAIS DETALHADA E COM CÓDIGO =========
% \noindent \textbf{\textit{Activity}} é um dos principais componentes de aplicações Android e representa uma tela pelo qual o usuário pode interagir com a UI. Possui um ciclo de vida, como mencionado na seção anterior. Tipicamente cada \textit{Activitiy} representa uma funcionalidade única, por exemplo a tela para redigir um \textit{e-mail}, a câmera para tirar uma foto, etc. Toda \textit{Activity} deve indicar no \textit{callback onCreate} o recurso de \textit{layout} que deve ser exibido. O Código-Fonte \ref{lst:Activity} apresenta o código para a criação de uma \textit{Activity}, na linha 5 é indicado o recurso de \textit{layout} que deve ser usado para a construção da UI \cite{AndroidActivities2016}.\\ 

% \begin{lstlisting}[
% 	language=Java, 
% 	caption={Exemplo de código para a criação de uma \textit{Activity}}, 
% 	label={lst:Activity}
% ]
% public class MainActivity extends Activity {
%     @Override
%     public void onCreate(Bundle savedInstanceState) {
%         super.onCreate(savedInstanceState);
%         setContentView(R.layout.main_activity);
%     }
% }
% \end{lstlisting}
% ============================= fim OPÇÃO MAIS DETALHADA E COM CÓDIGO =========

\noindent \textbf{\textit{Fragments}} representam parte de uma \textit{Activity} e também devem indicar seu recurso de \textit{layout} correspondente. \textit{Fragments} só podem ser usados dentro de uma \textit{Activity}. Podemos pensar neles como \textit{Sub-Activities}. \textit{Fragments} possuem um ciclo de vida extenso, com mais de dez métodos de retorno. Seu ciclo de vida está diretamente ligado ao ciclo de vida da \textit{Activity} ao qual ele está contido. A principal uso de \textit{Fragments} é para o reaproveitamento de trechos de \ac{UI} e comportamento em diferentes \textit{Activities}~\cite{AndroidFragments}.

% ============================= início OPÇÃO MAIS DETALHADA E COM CÓDIGO =========
% \noindent \textbf{\textit{Fragments}} são como \textit{Sub-Activities}, representam parte da UI de uma \textit{Activity} e também devem indicar seu recurso de \textit{layout} correspondente. \textit{Fragments} possuem um ciclo de vida extenso, com mais de dez \textit{callbacks}, demonstrado pelas caixas cinza na Figura \ref{fig:frament-lifecycle}. Seu ciclo de vida está diretamente ligado ao ciclo de vida da \textit{Activity} ao qual ele está contido, esta relação é apresentada na Figura \ref{fig:activity-fragment-lifecycle}. A principal uso de \textit{Fragments} é para o reaproveitamento de trechos de UI e comportamento em \textit{Activities} diferentes \cite{AndroidFragments}. A imagem apresenta seu ciclo de vida com mais de dez \textit{callbacks}. O Código-Fonte \ref{lst:Fragment} apresenta o código para a criação de uma \textit{Fragment}. \\

% \begin{lstlisting}[
% 	language=Java, 
% 	caption={Exemplo de código para a criação de uma \textit{Activity}}, 
% 	label={lst:Fragment}
% ]
% public static class MainFragment extends Fragment {
%     @Override
%     public View onCreateView(LayoutInflater inflater, ViewGroup container,
%                              Bundle savedInstanceState) {
%         return inflater.inflate(R.layout.main_fragment, container, false);
%     }
% }
% \end{lstlisting}


% \begin{figure*}[!htb]
% \centering
% 	\begin{subfigure}{.45\textwidth}
% 	  \centering
% 	  \includegraphics[width=.8\textwidth]{fragment-lifecycle.png}
% 	  \caption{Ciclo de vida de \textit{Fragments}.}
% 	  \label{fig:frament-lifecycle}
% 	\end{subfigure}
% 	\begin{subfigure}{.50\textwidth}
% 	  \centering
% 	  \includegraphics[width=.8\textwidth]{activity-fragment-lifecycle.png}
% 	  \newline \newline \newline \newline \newline \newline
% 	  \caption{Ciclo de vida do \textit{Fragment} com relação aos estados da \textit{Activity} que ele está contido.}
% 	  \label{fig:activity-fragment-lifecycle}
% 	\end{subfigure}% 
% \caption{Ciclo de vida de \textit{Fragments} e sua relação com o ciclo de vida de \textit{Activities}.}
% \label{fig:android-lifecycles}
% \vspace{-.5cm} 
% \end{figure*}

% ============================= fim OPÇÃO MAIS DETALHADA E COM CÓDIGO =========


\noindent \textbf{\textit{Adapters}} são utilizados para popular a \acs{UI} com coleções de dados como por exemplo, uma lista de \textit{e-mails}, onde o \textit{layout} é o mesmo para cada item mas o conteúdo é diferente~\cite{AndroidLayouts}. 

\noindent \textbf{\textit{Listeners}} são interfaces que representam eventos do usuário, por exemplo o \textit{OnClickListener} captura o clique pelo usuário. Essas interfaces costumam ter apenas um método, onde é implementado o comportamento desejado para responder a interação do usuário~\cite{AndroidUIEvents}.

\noindent \textbf{\textit{Recursos de Layout}} são XMLs utilizados para o desenvolvimento da estrutura da \ac{UI} dos componentes Android. O desenvolvimento é feito utilizando uma hierarquia de \textit{Views} e \textit{ViewGroups}. \textit{Views} são caixas de texto, botões, dentre outros. \textit{ViewGroups} são \textit{Views} especiais pois podem conter outras \textit{Views}. Cada \textit{ViewGroup} organiza suas \textit{Views} filhas de uma forma específica, horizontalmente, em tabela, posicionamento relativo, dentre outros. Esta hierarquia pode ser tão simples ou complexa quanto se precisar, mas quanto mais simples melhor o desempenho~\cite{AndroidLayoutResources, AndroidLayouts}. 

% ============================= início OPÇÃO MAIS DETALHADA E COM CÓDIGO =========
% \noindent \textbf{\textit{Recursos de Layout}} são XMLs utilizados para o desenvolvimento da UI dos componentes Android. O desenvolvimento é feito utilizando uma hierarquia de \textit{Views} e \textit{ViewGroups}. \textit{Views} são caixas de texto, botões, dentre outros elementos de interface. \textit{ViewGroups} são \textit{Views} especiais pois podem conter outras \textit{Views}. Cada \textit{ViewGroup} organiza suas \textit{Views} filhas de uma forma específica, por exemplo o \textit{LinearLayout} é um \textit{ViewGroup} que organizar suas \textit{Views} filhas verticalmente, uma abaixo da outra ou horizontalmente, uma ao lado direito da outra. Esta árvore hierárquica pode ser tão simples ou complexa quanto se precisar, mas quanto mais simples melhor o desempenho. O Código-Fonte \ref{lst:LayoutSample} apresenta um recurso de \textit{layout} simples com uma caixa de texto e um botão \cite{AndroidUIOverview}. \\


% \begin{lstlisting}[
% 	language=XML, 
% 	caption={Arquivo exemplo de layout.}, 
% 	label={lst:LayoutSample}
% ]
% <?xml version="1.0" encoding="utf-8"?>
% <LinearLayout ...
%     android:layout_width="fill_parent"
%     android:layout_height="fill_parent"
%     android:orientation="vertical">

%     <TextView android:id="@+id/text"
% 	      android:layout_width="wrap_content"
% 	      android:layout_height="wrap_content"
% 	      android:text="I am a TextView" />

%     <Button android:id="@+id/button"
%         android:layout_width="wrap_content"
%         android:layout_height="wrap_content"
%         android:text="I am a Button" />
% </LinearLayout>
% \end{lstlisting}
% ============================= fim OPÇÃO MAIS DETALHADA E COM CÓDIGO =========


\noindent \textbf{\textit{Recursos de String}} são XMLs utilizados para definir textos, conjunto de textos e plurais usados no aplicativo. As principais vantagens de se usar recursos de \textit{String} é o reaproveitamento dos textos em diferentes \ac{UI}s e a facilidade para internacionalizar~\cite{AndroidStringResources}.

\noindent \textbf{\textit{Recursos de Style}} são XMLs utilizados para a definição de estilos a serem aplicados nos XMLs de \textit{layout}. A principais vantagens em se utilizar recursos \textit{Styles} é separar o código de estrutura da \ac{UI} do código que define sua aparência e forma, e também possibilitar a reutilização de estilos em diferentes \ac{UI}s~\cite{AndroidStyleResources}.

\noindent \textbf{\textit{Recursos de Drawable}} são arquivos gráficos utilizados na \ac{UI}. Estes arquivos podem ser imagens tradicionais, \texttt{.png}, \texttt{.jpg} ou \texttt{.gif}, ou XMLs gráficos. A principal vantagem dos XMLs gráficos está no tamanho do arquivo que é comumente bem menor do que imagens tradicionais e, diferente das imagens tradicionais onde é recomendado que tenha mais de uma versão da mesma em resolução diferentes, XMLs gráficos só é necessário uma versão~\cite{AndroidDrawableResources}.






\subsection{Desafios no Desenvolvimento da Camada de Apresentação Android}

% No desenvolvimento Android, uma tela é composta basicamente por dois arquivos, uma classe Java responsável pela criação da tela e responder aos eventos do usuário e um recurso de \textit{layout}, arquivo XML responsável pela criação da interface visual (\acl{UI} - \acs{UI}).

\textit{Activity} é um dos principais componentes de aplicativos Android. Ela representa uma tela com interface do usuário (\acl{UI} - \acs{UI}) pelo qual o usuário pode interagir através de botões, listagens, caixas de entrada de textos, dentre outros. Para implementar uma \textit{Activity} é necessário criar uma classe derivada de \texttt{Activity} e sobrescrever alguns métodos herdados, chamados de métodos de retorno. O principal método de retorno é o \textit{onCreate}, entre suas responsabilidades está a criação da tela e configuração da \acs{UI}. O Código-Fonte \ref{lst:BasicActivity} apresenta o código mínimo para a criação de uma \textit{Activity}, na linha 5 temos o código responsável pela configuração da \acs{UI} que indica o recurso de \textit{layout} ``main\_activity''.

\begin{lstlisting}[
  language=Java, 
  caption={Código mínimo para a criação de uma \textit{Activity}}, 
  label={lst:BasicActivity}
]
public class MainActivity extends Activity {
  @Override
  public void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      setContentView(R.layout.main_activity);
  }
}
\end{lstlisting}

A \acs{UI} de uma \textit{Activity} é construída por meio de recursos de \textit{layout}, arquivos XML cujo as \textit{tags} provém do kit de desenvolvimento Android (\acl{SDK} - \acs{SDK}) e representam \textit{Views} ou \textit{ViewGroups}. O Código-Fonte \ref{lst:SimpleLayout} apresenta um recurso de \textit{layout} com duas \textit{Views} e um \textit{ViewGroup}. As \textit{Views} são um \textit{TextView}, que representa uma caixa de entrada de texto e um \textit{Button}, que representa um botão. Essas duas \textit{Views} estão contidas dentro do \textit{ViewGroup} \textit{LinearLayout}, que as organiza verticalmente. 


\begin{lstlisting}[
  language=XML, 
  caption={Exemplo de recurso de \textit{layout} com um campo de entrada de texto e um botão organizados um abaixo do outro.}, 
  label={lst:SimpleLayout}
]
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout ...
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:orientation="vertical">

    <TextView android:id="@+id/text"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Um TextView" />

    <Button android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Um Button" />
</LinearLayout>
\end{lstlisting}

Os códigos apresentados são bem simples, mas comumente, estas telas e \acs{UI}s tendem a ser bem mais robustas e ricas de informações e interatividade. São em contextos como esses que os desafios no desenvolvimento da camada de apresentação Android surgem. \acs{UI}s ricas e robustas podem significar muitas \textit{Views} e \textit{ViewGroups}, resultando em recursos de \textit{layout} grandes e complexos. E ainda, quanto mais ricas e robustas são as \acs{UI}s, mais provavelmente o código das \textit{Activities} correspondentes também serão grandes e complexos, pois são pelas \textit{Activities} que \textit{Views} e \textit{ViewGroups} conseguem interagir com o usuário, também são pelas \textit{Activities} que os dados chegam até a \acs{UI} e vice-versa, dentre muitas outras responsabilidades que tendem a ficar com as \textit{Activities}.

\subsubsection{Ciclo de Vida}

Toda \textit{Activity}, bem como outros componentes Android, possui um ciclo de vida. O ciclo de vida de um componente é composto por um conjunto de métodos de retorno, que por sua vez, são métodos invocados pelo Android em uma ordem específica \cite{AndroidActivities2016}. Os componente da camada de apresentação Android possuem ciclos de vida mais extensos, e portanto, mais complexos. 

Como exemplo, na Figura \ref{fig:android-lifecycles} apresentamos o ciclo de vida de três componentes Android: \textit{Activities} e \textit{Fragments}, ambos relacionados a camada de apresentação e \textit{Services}, componente usado para longos processamento em segundo plano. Os métodos de retorno são representados pelos retângulos em cinza. É possível observar que \textit{Activities} e \textit{Fragments} possuem respectivamente sete e onze métodos de retorno enquanto que \textit{Services} possuem apenas quatro.

\begin{figure*}[!htb]
\centering
  \begin{subfigure}[b]{.33\textwidth}
    \centering
    \includegraphics[width=.9\textwidth]{activity-lifecycle.png}
    \caption{\textit{Activitiy}.}
    \label{fig:activity-lifecycle}
  \end{subfigure}
  \begin{subfigure}[b]{.33\textwidth}
    \centering
    \includegraphics[width=.6\textwidth]{fragment-lifecycle.png}
    \caption{\textit{Fragment}.}
    \label{fig:activity-lifecycle}
  \end{subfigure}
  \begin{subfigure}[b]{.30\textwidth}
    \centering
    \includegraphics[width=.9\textwidth]{service-lifecycle.png}
    \caption{\textit{Services}.}
    \label{fig:service-lifecycle}
  \end{subfigure}% 
\caption{Comparativo do ciclo de vida de componentes Android que pertencem e não pertencem a camada de apresentação.}
\label{fig:android-lifecycles}
% \vspace{-.5cm} 
\end{figure*}

% \begin{lstlisting}[
%   language=Java, 
%   caption={Exemplo de código para a criação de uma \textit{Activity}}, 
%   label={lst:Activity}
% ]
% public class MainActivity extends Activity {
%   @Override
%   public void onCreate(Bundle savedInstanceState) {
%       super.onCreate(savedInstanceState);
%       setContentView(R.layout.main_activity);
%       // ...
%   }
%   @Override
%   protected void onStart() {
%       super.onStart();
%       // ...
%   }
%   @Override
%   protected void onResume() {
%       super.onResume();
%       // ...
%   }
%   @Override
%   protected void onPause() {
%       super.onPause();
%       // ...
%   }
%   @Override
%   protected void onStop() {
%       super.onStop();
%       // ...
%   }
%   @Override
%   protected void onDestroy() {
%       super.onDestroy();
%       // ...
%   }
% }
% \end{lstlisting}




% Antes de a plataforma Android poder iniciar qualquer um dos componente supramencionados, a plataforma precisa saber que eles existem. Isso é feito através da leitura do arquivo \texttt{AndroidManifest.xml} do aplicativo (arquivo de manifesto). Este arquivo deve estar no diretório raiz do projeto do aplicativo e deve conter a declaração de todos os seus componentes.

% O arquivo de manifesto é um arquivo XML e pode conter muitas outras informações além das declarações dos componentes do aplicativo, por exemplo:

% \begin{itemize}
% 	\item Identificar qualquer permissão de usuário requerida pelo aplicativo, como acesso a internet, acesso a informações de contatos do usuário e assim por diante.

% 	\item Declarar o nível mínimo do Android requerido para o aplicativo, baseado em quais APIs são usadas pelo aplicativo.

% 	\item Declarar quais funcionalidades de sistema ou \textit{hardware} são usadas ou requeridas pelo aplicativo, por exemplo câmera, \textit{bluetooth} e assim por diante.

% 	\item Declarar outras APIs que são necessárias para uso do aplicativo (além do arcabouço de APIs do Android), como a biblioteca do Google Maps.
% \end{itemize}

% Os elementos usados no arquivo de manifesto são definidos pelo vocabulário XML do Android. Por exemplo, uma \textit{activity} pode ser declarada conforme o Código-Fonte \ref{lst:AndroidManifest}. \\

% % \begin{lstlisting}[
% % 	language=XML, 
% % 	caption={Arquivo \texttt{AndroidManifest.xml}}, 
% % 	label={lst:AndroidManifest}
% % ]
% % <?xml version="1.0" encoding="utf-8"?>
% % <manifest ... >
% %     <application android:icon="@drawable/app_icon.png" ... >
% %         <activity android:name="com.example.project.ExampleActivity"
% %                   android:label="@string/example_label" ... >
% %         </activity>
% %         ...
% %     </application>
% % </manifest>	
% % \end{lstlisting}

% No elemento \texttt{<application>} o atributo \texttt{android:icon} aponta para o ícone, que é um recurso, que identifica o aplicativo. No elemento \texttt{<activity>}, o atributo \texttt{android:name} especifica o nome completamente qualificado da \textit{Activity}, que é uma classe que extende de \texttt{Activity}, e por fim, o atributo \texttt{android:label} especifica um texto para ser usado como título da \textit{Activity}.

% Para declarar cada um dos quatro tipos de componentes, deve-se usar os elementos a seguir:
% \begin{itemize}
% 	\item \texttt{<activity>} elemento para \textit{activities}.
% 	\item \texttt{<service>} elemento para \textit{services}.
% 	\item \texttt{<receiver>} elemento para \textit{broadcast receivers}.
% 	\item \texttt{<provider>} elemento para \textit{content providers}.
% \end{itemize}

% \subsection{Recursos do Aplicação}
% \label{sec:AndroidResources}

% Um aplicativo Android é composto por outros arquivos além de código Java, ele requer \textbf{recursos} como imagens, arquivos de áudio, e qualquer recurso relativo a apresentação visual do aplicativo \cite{AndroidFundamentals}. Também é possível definir animações, menus, estilos, cores e arquivos de \textit{layout} das \textit{activities}. Recursos costumam ser arquivos XML que usam o vocabulário definido pelo Android.

% Apesar de ser possível a criação desses recursos através de código-fonte Java, um dos aspectos mais importantes de prover recursos separados do código-fonte é a habilidade nativa da plataforma de prover recursos alternativos para diferentes configurações de dispositivos como por exemplo idioma ou tamanho de tela. Este aspecto se torna mais importante conforme mais dispositivos são lançados com configurações diferentes. Segundo levantamento da Open Signal, em 2015 foram encontrados mais de 24 mil dispositivos diferentes com Android \cite{AndroidFragmentation}.

% De forma a prover compatibilidade com diferentes configurações, deve-se organizar os recursos dentro do diretório \texttt{res} do projeto, usando sub-diretórios que agrupam os recursos por tipo e configuração. Para qualquer tipo de recurso, pode-se especificar uma opção padrão e outras alternativas. 

% \begin{itemize}
% 	\item \textbf{Recursos padrões} são aqueles que devem ser usados independente de qualquer configuração ou quando não há um recurso alternativo que atenda a configuração atual. Por exemplo, arquivos de \textit{layout} padrão ficam em \texttt{res/layout}.

% 	\item \textbf{Recursos alternativos} são todos aqueles que foram desenhados para atender a uma configuração específica. Para especificar que um grupo de recursos é para ser usado em determinada configuração, basta adicionar um qualificador ao nome do diretório. Por exemplo, arquivos de \textit{layout} para quando o dispositivo está em posição de paisagem ficam em \texttt{res/layout-land}.
% \end{itemize}

% O Android irá aplicar automaticamente o recurso apropriado através da identificação da configuração corrente do dispositivo com os recursos disponíveis no aplicativo. Por exemplo, o recurso do tipo \textit{strings} pode conter textos usados nas interfaces do aplicativo. É possível traduzir estes textos em diferentes idiomas e salvá-los em arquivos separados. Desta forma, baseado no qualificador de idioma usado no nome do diretório deste tipo de recurso (por exemplo \texttt{res/values-fr} para o idioma frânces) e a configuração de idioma do dispositivo, o Android aplica o conjunto de \textit{strings} mais apropriado.

% A seguir são listados os tipos de recursos que podem ser utilizados no Android \cite{AndroidResourceType}. Para cada tipo de recurso existe um conjunto de qualificadores que podem ser usados para prover recursos alternativos:

% \begin{itemize}
% 	\item \textbf{Recursos de animações} Definem animações pré-determinadas. Ficam nos diretórios \texttt{res/anim} ou \texttt{res/animator}.

% 	\item \textbf{Recursos de lista de cores de estado} Definem recursos de cores que alteram baseado no estado da \textit{View}. Ficam no diretório \texttt{res/color}.	

% 	\item \textbf{Recursos de desenhos} Definem recursos gráficos como \textit{bitmap} ou XML. Ficam no diretório \texttt{res/drawable}.

% 	\item \textbf{Recursos de \textit{layouts}} Definem a parte visual da interface com o usuário. Ficam no diretório \texttt{res/layout}.

% 	\item \textbf{Recursos de menus} Definem os conteúdos dos menus da aplicação. Ficam no diretório \texttt{res/menu}.

% 	\item \textbf{Recursos de textos} Definem textos, conjunto de textos e plurais. Ficam no diretório \texttt{res/values}.

% 	\item \textbf{Recursos de estilos} Definem os estilos e e formatos para os elementos da interface com usuário. Ficam no diretório \texttt{res/values}.

% 	\item \textbf{Outros recursos} Ainda existem outros recursos como inteiros, \textit{booleanos}, dimensões, dentre outros. Ficam no diretório \texttt{res/values}.
% \end{itemize}


% \subsection{Interfaces de Usuários}

% Arquivos de layout são recursos localizados na pasta \texttt{res/layout} que possuem a extensão \texttt{.xml}. 

% Todos os elementos de UI (Interface de Usuário, do inglês UI, \textit{User Interface}) de um aplicativo Android são construídos usando objetos do tipo \texttt{View} ou \texttt{ViewGroup}. Uma \texttt{View} é um objeto que desenha algo na tela do qual o usuário pode interagir. Um \texttt{ViewGroup} é um objeto que agrupa outras \texttt{View}s e \texttt{ViewGroup}s de forma a desenhar o layout da interface \cite{AndroidUIOverview}.

% A UI para cada componente do aplicativo é definida usando uma hierarquia de objetos \texttt{View} e \texttt{ViewGroup}, como mostrado na figura \ref{fig:UIOverview}. Cada \texttt{ViewGroup} é um container invisível que organiza \texttt{View}s filhas, enquanto as \texttt{View}s filhas são caixas de texto, botões e outros componentes visuais que compoem a UI. Esta árvore hierárquica pode ser tão simples ou complexa quanto se precisar, mas quanto mais simples melhor o desempenho.

% \begin{figure}[!htb]
% 	\centering
% 	\includegraphics[width=0.7\textwidth]{ui-overview.png}
% 	\caption{Árvore hierárquica de \texttt{View}s e \texttt{ViewGroup}s do Android.}
% 	\label{fig:UIOverview}
% \end{figure}

% É possível criar um layout programaticamente, instanciando \texttt{View}s e \texttt{ViewGroup}s no código e construir a árvore hierárquica manualmente, no entanto, a forma mais simples e efetiva de definir um layout é través de um XML de layout. O XML de layout oferece uma estrutura legível aos olhos humanos, similar ao HTML, podendo ser utilizados elementos aninhados.

% O vocabulário XML para declarar elementos de UI segue a estrutura de nome de classes e métodos, onde os nomes dos elementos correspondem aos nomes das classes e os atributos correspondem aos nomes dos métodos. De fato, a correspondência frequentemente é tão direta que é possível adivinhar qual atributo XML correspodne a qual método de classe, ou adivinhar qual a classe correspondente para determinado elemento. No entanto, algumas classes possuem pequenas diferenças como por exemplo, o elemento \texttt{<EditText>} tem o atributo \texttt{text} que correponde ao método \texttt{EditText.setText()}.

% Um layout vertical simples com uma caixa de texto e um botão se parece com o código no listing \ref{lst:LayoutSample}.

% \begin{lstlisting}[
% 	language=XML, 
% 	caption={Arquivo exemplo de layout.}, 
% 	label={lst:LayoutSample}
% ]
% <?xml version="1.0" encoding="utf-8"?>
% <LinearLayout ...
%               android:layout_width="fill_parent"
%               android:layout_height="fill_parent"
%               android:orientation="vertical">

%     <TextView android:id="@+id/text"
%               android:layout_width="wrap_content"
%               android:layout_height="wrap_content"
%               android:text="I am a TextView" />

%     <Button android:id="@+id/button"
%             android:layout_width="wrap_content"
%             android:layout_height="wrap_content"
%             android:text="I am a Button" />

% </LinearLayout>
% \end{lstlisting}

% Quando um recurso de layout é carregado pelo aplicativo, o Android inicializa um objeto para cada elemento do layout, desta forma é possível recuperá-lo programaticamente para definir comportamentos, modificar o layout ou mesmo recuperar o estado. 

% O Android provê uma série de elementos de UI comuns pré-prontos como: caixa de texto, botão, lista suspensa, dentre muitos outros. Desta forma, o desenvolvedor não precisa implementar do zero estes elementos básicos através de \texttt{View}s e \texttt{ViewGroup}s para escrever uma interface de usuário.

% Cada subclasse de \texttt{ViewGroup} provê uma forma única de exibir o conteúdo dentro dele. Por exemplo, o \texttt{LinearLayout} organiza seu conteúdo de forma linear horizontalmente, um ao lado do outro, ou verticalmente, um abaixo do outro. O \texttt{RelativeLayout} permite especificar a posição de uma \texttt{View} relativa ao posicionamento de alguma outra \cite{AndroidLayouts}.

% Quando o conteúdo é dinâmico ou não pré-determinado, como por exemplo uma lista de dados, pode-se usar um elemento que estende de \texttt{AdapterView} para popular o layout em momento de execução. Subclasses de \texttt{AdapterView} usam uma implementação de \texttt{Adapter} para carregar dados em seu layout. \texttt{Adapter}s agem como um intermediador entre o conteúdo a ser exibido e o layout, ele recupera o conteúdo e converte cada item, de uma lista por exemplo, dentro de uma ou mais \texttt{View}s.

% Os elementos comumente usados para situações de conteúdo dinâmico ou não pré-determinado são: \texttt{ListView} e \texttt{GridView}. Para fazer o carregamento dos dados nestes elementos, o Android provê alguns \texttt{Adapter}s como por exemplo o \texttt{ArrayAdapter} que a partir de um \texttt{array} de dados popula os dados na \texttt{ListView} ou \texttt{GridView}.

% \subsection{Eventos de Interface}

% No Android, há mais de uma maneira de interceptar os eventos da interação de um usuário com sua aplicação. Ao considerar eventos dentro de sua interface de usuário, a abordagem é capturar os eventos do objeto de Vista específico com o qual o usuário interage. A classe \texttt{View} fornece os meios para fazê-lo.

% Dentro das várias classes de visualização que você usará para compor seu layout, você pode notar vários métodos de retorno de chamada pública que se parecem úteis para eventos de UI. Esses métodos são chamados pela estrutura do Android quando a ação respectiva ocorre nesse objeto. Por exemplo, quando uma Tela (como um botão) é tocada, o método onTouchEvent () é chamado nesse objeto. No entanto, para interceptar isso, você deve estender a classe e substituir o método. No entanto, estender cada objeto View para lidar com esse evento não seria prático. É por isso que a classe View também contém uma coleção de interfaces aninhadas com callbacks que você pode definir muito mais facilmente. Essas interfaces, chamadas de ouvintes de eventos, são seu ingresso para capturar a interação do usuário com sua IU.

% Enquanto você usará mais comumente os ouvintes do evento para ouvir a interação do usuário, pode ocorrer um momento em que você deseja ampliar uma classe View, para criar um componente personalizado. Talvez você queira estender a classe Button para tornar algo mais extravagante. Neste caso, você poderá definir os comportamentos de evento padrão para sua classe usando os manipuladores de eventos da classe.


% % organizar melhor
% Para definirmos quais elementos representam o \textit{front-end} Android, fizemos umas extensa revisão da documentação oficial e chegamos nos seguintes itens: \textsc{Activities}, \textsc{Fragments}, \textsc{Listeners}, \textsc{Adapters} e os recursos do aplicativo, que são arquivos XML ou imagens utilizados na interface visual, como por exemplo \textsc{Drawables}, \textsc{Layouts}, \textsc{Styles} e \textsc{Colors}. Como existem muitos tipos de recursos do aplicativo \cite{AndroidResourcesOverview}, selecionamos quatro: \textsc{Layout}, \textsc{Styles}, \textsc{String} e \textsc{Drawable}. Optamos por esses recursos pois estão presentes no template padrão do Android Studio \cite{FirstApp2017}, IDE oficial para desenvolvimento de projetos da plataforma Android \cite{AndroidStudio}.
