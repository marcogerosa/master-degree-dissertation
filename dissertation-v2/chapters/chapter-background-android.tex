% -*- root: index.tex -*-
\section{\textsc{Android}}
\label{sec:Android}

Android é um sistema operacional móvel, desenvolvido pelo Google, baseado no kernel do Linux e desenhado principalmente para o uso em dispositivos móveis com telas sensíveis ao toque \cite{WikiAndroid}. Em 2017 é o sistema operacional móvel mais usado no mundo


\subsection*{Arquitetura da Plataforma}

Android é um sistema operacional de código aberto, baseado no kernel do Linux criado para um amplo conjunto de dispositivos. Para prover acesso aos recursos específicos dos dispositivos como câmera ou \textit{bluetooth}, o Android possui uma camada de abstração de \textit{hardware} (HAL do inglês \textit{Hardware Abstraction Layer}) exposto aos desenvolvedores através de um arcabouço de interfaces de programação de aplicativos (APIs do inglês \textit{Applications Programming Interface}) Java. Estes e outros elementos explicados a seguir podem ser visualizados na figura \ref{fig:AndroidPlatform} \cite{AndroidPlatformArchitecture}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.7\textwidth]{android-architecture.png}
	\caption{Arquitetura do sistema operacional Android.}
	\label{fig:AndroidPlatform}
\end{figure}

Cada aplicativo é executado em um novo processo de sistema que contém sua própria instância do ambiente de execução Android. A partir da versão 5 (API nível 21), o ambiente de execução padrão é o Android Runtime (ART), antes desta versão era a Dalvik. ART foi escrita para executar multiplas instâncias de máquina virtual em dispositivos com pouca memória. Suas funcionalidades incluem: duas forma de compilação, a frente do tempo (AOT do inglês \textit{Ahead-of-time}) e apenas no momento (JIT do inglês \textit{Just-in-time}), o coletor de lixo, ferramentas de depuração e um relatório de diagnósticos de erros e exceções.

Muitos dos componentes e serviços básicos do Android, como ART e HAL, foram criados a partir de código nativo que depende de bibliotecas nativas escritas em C e C++. A plataforma Android provê arcabouços de APIs Java para expôr as funcionalidade de algumas destas bibliotecas nativas para os aplicativos. Por exemplo, OpenGL ES pode ser acessado através do arcabouço Android Java OpenGL API, de forma a adicionar suporte ao desenho e manipulação de gráficos 2D e 3D no aplicativo.

Todo as funcionalidades da plataforma Android estão disponíveis para os aplicativos através de APIs Java. Estas APIs compõem os elementos básicos para a construção de aplicativos Android. Dentre eles, os mais relevantes para esta dissertação são:

\begin{itemize}
	\item Um rico e extensível \textbf{Sistema de Visualização} para a contrução de interfaces com o usuário, também chamadas de arquivos de \textit{layout}, do aplicativo. Incluindo listas, grades ou tabelas, caixas de textos, botões, dentre outros.

	\item Um \textbf{Gerenciador de Recursos}, provendo acesso aos recursos ``não-java'' como textos, elementos gráficos, arquivos de \textit{layout}.

	\item Um \textbf{Gerenciador de Activity} que gerencia o ciclo de vida dos aplicativos e provê uma navegação comum.
\end{itemize}

O Android já vem com um conjunto de aplicativos básicos como por exemplo, para envio e recebimento de SMS, calendário, navegador, contatos e outros. Estes aplicativos vindos com a plataforma não possuem nenhum diferencial com relação aos aplicativos de terceiros. Todo aplicativo tem acesso ao mesmo arcabouço de APIs do Android, seja ele aplicativo da plataforma ou de terceiro. Desta forma, um aplicativo de terceiro pode se tornar o aplicativo padrão para navegar na internet, receber e enviar SMS e assim por diante.

Aplicativos da plataforma provem capacidades básicas que aplicativos de terceiros podem reutilizar. Por exemplo, se um aplicativo de terceiro quer possibilitar o envio de SMS, o mesmo pode redirecionar esta funcionalidade de forma a abrir o aplicativo de SMS já existente, ao invés de implementar por si só.

\subsection*{Fundamentos do Desenvolvimento Android}

Aplicativos Android são escritos na linguagem de programação Java. O \ac{SDK} Android compila o código, junto com qualquer arquivo de recurso ou dados, em um arquivo Android Package (APK). Um APK, arquivo com extensão \texttt{.apk}, é usado por dispositivos para a instalação de um aplicativo \cite{AndroidFundamentals}.

Componentes Android são os elementos base para a construção de aplicativos Android. Cada componente é um diferente ponto através do qual o sistema pode acionar o aplicativo. Nem todos os componente são pontos de entrada para o usuário e alguns são dependentes entre si, mas cada qual existe de forma autônoma e desempenha um papel específico. 

Existem quatro tipos diferentes de componentes Android. Cada tipo serve um propósito distinto e tem diferentes ciclos de vida, que definem como o componente é criado e destruído. Os quatro componentes são:

\begin{itemize}

	\item \textbf{Activities}

	Uma \textit{activity} representa uma tela com uma interface de usuário. Por exemplo, um aplicativo de email pode ter uma \textit{activity} para mostrar a lista de emails, outra para redigir um email, outra para ler emails e assim por diante. Embora \textit{activities} trabalhem juntas de forma a criar uma experiência de usuário (UX do inglês \textit{User Experience}) coesa no aplicativo de emails, cada uma é independente da outra. Desta forma, um aplicativo diferente poderia iniciar qualquer uma destas \textit{activities} (se o aplicativo de emails permitir). Por exemplo, a \textit{activity} de redigir email no aplicativo de emails, poderia solicitar o aplicativo câmera, de forma a permitir o compartilhamento de alguma foto. Uma \textit{activity} é implementada como uma subclasse de \texttt{Activity}.  

	\item \textbf{Services}

	Um \textit{service} é um componente que é executado em plano de fundo para processar operações de longa duração ou processar operações remotas. Um \textit{service} não provê uma interface com o usuário. Por exemplo, um \textit{service} pode tocar uma música em plano de fundo enquanto o usuário está usando um aplicativo diferente, ou ele pode buscar dados em um servidor remoto através da internet sem bloquear as interações do usuário com a \textit{activity}. Outros componente, como uma \textit{activity}, podem iniciar um \textit{service} e deixá-lo executar em plano de fundo. É possível interagir com um \textit{service} durante sua execução. Um \textit{service} é implementado como uma subclasse de \texttt{Service}.

	\item \textbf{Content Providers}

	Um \textit{content provider} gerencia um conjunto compartilhado de dados do aplicativo. Estes dados podem estar armazenados em arquivos de sistema, banco de dados SQLite, servidor remoto ou qualquer outro local de armazenamento que o aplicativo possa acessar. Através de \textit{content providers}, outros aplicativos podem consultar ou modificar (se o \textit{content provider} permitir) os dados. Por exemplo, a plataforma Android disponibiliza um \textit{content provider} que gerencia as informações dos contatos dos usuários. Desta forma, qualquer aplicativo, com as devidas permissões, pode consultar parte do \textit{content provider} (como \texttt{ContactsContract.Data}) para ler e escrever informações sobre um contato específico. Um \textit{content provider} é implementado como uma subclasse de \texttt{ContentProvider}.

	\item \textbf{Broadcast Receivers}

	Um \textit{broadcast receiver} é um componente que responde a mensagens enviadas pelo sistema. Muitas destas mensagens são originadas da plataforma Android, por exemplo, o desligamento da tela, baixo nível de bateria e assim por diante. Aplicativos de terceiros também podem enviar mensagens, por exemplo, informando que alguma operação foi concluída. No entanto, \textit{broadcast receivers} não possuem interface de usuário. Para informar o usuário que algo ocorreu, \textit{broadcast receivers} podem criar notificações. Um \textit{broadcast receiver} é implementado como uma subclasse de \texttt{BroadcastReceiver}.

\end{itemize}

Antes de a plataforma Android poder iniciar qualquer um dos componente supramencionados, a plataforma precisa saber que eles existem. Isso é feito através da leitura do arquivo \texttt{AndroidManifest.xml} do aplicativo (arquivo de manifesto). Este arquivo deve estar no diretório raiz do projeto do aplicativo e deve conter a declaração de todos os seus componentes.

O arquivo de manifesto é um arquivo XML e pode conter muitas outras informações além das declarações dos componentes do aplicativo, por exemplo:

\begin{itemize}
	\item Identificar qualquer permissão de usuário requerida pelo aplicativo, como acesso a internet, acesso a informações de contatos do usuário e assim por diante.

	\item Declarar o nível mínimo do Android requerido para o aplicativo, baseado em quais APIs são usadas pelo aplicativo.

	\item Declarar quais funcionalidades de sistema ou \textit{hardware} são usadas ou requeridas pelo aplicativo, por exemplo câmera, \textit{bluetooth} e assim por diante.

	\item Declarar outras APIs que são necessárias para uso do aplicativo (além do arcabouço de APIs do Android), como a biblioteca do Google Maps.
\end{itemize}

Os elementos usados no arquivo de manifesto são definidos pelo vocabulário XML do Android. Por exemplo, uma \textit{activity} pode ser declarada conforme o \textit{listing} \ref{lst:AndroidManifest}. \\

\begin{lstlisting}[
	language=XML, 
	caption={Arquivo \texttt{AndroidManifest.xml}}, 
	label={lst:AndroidManifest}
]
<?xml version="1.0" encoding="utf-8"?>
<manifest ... >
    <application android:icon="@drawable/app_icon.png" ... >
        <activity android:name="com.example.project.ExampleActivity"
                  android:label="@string/example_label" ... >
        </activity>
        ...
    </application>
</manifest>	
\end{lstlisting}

No elemento \texttt{<application>} o atributo \texttt{android:icon} aponta para o ícone, que é um recurso, que identifica o aplicativo. No elemento \texttt{<activity>}, o atributo \texttt{android:name} especifica o nome completamente qualificado da \textit{Activity}, que é uma classe que extende de \texttt{Activity}, e por fim, o atributo \texttt{android:label} especifica um texto para ser usado como título da \textit{Activity}.

Para declarar cada um dos quatro tipos de componentes, deve-se usar os elementos a seguir:
\begin{itemize}
	\item \texttt{<activity>} elemento para \textit{activities}.
	\item \texttt{<service>} elemento para \textit{services}.
	\item \texttt{<receiver>} elemento para \textit{broadcast receivers}.
	\item \texttt{<provider>} elemento para \textit{content providers}.
\end{itemize}

\subsection*{Recursos do Aplicativo}
\label{sec:AndroidResources}

Um aplicativo Android é composto por outros arquivos além de código Java, ele requer \textbf{recursos} como imagens, arquivos de áudio, e qualquer recurso relativo a apresentação visual do aplicativo \cite{AndroidFundamentals}. Também é possível definir animações, menus, estilos, cores e arquivos de \textit{layout} das \textit{activities}. Recursos costumam ser arquivos XML que usam o vocabulário definido pelo Android.

Um dos aspectos mais importantes de prover recursos separados do código-fonte é a habilidade de prover recursos alternativos para diferentes configurações de dispositivos como por exemplo idioma ou tamanho de tela. Este aspecto se torna mais importante conforme mais dispositivos são lançados com configurações diferentes. Segundo levantamento, em 2015 foram encontrados mais de 24 mil dispositivos diferentes com Android \cite{AndroidFragmentation}.

De forma a prover compatibilidade com diferentes configurações, deve-se organizar os recursos dentro do diretório \texttt{res} do projeto, usando sub-diretórios que agrupam os recursos por tipo e configuração. Para qualquer tipo de recurso, pode-se especificar uma opção padrão e outras alternativas. 

\begin{itemize}
	\item \textbf{Recursos padrões} são aqueles que devem ser usados independente de qualquer configuração ou quando não há um recurso alternativo que atenda a configuração atual. Por exemplo, arquivos de \textit{layout} padrão ficam em \texttt{res/layout}.

	\item \textbf{Recursos alternativos} são todos aqueles que foram desenhados para atender a uma configuração específica. Para especificar que um grupo de recursos é para ser usado em determinada configuração, basta adicionar um qualificador ao nome do diretório. Por exemplo, arquivos de \textit{layout} para quando o dispositivo está em posição de paisagem ficam em \texttt{res/layout-land}.
\end{itemize}

O Android irá aplicar automaticamente o recurso apropriado através da identificação da configuração corrente do dispositivo com os recursos disponíveis no aplicativo. Por exemplo, o recurso do tipo \textit{strings} pode conter textos usados nas interfaces do aplicativo. É possível traduzir estes textos em diferentes idiomas e salvá-los em arquivos separados. Desta forma, baseado no qualificador de idioma usado no nome do diretório deste tipo de recurso (por exemplo \texttt{res/values-fr} para o idioma frânces) e a configuração de idioma do dispositivo, o Android aplica o conjunto de \textit{strings} mais apropriado.

A seguir são listados os tipos de recursos que podem ser utilizados no Android \cite{AndroidResourceType}. Para cada tipo de recurso existe um conjunto de qualificadores que podem ser usados para prover recursos alternativos:

\begin{itemize}
	\item \textbf{Recursos de animações} Definem animações pré-determinadas. Ficam nos diretórios \texttt{res/anim} ou \texttt{res/animator}.

	\item \textbf{Recursos de lista de cores de estado} Definem recursos de cores que alteram baseado no estado da \textit{View}. Ficam no diretório \texttt{res/color}.	

	\item \textbf{Recursos de desenhos} Definem recursos gráficos como \textit{bitmap} ou XML. Ficam no diretório \texttt{res/drawable}.

	\item \textbf{Recursos de \textit{layouts}} Definem a parte visual da interface com o usuário. Ficam no diretório \texttt{res/layout}.

	\item \textbf{Recursos de menus} Definem os conteúdos dos menus da aplicação. Ficam no diretório \texttt{res/menu}.

	\item \textbf{Recursos de textos} Definem textos, conjunto de textos e plurais. Ficam no diretório \texttt{res/values}.

	\item \textbf{Recursos de estilos} Definem os estilos e e formatos para os elementos da interface com usuário. Ficam no diretório \texttt{res/values}.

	\item \textbf{Outros recursos} Ainda existem outros recursos como inteiros, \textit{booleanos}, dimensões, dentre outros. Ficam no diretório \texttt{res/values}.
\end{itemize}


\subsection*{Interfaces de Usuários}

Arquivos de layout são recursos localizados na pasta \texttt{res/layout} que possuem a extensão \texttt{.xml}. 

Todos os elementos de UI (Interface de Usuário, do inglês UI, \textit{User Interface}) de um aplicativo Android são construídos usando objetos do tipo \texttt{View} ou \texttt{ViewGroup}. Uma \texttt{View} é um objeto que desenha algo na tela do qual o usuário pode interagir. Um \texttt{ViewGroup} é um objeto que agrupa outras \texttt{View}s e \texttt{ViewGroup}s de forma a desenhar o layout da interface \cite{AndroidUIOverview}.

A UI para cada componente do aplicativo é definida usando uma hierarquia de objetos \texttt{View} e \texttt{ViewGroup}, como mostrado na figura \ref{fig:UIOverview}. Cada \texttt{ViewGroup} é um container invisível que organiza \texttt{View}s filhas, enquanto as \texttt{View}s filhas são caixas de texto, botões e outros componentes visuais que compoem a UI. Esta árvore hierárquica pode ser tão simples ou complexa quanto se precisar, mas quanto mais simples melhor o desempenho.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.7\textwidth]{ui-overview.png}
	\caption{Árvore hierárquica de \texttt{View}s e \texttt{ViewGroup}s do Android.}
	\label{fig:UIOverview}
\end{figure}

É possível criar um layout programaticamente, instanciando \texttt{View}s e \texttt{ViewGroup}s no código e construir a árvore hierárquica manualmente, no entanto, a forma mais simples e efetiva de definir um layout é través de um XML de layout. O XML de layout oferece uma estrutura legível aos olhos humanos, similar ao HTML, podendo ser utilizados elementos aninhados.

O vocabulário XML para declarar elementos de UI segue a estrutura de nome de classes e métodos, onde os nomes dos elementos correspondem aos nomes das classes e os atributos correspondem aos nomes dos métodos. De fato, a correspondência frequentemente é tão direta que é possível adivinhar qual atributo XML correspodne a qual método de classe, ou adivinhar qual a classe correspondente para determinado elemento. No entanto, algumas classes possuem pequenas diferenças como por exemplo, o elemento \texttt{<EditText>} tem o atributo \texttt{text} que correponde ao método \texttt{EditText.setText()}.

Um layout vertical simples com uma caixa de texto e um botão se parece com o código no listing \ref{lst:LayoutSample}.

\begin{lstlisting}[
	language=XML, 
	caption={Arquivo exemplo de layout.}, 
	label={lst:LayoutSample}
]
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout ...
              android:layout_width="fill_parent"
              android:layout_height="fill_parent"
              android:orientation="vertical">

    <TextView android:id="@+id/text"
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:text="I am a TextView" />

    <Button android:id="@+id/button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="I am a Button" />

</LinearLayout>
\end{lstlisting}

Quando um recurso de layout é carregado pelo aplicativo, o Android inicializa um objeto para cada elemento do layout, desta forma é possível recuperá-lo programaticamente para definir comportamentos, modificar o layout ou mesmo recuperar o estado. 

O Android provê uma série de elementos de UI comuns pré-prontos como: caixa de texto, botão, lista suspensa, dentre muitos outros. Desta forma, o desenvolvedor não precisa implementar do zero estes elementos básicos através de \texttt{View}s e \texttt{ViewGroup}s para escrever uma interface de usuário.

Cada subclasse de \texttt{ViewGroup} provê uma forma única de exibir o conteúdo dentro dele. Por exemplo, o \texttt{LinearLayout} organiza seu conteúdo de forma linear horizontalmente, um ao lado do outro, ou verticalmente, um abaixo do outro. O \texttt{RelativeLayout} permite especificar a posição de uma \texttt{View} relativa ao posicionamento de alguma outra \cite{AndroidLayouts}.

Quando o conteúdo é dinâmico ou não pré-determinado, como por exemplo uma lista de dados, pode-se usar um elemento que estende de \texttt{AdapterView} para popular o layout em momento de execução. Subclasses de \texttt{AdapterView} usam uma implementação de \texttt{Adapter} para carregar dados em seu layout. \texttt{Adapter}s agem como um intermediador entre o conteúdo a ser exibido e o layout, ele recupera o conteúdo e converte cada item, de uma lista por exemplo, dentro de uma ou mais \texttt{View}s.

Os elementos comumente usados para situações de conteúdo dinâmico ou não pré-determinado são: \texttt{ListView} e \texttt{GridView}. Para fazer o carregamento dos dados nestes elementos, o Android provê alguns \texttt{Adapter}s como por exemplo o \texttt{ArrayAdapter} que a partir de um \texttt{array} de dados popula os dados na \texttt{ListView} ou \texttt{GridView}.

\subsection*{Eventos de Interface}

On Android, there's more than one way to intercept the events from a user's interaction with your application. When considering events within your user interface, the approach is to capture the events from the specific View object that the user interacts with. The View class provides the means to do so.

Within the various View classes that you'll use to compose your layout, you may notice several public callback methods that look useful for UI events. These methods are called by the Android framework when the respective action occurs on that object. For instance, when a View (such as a Button) is touched, the onTouchEvent() method is called on that object. However, in order to intercept this, you must extend the class and override the method. However, extending every View object in order to handle such an event would not be practical. This is why the View class also contains a collection of nested interfaces with callbacks that you can much more easily define. These interfaces, called event listeners, are your ticket to capturing the user interaction with your UI.

While you will more commonly use the event listeners to listen for user interaction, there may come a time when you do want to extend a View class, in order to build a custom component. Perhaps you want to extend the Button class to make something more fancy. In this case, you'll be able to define the default event behaviors for your class using the class event handlers.
