%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setlength{\parindent}{0pt}
\setlength{\textheight}{22cm}
\setlength{\parskip}{0.2cm}

% Para aumentar o espaçamento entre as linhas
\linespread{1.2}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Reparo de plano por refinamento reverso}
\label{cap:reparo_de_plano_por_refinamento_reverso}

Este capítulo apresenta a estratégia de reparo de plano por refinamento reverso\index{refinamento!reverso} e do método heurístico\index{heurística} desenvolvido neste trabalho. 

\section{Refinamento reverso}

Para o reparo de plano não se pode utilizar diretamente o modelo de planejamento por refinamento, pois esta estratégia só permite adicionar ações, enquanto no reparo é preciso, além de adicionar, retirar ações. O reparo de plano constitui de duas atividades distintas: a remoção de ações que estejam impedindo o sucesso do plano e a ampliação do plano, por meio da adição de ações (\cite{Roman2004}). Por este motivo, é necessário incluir uma {\it estratégia de refinamento reverso} para o reparo de plano. \\

A remoção de restrições do plano parcial impede que o plano atinja seus objetivos. A adição de ações pode ser tratada como um planejamento normal, em que o plano parcial\index{plano!parcial} é ampliado (refinado) para satisfazer os objetivos. O Exemplo 5.1.1 ilustra uma situação em que apenas o reparo não é suficiente para que o plano atinja seu objetivo, sendo necessário um processo de refinamento reverso a fim de que o plano seja reparado. \\

\begin{Ex}
Suponha que exista um plano para um indivíduo ir a um encontro utilizando um carro. Entretanto, ao se aproximar do carro, ele nota que um dos pneus está furado. Um simples reparo para este plano poderia ser adicionar ações para a troca do pneu por um sobressalente e, então, prosseguir com o resto do plano, o que corresponderia à adição de ações ao plano falho. Porém, supondo que este é um encontro muito importante para o qual o indivíduo não quer se atrasar e, neste caso, trocar o pneu poderia levar muito tempo, seria melhor remover do plano a ação de dirigir o carro e substituí-la por ações que utilizem um táxi. Nesse caso, algumas ações do plano seriam removidas e outras, adicionadas. \\
\end{Ex}

Portanto, para reparar um plano, um planejador não deve apenas empregar
uma estratégia de refinamento\index{refinamento} com o intuito de ampliar o plano por meio de ações que
atingirão os objetivos. O planejador tem, também, que empregar uma
estratégia de {\it refinamento reverso\index{refinamento!reverso}} para diminuir as restrições do
plano parcial (removendo ações do plano que estejam obstruindo uma
solução). \\

% Em \cite{Roman2005} foi proposta uma heurística para o refinamento reverso que usa... . Porém, não está claro com... e como implementar tal heurística. 
%A heurística implementada nessa dissertação usa algumas idéias propostas pro Krogt, a saber:
%\begin{itemize}
 %\item cria uma versão relaxada do problema;
%\item desconsidera os efeitos negados;
%\item desconsidera as pré-condições negadas. 
%\end{itemize}
%A diferença entre a heurística proposta aqui e a de Krogt é que a árvore de de ações a serem renovadas é enumerada...

No artigo \cite{Roman2005} os autores propõem uma ampliação do modelo do planejamento por refinamento que permite que estratégias de refinamento reverso sejam empregadas. A proposta original de Roman Krogt e Mathijs M. Weerdt pode ser melhor compreendida através da Figura 5.1.

\begin{center}
  \begin{figure}[ht!]
    \centering
	\label{fig:arquitetura_sistema_reparo_plano}
    \includegraphics[angle=0,width=0.80\textwidth]{./img/sistema_reparo_plano.ps}
    \caption[Arquitetura de funcionamento do sistema de reparo de plano]{Arquitetura de funcionamento do sistema de reparo de plano.}
  \end{figure}
\end{center}

%% [TODO: 
%% o Historico so deve ser incluido no texto quando os algoritmos 
%% também tiverem suporte a historico. Isto é, que a funcao de heuristica
%% seja chamada mais de uma vez, e que ela tenha como parametro o historico
%% (H) para armazenar ate onde ja analisou;
%% ]

%A seguir,
%é introduzido um {\it histórico} $H$ para armazenar o caminho e os
%refinamentos reversos, a fim de ser capaz de prevenir {\it loops}
%inifinitos. A cada solicitação de uma da heurítica de refinamento reverso, é
%atualizado o histórico de modo a refletir que planos parciais já foram
%considerados.

Uma versão adaptada desta proposta de ampliação pode ser vista no Algoritmo \ref{algoritmo_reparo_plano}. Dado um plano $\pi$, parcialmente executado, o estado em que o plano apresentou falha, o domínio e a meta do problema, inicialmente, escolhe-se {\it refinar} o plano, isto é, adicionar refinamentos. Se não for encontrada uma solução, então tenta-se {\it remover refinamentos} do plano. Para executar o modelo de refinamento reverso no plano, é necessário selecionar uma heurística de refinamento reverso e aplicá-la ao plano parcial. O refinamento ocorre no trecho do algoritmo referente ao planejamento normal. \\

O Algoritmo \ref{algoritmo_reparo_plano} funciona da seguinte forma: inicialmente ele atribui o estado em que a execução do plano original deveria estar caso não tivesse ocorrido a falha, a uma variável ($e_g$). A seguir, o algoritmo chama um método de planejamento que tenta encontrar um plano que leve a execução do estado atual $s$ ao estado desejado $e_g$, atribuindo o resultado a $\pi_r$. Na próxima fase, os comandos descritos nas linhas 4 e 5 verificam se o resultado $\pi_r$ é diferente de falha. Caso seja, o algoritmo devolve o reparo de plano encontrado pelo planejador concatenado ao plano original. Isto significa que somente a adição de novas ações conseguiu reparar o plano falho. \\

Entretanto, caso o resultado de $\pi_r$ retorne uma falha, um método heurístico, que recebe como entrada o estado atual $s$ e o plano original $\pi$, é chamado. Este método devolve como resposta uma estrutura de dados composta por uma lista de pares de {\tt estado} e {\tt quantidade}, que indica quais conjuntos de ações do plano original devem ser considerados para a remoção. A proposta é fazer com que a execução do plano retorne ao {\tt estado} do plano original após a remoção da {\tt quantidade} necessária de ações. Ocorre, então, um processo de repetição, onde cada par de {\tt estado} e {\tt quantidade} é testado a fim de que o plano saia do estado atual $s$ e consiga alcançar o estado $e_g$, atribuindo o resultado a $\pi_r$. \\

Os próximos comandos verificam se o resultado $\pi_r$ é diferente de falha. Em caso afirmativo, remove-se do plano original a {\tt quantidade} de ações. Em seguida o algoritmo devolve o reparo de plano encontrado pelo planejador concatenado ao plano original. Portanto, neste caso, para reparar o plano foi necessária a remoção de um conjunto de ações do plano original e a adição de um conjunto de novas ações. Se nenhum dos pares for capaz de devolver uma resposta diferente de falha, então um replanejamento\index{replanejamento} é feito. O método de planejamento tenta encontrar um plano que saia do estado atual $s$ e consiga alcançar o objetivo $S_g$, atribuindo o resultado a $\pi_r$. Mais uma vez o algoritmo verifica se o resultado $\pi_r$ é diferente de falha. Caso seja, o algoritmo devolve o plano encontrado pelo planejador. \\

Uma versão do Algoritmo \ref{algoritmo_reparo_plano} sem heurística pode ser visualizada no Algoritmo \ref{algoritmo_reparo_plano_sem_heuristica}.

\begin{algorithm}
	\label{algoritmo_reparo_plano_sem_heuristica}
	\caption[Algoritmo de reparo de plano sem heurística]{Algoritmo de Reparo de Plano sem Heurística.}
	\Entrada{Trecho do plano original ainda não executado $\pi$, Estado atual $s$, Domínio $\mathcal{D}$, Objetivo $S_g$}
	\Saida{Plano reparado $\pi$ ou {\it falha}}
	\Inicio{
	$e_g \leftarrow $ recuperaEstado($\pi$)\;
	$\pi_r \leftarrow $ planejador($s$, $e_g$, $\mathcal{D}$)\;
	\Se{$\pi_r \ne $ {\it falha}}
		{{\bf devolve} $\pi_r + \pi$\;}
	\Senao{
		\Para{todos os conjuntos de ações seqüenciais $c_a$ de $\pi$}{
			\Se{$\pi \ne c_a$}{
				$e_g \leftarrow $ recuperaEstado($\pi - c_a$)\;
				$\pi_r \leftarrow $ planejador($s$, $e_g$, $\mathcal{D}$)\;
				\Se{$\pi_r \ne $ {\it falha}}{
					$\pi \leftarrow \pi - c_a$\;
					{\bf devolve} $\pi_r + \pi$\;
				}
			}
		}
	}
	$\pi_r \leftarrow $ planejador($s$, $S_g$, $\mathcal{D}$)\;
	\Se{$\pi_r \ne $ {\it falha}}
		{{\bf devolve} $\pi_r$\;}
	{\bf devolve} $falha$\;
	}
\end{algorithm}

\begin{algorithm}
	\label{algoritmo_reparo_plano}
	\caption[Algoritmo de reparo de plano]{Algoritmo de Reparo de Plano.}
	\Entrada{Trecho do plano original ainda não executado $\pi$, Estado atual $s$, Domínio $\mathcal{D}$, Objetivo $S_g$}
	\Saida{Plano reparado $\pi$ ou {\it falha}}
	\Inicio{
	$e_g \leftarrow $ recuperaEstado($\pi$)\;
	$\pi_r \leftarrow $ planejador($s$, $e_g$, $\mathcal{D}$)\;
        \Se{$\pi_r \ne $ {\it falha}}
            {{\bf devolve} $\pi_r + \pi$\;}
        \Senao{
            lista[] $\leftarrow$ heurística($s$, $\pi$)\;
            \Repita{$lista[]$ estiver vazia}{
                $e_g \leftarrow $ lista.primeiroElemento().estado\;
		$\pi_r \leftarrow $ planejador($s$, $e_g$, $\mathcal{D}$)\;
                \Se{$\pi_r \ne $ {\it falha}}{
                    $\pi \leftarrow \pi$.remove($lista.primeiroElemento().quantidade$)\;
                    {\bf devolve} $\pi_r + \pi$\;
                }
                removePrimeiroElemento($lista[]$)\;
            }
	}
	$\pi_r \leftarrow $ planejador($s$, $S_g$, $\mathcal{D}$)\;
        \Se{$\pi_r \ne $ {\it falha}}
            {{\bf devolve} $\pi_r$\;}
	{\bf devolve} $falha$\;
    }
\end{algorithm}

\section{Heurística\index{heurística}} 
A forma mais comum de se adicionar conhecimento a respeito de um problema ao algoritmo de busca é por meio de funções heurísticas. Uma função heurística pode ser denotada por $h(n)$:

\begin{quote}
$h(n)\ =\ ${\small custo\ estimado\ do\ caminho\ mais\ econômico\ do\ nó\ $n$\ até\ um\ nó\ objetivo.}
\end{quote}

Se $n$ é um nó objetivo, então $h(n) = 0$. \\

Uma heurística é {\it admissível\index{heurística!admissível}} quando $h(n)$ 
não superestima o custo para alcançar o objetivo \cite{Russell2002}. Além disso, ela é
otimista por natureza, pois pressupõe que o custo da solução do problema é
 menor ou igual ao seu custo real. Isto ocorre porque a heurística ajuda a descartar os nós de maior custo,
assegurando que o caminho ótimo seja sempre o primeiro a ser escolhido. \\

Um modo de pensar sobre o problema da criação de heurísticas é ter
como base um {\it problema relaxado}, no qual um problema é encarado com menos restrições. O custo de
uma solução ótima para um problema relaxado é uma heurística\cite{Roman2005}
admissível para o problema original \cite{Russell2002}. \\


A idéia básica da construção de uma heurística para o planejamento reverso é observar os efeitos das ações e os objetivos que
devem ser alcançados, e avaliar quantas ações serão necessárias para
alcançar todos os objetivos. \\

Uma sugestão inicial é relaxar o problema removendo todas as
pré-condições das ações. Então, toda ação será aplicável e qualquer
literal poderá ser alcançado em um passo. \\

Uma heurística mais interessante seria, além de eliminar todas as pré-condições: (1) eliminar os efeitos negativos das ações e (2) considerar as interações positivas entre ações. Isto é, se uma ação tem o efeito $X\wedge \lnot Y$ no problema
original, terá somente o efeito $X$ no problema relaxado, ou seja, nenhuma ação pode excluir os literais alcançados por outro e, portanto, não é preciso se preocupar com interações negativas entre subplanos. Para que a união dos efeitos
positivos dessas ações satisfaça o objetivo, calcula-se o
número mínimo de ações necessárias. Por exemplo, considere o objetivo ($X$, $Y$, $Z$) para o domínio descrito pelas as seguintes ações:

\begin{quote}

ação($\alpha$, EFEITO: $X\wedge Q$) \\
ação($\beta$, EFEITO: $Y\wedge Z\wedge R$) \\
ação($\delta$, EFEITO: $Y\wedge Q\wedge R$) 
\end{quote}

O conjunto de objetivos $\lbrace X, Y, Z \rbrace$ pode ser alcançado pelas ações
$\lbrace \alpha, \beta \rbrace$ sendo a heurística igual a $2$, considerando custos unitários. É possível notar que a ação $\delta$ não é considerada, pois ela adiciona Y, que já é incluído pela ação $\beta$ (interação positiva).\\

A estratégia utilizada neste projeto foi gerar problemas
relaxados eliminando-se tanto as pré-condições negativas quanto os efeitos negativos e ainda, considerando uma ordem total entre as ações do plano para o cálculo da heurística. \\

%Este tipo de heurística é classificada como {\it lista de eliminação vazia} \cite{???}.

A abordagem para o uso destas heurísticas de planejamento para reparo de planos é ilustrada na Figura 5.2.
%TODO: ~\ref{heuristica_refinamento}.
De um lado, temos o plano corrente $P$ que não será refinado. É computado, então, o número de planos que resulta da remoção de ações de $P$. Para cada um destes planos resultantes, utiliza-se uma heurística para estimar a quantidade de trabalho necessária para transformar este plano em um plano válido, isto é, calcula-se um valor heurístico para cada um destes planos. O plano que obtiver o melhor (mais baixo) valor heurístico é selecionado e o planejamento (refinamento) é utilizado para completar este plano. Se o planejador não puder produzir uma solução (o que pode acontecer porque a heurística não é perfeita), um outro refinamento reverso é escolhido. É importante notar que somente se aplica o passo do refinamento reverso ao plano inicial $P$. \\

Um outro ponto de vista importante sobre este procedimento que deve ser levado em consideração é o espaço de busca atravessado. Inicialmente, o método de reparo de plano fornece o plano corrente $P$ para ser adaptado. Este plano pode estar localizado em uma parte do espaço de busca em que é muito difícil encontrar uma solução por refinamento (isto é, adicionando apenas ações), se tal solução existir. A heurística\index{heurística} de refinamento reverso avalia as condições do espaço de busca ao redor destes planos parciais, isto é, calcula um valor heurístico que expressa a facilidade com que o plano pode ser ampliado. Após ser identificada a melhor opção, é iniciado o processo de refinamento\index{refinamento}.

\begin{center}
    \begin{figure}[!ht]
		\includegraphics[angle=270, width=1.0\textwidth]{./img/heuristica.ps}
		\label{heuristica_refinamento} 
		\caption[Heurística para refinamento reverso]{Heurística de refinamento reverso. Do plano original à esquerda foram derivados $n$ subplanos e calculados seus respectivos valores heurísticos ($h_1, \ldots, h_n$). A região cinza representa a parte do plano que já foi executada.}
		\end{figure}
\end{center}

A heurística\index{heurística} só é utilizada nos casos em que o refinamento de plano falha ao tentar encontrar um reparo\index{reparo}. Seu objetivo é avaliar qual é o melhor conjunto de ações a serem removidas, de modo que, a partir do novo estado inicial, possa ser encontrado um reparo, por meio de refinamento, que satisfaça o novo estado-objetivo. \\

A heurítica desenvolvida neste trabalho é baseada na remoção de conjuntos de ações seqüenciais e crescentes. Os conjuntos de ações removidas a serem avaliados começam com a primeira ação não executada. A partir daí, cada novo conjunto é incrementado até que todas as ações tenham sido adicionadas. Inicia-se com uma ação, depois duas e assim sucessivamente até que todas as ações sejam incorporadas. Para cada conjunto de ações removidas um novo estado é gerado. Este estado contém
todas as pré-condições necessárias para executar todas as demais ações (não removidas) até o final do plano, como pode
ser observado na Figura 5.3.
%TODO: ~\ref{heuristica_refinamento_detalhado}.

\begin{center}
    \begin{figure}[!ht]  %\center
		\includegraphics[angle=270, width=1.0\textwidth]{./img/heuristica2.ps}
		\label{heuristica_refinamento_detalhado} 
		\caption[Características da heurística para refinamento reverso]{Para cada conjunto de ações removidas, um estado novo é gerado. Este estado contém todas as pré-condições necessárias para todas as ações não removidas. A heurística calcula a distância entre o estado atual $F$ e o estado novo $E$. A região cinza representa a parte do plano que já foi executada.}
		\end{figure}
\end{center}

O Algoritmo \ref{heuristica} tem como objetivo devolver uma lista de pares de {\tt estado} e {\tt valor} e funciona da seguinte forma: para todos os conjuntos de ações possíveis de serem removidas, um estado com as condições necessárias para executar o restante das ações (não removidas) do plano original é gerado ($E_g$). O processo é iniciado, marcando-se como visitado o estado atual ($s$), e este é inserido na fila $s$ com o valor igual a $0$. Este valor serve para indicar a distância entre o estado atual e o estado inserido na fila. A partir da linha 6 até a linha 19, para cada elemento $f$ da $fila$, verifica se o mesmo está contido em $E_g$. Se estiver, insere na lista de $resultados$, e o algoritmo devolve $resultados$ se tiver $E_g$ contido. Seqüencialmente, entre as linhas 12 e 18, para todas as ações $a$ aplicáveis ao estado $f.estado$, atribui a $s_{novo}$ o estado resultante após a execução da ação (linha 15). Sendo que esta execução não considera os efeitos negativos da ação. Verifica se o estado $s_{novo}$ não está marcado como visitado. Caso não esteja, marca como visitado e insere na $fila$ com o valor de $f.valor$ incrementado em um. Deste modo a estrutura da fila terá um conjunto de estados e valores que indicam a distância em relação ao estado atual $s$. (linha 16 a 18). Sendo que o conjunto de elementos devolvidos pelo algoritmo estará ordenado de acordo com o $valor$ heurístico atribuído. \\



\begin{algorithm}
	\label{heuristica}
	\caption[Heurística para refinamento reverso]{Heurística para Refinamento Reverso}
	\Entrada{Estado Atual $s$, Plano Original $\pi$}
	\Saida{Lista de pares de {\it Estado e valor}}
	\Inicio{
        $E_g \leftarrow$ geraListaEstados($\pi$)\;
        \ \\ %lista$<$valor, Estado$>$ fila[], resultado[]\;

        visitado($s$)\;
        fila.insere($0$, $s$)\;

        \Repita{fila estiver vazia}{
            $f \leftarrow$ fila.retiraInício()\;
            \Se{$f$.estado $\subset E_g$.estado}{
                resultado.insere($f$)\;
                \Se{$E_g \subseteq$ resultado}{
                    {\bf devolve} resultado\;
                }
            }
            \Para{toda ação $a$ aplicável ao estado $f$.estado}{
                {\small
                // Executa a ação $a$ no estado $f.estado$ \\
                // sem considerar efeitos negativo 
                } \\
                $s_{novo} \leftarrow$ executa($f$.estado, $a$)\;
                \Se{não visitado($s_{novo}$)}{
                    visitado($s_{novo}$)\;
                    fila.insere($f$.valor $+ 1$, $s_{novo}$)\;
                }
            }
        }
	{\bf devolve} resultado\;
    }
\end{algorithm}

%A estratégia da heurística\index{heurística} utilizada para refinamento reverso\index{refinamento!reverso} funciona da seguinte forma: após ter sido gerado um conjunto de estados $E_g$ baseados nos grupos de ações removidas, marca-se o estado atual como visitado e o insere com valor es\-pe\-cí\-fi\-co (iniciado com $0$) na fila de estados a serem analisados. Este valor indica a distância entre o estado atual e o estado inicial e o grau de dificuldade entre os dois estados. \\
%
%Em seguida, o algoritmo entra em um bloco de repetição, onde fica até que ocorra uma interrupção, uma vez que já se calculou a distância entre todos os estados-objetivo, ou porque não existe mais nenhum elemento na fila de estados a ser analisado, de modo que a cada iteração do bloco de repetição é retirado o primeiro elemento da fila para análise. Inicialmente, deve-se verificar se o elemento faz parte do conjunto de $E_g$. Em caso afirmativo, ele é adicionado a um conjunto de resultados. O conjunto de resultados, assim como a fila de estados a serem analisados, contém o valor que indica a distância entre o estado atual e o estado inicial. \\
%
%A análise das possíveis alternativas é feita da seguinte maneira: para todas as ações aplicáveis ao elemento atual, executa-se uma ação sem considerar os efeitos negados. Se o novo estado resultante da execução ainda não tiver sido visitado, deve-se marcá-lo como visitado e adicioná-lo à fila de estados, com o valor es\-pe\-cí\-fi\-co do elemento corrente incrementado em um. \\


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%O sistema de reparo de plano por refinamento reverso é uma técnica ainda pouco explorada na área de planejamento. Um dos estudos realizados nesta área envolve o sistema \ac{POPR}\index{POPR} desenvolvido por Roman Krogt e Mathijs M. Weerdt.  \\

%No artigo \cite{Roman2005} os autores propõem uma maneira de utilizar o planejador VHPOP, com algumas modificações, para escolher quais ações devem ser removidas do plano a fim de que ele atinja seus objetivos. Entretanto, este sistema não se encontra disponível para domínio público. \\




